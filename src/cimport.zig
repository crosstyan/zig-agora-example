pub const __builtin_bswap16 = @import("std").zig.c_builtins.__builtin_bswap16;
pub const __builtin_bswap32 = @import("std").zig.c_builtins.__builtin_bswap32;
pub const __builtin_bswap64 = @import("std").zig.c_builtins.__builtin_bswap64;
pub const __builtin_signbit = @import("std").zig.c_builtins.__builtin_signbit;
pub const __builtin_signbitf = @import("std").zig.c_builtins.__builtin_signbitf;
pub const __builtin_popcount = @import("std").zig.c_builtins.__builtin_popcount;
pub const __builtin_ctz = @import("std").zig.c_builtins.__builtin_ctz;
pub const __builtin_clz = @import("std").zig.c_builtins.__builtin_clz;
pub const __builtin_sqrt = @import("std").zig.c_builtins.__builtin_sqrt;
pub const __builtin_sqrtf = @import("std").zig.c_builtins.__builtin_sqrtf;
pub const __builtin_sin = @import("std").zig.c_builtins.__builtin_sin;
pub const __builtin_sinf = @import("std").zig.c_builtins.__builtin_sinf;
pub const __builtin_cos = @import("std").zig.c_builtins.__builtin_cos;
pub const __builtin_cosf = @import("std").zig.c_builtins.__builtin_cosf;
pub const __builtin_exp = @import("std").zig.c_builtins.__builtin_exp;
pub const __builtin_expf = @import("std").zig.c_builtins.__builtin_expf;
pub const __builtin_exp2 = @import("std").zig.c_builtins.__builtin_exp2;
pub const __builtin_exp2f = @import("std").zig.c_builtins.__builtin_exp2f;
pub const __builtin_log = @import("std").zig.c_builtins.__builtin_log;
pub const __builtin_logf = @import("std").zig.c_builtins.__builtin_logf;
pub const __builtin_log2 = @import("std").zig.c_builtins.__builtin_log2;
pub const __builtin_log2f = @import("std").zig.c_builtins.__builtin_log2f;
pub const __builtin_log10 = @import("std").zig.c_builtins.__builtin_log10;
pub const __builtin_log10f = @import("std").zig.c_builtins.__builtin_log10f;
pub const __builtin_abs = @import("std").zig.c_builtins.__builtin_abs;
pub const __builtin_fabs = @import("std").zig.c_builtins.__builtin_fabs;
pub const __builtin_fabsf = @import("std").zig.c_builtins.__builtin_fabsf;
pub const __builtin_floor = @import("std").zig.c_builtins.__builtin_floor;
pub const __builtin_floorf = @import("std").zig.c_builtins.__builtin_floorf;
pub const __builtin_ceil = @import("std").zig.c_builtins.__builtin_ceil;
pub const __builtin_ceilf = @import("std").zig.c_builtins.__builtin_ceilf;
pub const __builtin_trunc = @import("std").zig.c_builtins.__builtin_trunc;
pub const __builtin_truncf = @import("std").zig.c_builtins.__builtin_truncf;
pub const __builtin_round = @import("std").zig.c_builtins.__builtin_round;
pub const __builtin_roundf = @import("std").zig.c_builtins.__builtin_roundf;
pub const __builtin_strlen = @import("std").zig.c_builtins.__builtin_strlen;
pub const __builtin_strcmp = @import("std").zig.c_builtins.__builtin_strcmp;
pub const __builtin_object_size = @import("std").zig.c_builtins.__builtin_object_size;
pub const __builtin___memset_chk = @import("std").zig.c_builtins.__builtin___memset_chk;
pub const __builtin_memset = @import("std").zig.c_builtins.__builtin_memset;
pub const __builtin___memcpy_chk = @import("std").zig.c_builtins.__builtin___memcpy_chk;
pub const __builtin_memcpy = @import("std").zig.c_builtins.__builtin_memcpy;
pub const __builtin_expect = @import("std").zig.c_builtins.__builtin_expect;
pub const __builtin_nanf = @import("std").zig.c_builtins.__builtin_nanf;
pub const __builtin_huge_valf = @import("std").zig.c_builtins.__builtin_huge_valf;
pub const __builtin_inff = @import("std").zig.c_builtins.__builtin_inff;
pub const __builtin_isnan = @import("std").zig.c_builtins.__builtin_isnan;
pub const __builtin_isinf = @import("std").zig.c_builtins.__builtin_isinf;
pub const __builtin_isinf_sign = @import("std").zig.c_builtins.__builtin_isinf_sign;
pub const __has_builtin = @import("std").zig.c_builtins.__has_builtin;
pub const __builtin_assume = @import("std").zig.c_builtins.__builtin_assume;
pub const __builtin_unreachable = @import("std").zig.c_builtins.__builtin_unreachable;
pub const __builtin_constant_p = @import("std").zig.c_builtins.__builtin_constant_p;
pub const __builtin_mul_overflow = @import("std").zig.c_builtins.__builtin_mul_overflow;
pub const ptrdiff_t = c_long;
pub const wchar_t = c_uint;
pub const max_align_t = extern struct {
    __clang_max_align_nonce1: c_longlong align(8),
    __clang_max_align_nonce2: c_longdouble align(16),
};
pub const gint8 = i8;
pub const guint8 = u8;
pub const gint16 = c_short;
pub const guint16 = c_ushort;
pub const gint32 = c_int;
pub const guint32 = c_uint;
pub const gint64 = c_long;
pub const guint64 = c_ulong;
pub const gssize = c_long;
pub const gsize = c_ulong;
pub const goffset = gint64;
pub const gintptr = c_long;
pub const guintptr = c_ulong;
pub const GPid = c_int;
pub const __u_char = u8;
pub const __u_short = c_ushort;
pub const __u_int = c_uint;
pub const __u_long = c_ulong;
pub const __int8_t = i8;
pub const __uint8_t = u8;
pub const __int16_t = c_short;
pub const __uint16_t = c_ushort;
pub const __int32_t = c_int;
pub const __uint32_t = c_uint;
pub const __int64_t = c_long;
pub const __uint64_t = c_ulong;
pub const __int_least8_t = __int8_t;
pub const __uint_least8_t = __uint8_t;
pub const __int_least16_t = __int16_t;
pub const __uint_least16_t = __uint16_t;
pub const __int_least32_t = __int32_t;
pub const __uint_least32_t = __uint32_t;
pub const __int_least64_t = __int64_t;
pub const __uint_least64_t = __uint64_t;
pub const __quad_t = c_long;
pub const __u_quad_t = c_ulong;
pub const __intmax_t = c_long;
pub const __uintmax_t = c_ulong;
pub const __dev_t = c_ulong;
pub const __uid_t = c_uint;
pub const __gid_t = c_uint;
pub const __ino_t = c_ulong;
pub const __ino64_t = c_ulong;
pub const __mode_t = c_uint;
pub const __nlink_t = c_uint;
pub const __off_t = c_long;
pub const __off64_t = c_long;
pub const __pid_t = c_int;
pub const __fsid_t = extern struct {
    __val: [2]c_int,
};
pub const __clock_t = c_long;
pub const __rlim_t = c_ulong;
pub const __rlim64_t = c_ulong;
pub const __id_t = c_uint;
pub const __time_t = c_long;
pub const __useconds_t = c_uint;
pub const __suseconds_t = c_long;
pub const __suseconds64_t = c_long;
pub const __daddr_t = c_int;
pub const __key_t = c_int;
pub const __clockid_t = c_int;
pub const __timer_t = ?*anyopaque;
pub const __blksize_t = c_int;
pub const __blkcnt_t = c_long;
pub const __blkcnt64_t = c_long;
pub const __fsblkcnt_t = c_ulong;
pub const __fsblkcnt64_t = c_ulong;
pub const __fsfilcnt_t = c_ulong;
pub const __fsfilcnt64_t = c_ulong;
pub const __fsword_t = c_long;
pub const __ssize_t = c_long;
pub const __syscall_slong_t = c_long;
pub const __syscall_ulong_t = c_ulong;
pub const __loff_t = __off64_t;
pub const __caddr_t = [*c]u8;
pub const __intptr_t = c_long;
pub const __socklen_t = c_uint;
pub const __sig_atomic_t = c_int;
pub const clock_t = __clock_t;
pub const time_t = __time_t;
pub const struct_tm = extern struct {
    tm_sec: c_int,
    tm_min: c_int,
    tm_hour: c_int,
    tm_mday: c_int,
    tm_mon: c_int,
    tm_year: c_int,
    tm_wday: c_int,
    tm_yday: c_int,
    tm_isdst: c_int,
    tm_gmtoff: c_long,
    tm_zone: [*c]const u8,
};
pub const struct_timespec = extern struct {
    tv_sec: __time_t,
    tv_nsec: __syscall_slong_t,
};
pub const clockid_t = __clockid_t;
pub const timer_t = __timer_t;
pub const struct_itimerspec = extern struct {
    it_interval: struct_timespec,
    it_value: struct_timespec,
};
pub const union_sigval = extern union {
    sival_int: c_int,
    sival_ptr: ?*anyopaque,
};
pub const __sigval_t = union_sigval;
pub const union_pthread_attr_t = extern union {
    __size: [64]u8,
    __align: c_long,
};
pub const pthread_attr_t = union_pthread_attr_t;
const struct_unnamed_2 = extern struct {
    _function: ?fn (__sigval_t) callconv(.C) void,
    _attribute: [*c]pthread_attr_t,
};
const union_unnamed_1 = extern union {
    _pad: [12]c_int,
    _tid: __pid_t,
    _sigev_thread: struct_unnamed_2,
};
pub const struct_sigevent = extern struct {
    sigev_value: __sigval_t,
    sigev_signo: c_int,
    sigev_notify: c_int,
    _sigev_un: union_unnamed_1,
};
pub const pid_t = __pid_t;
pub const struct___locale_data = opaque {};
pub const struct___locale_struct = extern struct {
    __locales: [13]?*struct___locale_data,
    __ctype_b: [*c]const c_ushort,
    __ctype_tolower: [*c]const c_int,
    __ctype_toupper: [*c]const c_int,
    __names: [13][*c]const u8,
};
pub const __locale_t = [*c]struct___locale_struct;
pub const locale_t = __locale_t;
pub extern fn clock() clock_t;
pub extern fn time(__timer: [*c]time_t) time_t;
pub extern fn difftime(__time1: time_t, __time0: time_t) f64;
pub extern fn mktime(__tp: [*c]struct_tm) time_t;
pub extern fn strftime(noalias __s: [*c]u8, __maxsize: usize, noalias __format: [*c]const u8, noalias __tp: [*c]const struct_tm) usize;
pub extern fn strftime_l(noalias __s: [*c]u8, __maxsize: usize, noalias __format: [*c]const u8, noalias __tp: [*c]const struct_tm, __loc: locale_t) usize;
pub extern fn gmtime(__timer: [*c]const time_t) [*c]struct_tm;
pub extern fn localtime(__timer: [*c]const time_t) [*c]struct_tm;
pub extern fn gmtime_r(noalias __timer: [*c]const time_t, noalias __tp: [*c]struct_tm) [*c]struct_tm;
pub extern fn localtime_r(noalias __timer: [*c]const time_t, noalias __tp: [*c]struct_tm) [*c]struct_tm;
pub extern fn asctime(__tp: [*c]const struct_tm) [*c]u8;
pub extern fn ctime(__timer: [*c]const time_t) [*c]u8;
pub extern fn asctime_r(noalias __tp: [*c]const struct_tm, noalias __buf: [*c]u8) [*c]u8;
pub extern fn ctime_r(noalias __timer: [*c]const time_t, noalias __buf: [*c]u8) [*c]u8;
pub extern var __tzname: [2][*c]u8;
pub extern var __daylight: c_int;
pub extern var __timezone: c_long;
pub extern var tzname: [2][*c]u8;
pub extern fn tzset() void;
pub extern var daylight: c_int;
pub extern var timezone: c_long;
pub extern fn timegm(__tp: [*c]struct_tm) time_t;
pub extern fn timelocal(__tp: [*c]struct_tm) time_t;
pub extern fn dysize(__year: c_int) c_int;
pub extern fn nanosleep(__requested_time: [*c]const struct_timespec, __remaining: [*c]struct_timespec) c_int;
pub extern fn clock_getres(__clock_id: clockid_t, __res: [*c]struct_timespec) c_int;
pub extern fn clock_gettime(__clock_id: clockid_t, __tp: [*c]struct_timespec) c_int;
pub extern fn clock_settime(__clock_id: clockid_t, __tp: [*c]const struct_timespec) c_int;
pub extern fn clock_nanosleep(__clock_id: clockid_t, __flags: c_int, __req: [*c]const struct_timespec, __rem: [*c]struct_timespec) c_int;
pub extern fn clock_getcpuclockid(__pid: pid_t, __clock_id: [*c]clockid_t) c_int;
pub extern fn timer_create(__clock_id: clockid_t, noalias __evp: [*c]struct_sigevent, noalias __timerid: [*c]timer_t) c_int;
pub extern fn timer_delete(__timerid: timer_t) c_int;
pub extern fn timer_settime(__timerid: timer_t, __flags: c_int, noalias __value: [*c]const struct_itimerspec, noalias __ovalue: [*c]struct_itimerspec) c_int;
pub extern fn timer_gettime(__timerid: timer_t, __value: [*c]struct_itimerspec) c_int;
pub extern fn timer_getoverrun(__timerid: timer_t) c_int;
pub extern fn timespec_get(__ts: [*c]struct_timespec, __base: c_int) c_int;
pub const gchar = u8;
pub const gshort = c_short;
pub const glong = c_long;
pub const gint = c_int;
pub const gboolean = gint;
pub const guchar = u8;
pub const gushort = c_ushort;
pub const gulong = c_ulong;
pub const guint = c_uint;
pub const gfloat = f32;
pub const gdouble = f64;
pub const gpointer = ?*anyopaque;
pub const gconstpointer = ?*const anyopaque;
pub const GCompareFunc = ?fn (gconstpointer, gconstpointer) callconv(.C) gint;
pub const GCompareDataFunc = ?fn (gconstpointer, gconstpointer, gpointer) callconv(.C) gint;
pub const GEqualFunc = ?fn (gconstpointer, gconstpointer) callconv(.C) gboolean;
pub const GDestroyNotify = ?fn (gpointer) callconv(.C) void;
pub const GFunc = ?fn (gpointer, gpointer) callconv(.C) void;
pub const GHashFunc = ?fn (gconstpointer) callconv(.C) guint;
pub const GHFunc = ?fn (gpointer, gpointer, gpointer) callconv(.C) void;
pub const GCopyFunc = ?fn (gconstpointer, gpointer) callconv(.C) gpointer;
pub const GFreeFunc = ?fn (gpointer) callconv(.C) void;
pub const GTranslateFunc = ?fn ([*c]const gchar, gpointer) callconv(.C) [*c]const gchar; // /usr/include/glib-2.0/glib/gtypes.h:521:11: warning: struct demoted to opaque type - has bitfield
const struct_unnamed_3 = opaque {};
pub const union__GDoubleIEEE754 = extern union {
    v_double: gdouble,
    mpn: struct_unnamed_3,
};
pub const GDoubleIEEE754 = union__GDoubleIEEE754; // /usr/include/glib-2.0/glib/gtypes.h:512:11: warning: struct demoted to opaque type - has bitfield
const struct_unnamed_4 = opaque {};
pub const union__GFloatIEEE754 = extern union {
    v_float: gfloat,
    mpn: struct_unnamed_4,
};
pub const GFloatIEEE754 = union__GFloatIEEE754;
pub const struct__GTimeVal = extern struct {
    tv_sec: glong,
    tv_usec: glong,
};
pub const GTimeVal = struct__GTimeVal;
pub const grefcount = gint;
pub const gatomicrefcount = gint;
pub extern fn memcpy(__dest: ?*anyopaque, __src: ?*const anyopaque, __n: c_ulong) ?*anyopaque;
pub extern fn memmove(__dest: ?*anyopaque, __src: ?*const anyopaque, __n: c_ulong) ?*anyopaque;
pub extern fn memccpy(__dest: ?*anyopaque, __src: ?*const anyopaque, __c: c_int, __n: c_ulong) ?*anyopaque;
pub extern fn memset(__s: ?*anyopaque, __c: c_int, __n: c_ulong) ?*anyopaque;
pub extern fn memcmp(__s1: ?*const anyopaque, __s2: ?*const anyopaque, __n: c_ulong) c_int;
pub extern fn memchr(__s: ?*const anyopaque, __c: c_int, __n: c_ulong) ?*anyopaque;
pub extern fn strcpy(__dest: [*c]u8, __src: [*c]const u8) [*c]u8;
pub extern fn strncpy(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) [*c]u8;
pub extern fn strcat(__dest: [*c]u8, __src: [*c]const u8) [*c]u8;
pub extern fn strncat(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) [*c]u8;
pub extern fn strcmp(__s1: [*c]const u8, __s2: [*c]const u8) c_int;
pub extern fn strncmp(__s1: [*c]const u8, __s2: [*c]const u8, __n: c_ulong) c_int;
pub extern fn strcoll(__s1: [*c]const u8, __s2: [*c]const u8) c_int;
pub extern fn strxfrm(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) c_ulong;
pub extern fn strcoll_l(__s1: [*c]const u8, __s2: [*c]const u8, __l: locale_t) c_int;
pub extern fn strxfrm_l(__dest: [*c]u8, __src: [*c]const u8, __n: usize, __l: locale_t) usize;
pub extern fn strdup(__s: [*c]const u8) [*c]u8;
pub extern fn strndup(__string: [*c]const u8, __n: c_ulong) [*c]u8;
pub extern fn strchr(__s: [*c]const u8, __c: c_int) [*c]u8;
pub extern fn strrchr(__s: [*c]const u8, __c: c_int) [*c]u8;
pub extern fn strcspn(__s: [*c]const u8, __reject: [*c]const u8) c_ulong;
pub extern fn strspn(__s: [*c]const u8, __accept: [*c]const u8) c_ulong;
pub extern fn strpbrk(__s: [*c]const u8, __accept: [*c]const u8) [*c]u8;
pub extern fn strstr(__haystack: [*c]const u8, __needle: [*c]const u8) [*c]u8;
pub extern fn strtok(__s: [*c]u8, __delim: [*c]const u8) [*c]u8;
pub extern fn __strtok_r(noalias __s: [*c]u8, noalias __delim: [*c]const u8, noalias __save_ptr: [*c][*c]u8) [*c]u8;
pub extern fn strtok_r(noalias __s: [*c]u8, noalias __delim: [*c]const u8, noalias __save_ptr: [*c][*c]u8) [*c]u8;
pub extern fn strlen(__s: [*c]const u8) c_ulong;
pub extern fn strnlen(__string: [*c]const u8, __maxlen: usize) usize;
pub extern fn strerror(__errnum: c_int) [*c]u8;
pub extern fn strerror_r(__errnum: c_int, __buf: [*c]u8, __buflen: usize) c_int;
pub extern fn strerror_l(__errnum: c_int, __l: locale_t) [*c]u8;
pub extern fn bcmp(__s1: ?*const anyopaque, __s2: ?*const anyopaque, __n: c_ulong) c_int;
pub extern fn bcopy(__src: ?*const anyopaque, __dest: ?*anyopaque, __n: usize) void;
pub extern fn bzero(__s: ?*anyopaque, __n: c_ulong) void;
pub extern fn index(__s: [*c]const u8, __c: c_int) [*c]u8;
pub extern fn rindex(__s: [*c]const u8, __c: c_int) [*c]u8;
pub extern fn ffs(__i: c_int) c_int;
pub extern fn ffsl(__l: c_long) c_int;
pub extern fn ffsll(__ll: c_longlong) c_int;
pub extern fn strcasecmp(__s1: [*c]const u8, __s2: [*c]const u8) c_int;
pub extern fn strncasecmp(__s1: [*c]const u8, __s2: [*c]const u8, __n: c_ulong) c_int;
pub extern fn strcasecmp_l(__s1: [*c]const u8, __s2: [*c]const u8, __loc: locale_t) c_int;
pub extern fn strncasecmp_l(__s1: [*c]const u8, __s2: [*c]const u8, __n: usize, __loc: locale_t) c_int;
pub extern fn explicit_bzero(__s: ?*anyopaque, __n: usize) void;
pub extern fn strsep(noalias __stringp: [*c][*c]u8, noalias __delim: [*c]const u8) [*c]u8;
pub extern fn strsignal(__sig: c_int) [*c]u8;
pub extern fn __stpcpy(noalias __dest: [*c]u8, noalias __src: [*c]const u8) [*c]u8;
pub extern fn stpcpy(__dest: [*c]u8, __src: [*c]const u8) [*c]u8;
pub extern fn __stpncpy(noalias __dest: [*c]u8, noalias __src: [*c]const u8, __n: usize) [*c]u8;
pub extern fn stpncpy(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) [*c]u8;
pub const struct__GBytes = opaque {};
pub const GBytes = struct__GBytes;
pub const struct__GArray = extern struct {
    data: [*c]gchar,
    len: guint,
};
pub const GArray = struct__GArray;
pub const struct__GByteArray = extern struct {
    data: [*c]guint8,
    len: guint,
};
pub const GByteArray = struct__GByteArray;
pub const struct__GPtrArray = extern struct {
    pdata: [*c]gpointer,
    len: guint,
};
pub const GPtrArray = struct__GPtrArray;
pub extern fn g_array_new(zero_terminated: gboolean, clear_: gboolean, element_size: guint) [*c]GArray;
pub extern fn g_array_steal(array: [*c]GArray, len: [*c]gsize) gpointer;
pub extern fn g_array_sized_new(zero_terminated: gboolean, clear_: gboolean, element_size: guint, reserved_size: guint) [*c]GArray;
pub extern fn g_array_copy(array: [*c]GArray) [*c]GArray;
pub extern fn g_array_free(array: [*c]GArray, free_segment: gboolean) [*c]gchar;
pub extern fn g_array_ref(array: [*c]GArray) [*c]GArray;
pub extern fn g_array_unref(array: [*c]GArray) void;
pub extern fn g_array_get_element_size(array: [*c]GArray) guint;
pub extern fn g_array_append_vals(array: [*c]GArray, data: gconstpointer, len: guint) [*c]GArray;
pub extern fn g_array_prepend_vals(array: [*c]GArray, data: gconstpointer, len: guint) [*c]GArray;
pub extern fn g_array_insert_vals(array: [*c]GArray, index_: guint, data: gconstpointer, len: guint) [*c]GArray;
pub extern fn g_array_set_size(array: [*c]GArray, length: guint) [*c]GArray;
pub extern fn g_array_remove_index(array: [*c]GArray, index_: guint) [*c]GArray;
pub extern fn g_array_remove_index_fast(array: [*c]GArray, index_: guint) [*c]GArray;
pub extern fn g_array_remove_range(array: [*c]GArray, index_: guint, length: guint) [*c]GArray;
pub extern fn g_array_sort(array: [*c]GArray, compare_func: GCompareFunc) void;
pub extern fn g_array_sort_with_data(array: [*c]GArray, compare_func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_array_binary_search(array: [*c]GArray, target: gconstpointer, compare_func: GCompareFunc, out_match_index: [*c]guint) gboolean;
pub extern fn g_array_set_clear_func(array: [*c]GArray, clear_func: GDestroyNotify) void;
pub extern fn g_ptr_array_new() [*c]GPtrArray;
pub extern fn g_ptr_array_new_with_free_func(element_free_func: GDestroyNotify) [*c]GPtrArray;
pub extern fn g_ptr_array_steal(array: [*c]GPtrArray, len: [*c]gsize) [*c]gpointer;
pub extern fn g_ptr_array_copy(array: [*c]GPtrArray, func: GCopyFunc, user_data: gpointer) [*c]GPtrArray;
pub extern fn g_ptr_array_sized_new(reserved_size: guint) [*c]GPtrArray;
pub extern fn g_ptr_array_new_full(reserved_size: guint, element_free_func: GDestroyNotify) [*c]GPtrArray;
pub extern fn g_ptr_array_free(array: [*c]GPtrArray, free_seg: gboolean) [*c]gpointer;
pub extern fn g_ptr_array_ref(array: [*c]GPtrArray) [*c]GPtrArray;
pub extern fn g_ptr_array_unref(array: [*c]GPtrArray) void;
pub extern fn g_ptr_array_set_free_func(array: [*c]GPtrArray, element_free_func: GDestroyNotify) void;
pub extern fn g_ptr_array_set_size(array: [*c]GPtrArray, length: gint) void;
pub extern fn g_ptr_array_remove_index(array: [*c]GPtrArray, index_: guint) gpointer;
pub extern fn g_ptr_array_remove_index_fast(array: [*c]GPtrArray, index_: guint) gpointer;
pub extern fn g_ptr_array_steal_index(array: [*c]GPtrArray, index_: guint) gpointer;
pub extern fn g_ptr_array_steal_index_fast(array: [*c]GPtrArray, index_: guint) gpointer;
pub extern fn g_ptr_array_remove(array: [*c]GPtrArray, data: gpointer) gboolean;
pub extern fn g_ptr_array_remove_fast(array: [*c]GPtrArray, data: gpointer) gboolean;
pub extern fn g_ptr_array_remove_range(array: [*c]GPtrArray, index_: guint, length: guint) [*c]GPtrArray;
pub extern fn g_ptr_array_add(array: [*c]GPtrArray, data: gpointer) void;
pub extern fn g_ptr_array_extend(array_to_extend: [*c]GPtrArray, array: [*c]GPtrArray, func: GCopyFunc, user_data: gpointer) void;
pub extern fn g_ptr_array_extend_and_steal(array_to_extend: [*c]GPtrArray, array: [*c]GPtrArray) void;
pub extern fn g_ptr_array_insert(array: [*c]GPtrArray, index_: gint, data: gpointer) void;
pub extern fn g_ptr_array_sort(array: [*c]GPtrArray, compare_func: GCompareFunc) void;
pub extern fn g_ptr_array_sort_with_data(array: [*c]GPtrArray, compare_func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_ptr_array_foreach(array: [*c]GPtrArray, func: GFunc, user_data: gpointer) void;
pub extern fn g_ptr_array_find(haystack: [*c]GPtrArray, needle: gconstpointer, index_: [*c]guint) gboolean;
pub extern fn g_ptr_array_find_with_equal_func(haystack: [*c]GPtrArray, needle: gconstpointer, equal_func: GEqualFunc, index_: [*c]guint) gboolean;
pub extern fn g_byte_array_new() [*c]GByteArray;
pub extern fn g_byte_array_new_take(data: [*c]guint8, len: gsize) [*c]GByteArray;
pub extern fn g_byte_array_steal(array: [*c]GByteArray, len: [*c]gsize) [*c]guint8;
pub extern fn g_byte_array_sized_new(reserved_size: guint) [*c]GByteArray;
pub extern fn g_byte_array_free(array: [*c]GByteArray, free_segment: gboolean) [*c]guint8;
pub extern fn g_byte_array_free_to_bytes(array: [*c]GByteArray) ?*GBytes;
pub extern fn g_byte_array_ref(array: [*c]GByteArray) [*c]GByteArray;
pub extern fn g_byte_array_unref(array: [*c]GByteArray) void;
pub extern fn g_byte_array_append(array: [*c]GByteArray, data: [*c]const guint8, len: guint) [*c]GByteArray;
pub extern fn g_byte_array_prepend(array: [*c]GByteArray, data: [*c]const guint8, len: guint) [*c]GByteArray;
pub extern fn g_byte_array_set_size(array: [*c]GByteArray, length: guint) [*c]GByteArray;
pub extern fn g_byte_array_remove_index(array: [*c]GByteArray, index_: guint) [*c]GByteArray;
pub extern fn g_byte_array_remove_index_fast(array: [*c]GByteArray, index_: guint) [*c]GByteArray;
pub extern fn g_byte_array_remove_range(array: [*c]GByteArray, index_: guint, length: guint) [*c]GByteArray;
pub extern fn g_byte_array_sort(array: [*c]GByteArray, compare_func: GCompareFunc) void;
pub extern fn g_byte_array_sort_with_data(array: [*c]GByteArray, compare_func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_atomic_int_get(atomic: [*c]const volatile gint) gint;
pub extern fn g_atomic_int_set(atomic: [*c]volatile gint, newval: gint) void;
pub extern fn g_atomic_int_inc(atomic: [*c]volatile gint) void;
pub extern fn g_atomic_int_dec_and_test(atomic: [*c]volatile gint) gboolean;
pub extern fn g_atomic_int_compare_and_exchange(atomic: [*c]volatile gint, oldval: gint, newval: gint) gboolean;
pub extern fn g_atomic_int_add(atomic: [*c]volatile gint, val: gint) gint;
pub extern fn g_atomic_int_and(atomic: [*c]volatile guint, val: guint) guint;
pub extern fn g_atomic_int_or(atomic: [*c]volatile guint, val: guint) guint;
pub extern fn g_atomic_int_xor(atomic: [*c]volatile guint, val: guint) guint;
pub extern fn g_atomic_pointer_get(atomic: ?*const volatile anyopaque) gpointer;
pub extern fn g_atomic_pointer_set(atomic: ?*volatile anyopaque, newval: gpointer) void;
pub extern fn g_atomic_pointer_compare_and_exchange(atomic: ?*volatile anyopaque, oldval: gpointer, newval: gpointer) gboolean;
pub extern fn g_atomic_pointer_add(atomic: ?*volatile anyopaque, val: gssize) gssize;
pub extern fn g_atomic_pointer_and(atomic: ?*volatile anyopaque, val: gsize) gsize;
pub extern fn g_atomic_pointer_or(atomic: ?*volatile anyopaque, val: gsize) gsize;
pub extern fn g_atomic_pointer_xor(atomic: ?*volatile anyopaque, val: gsize) gsize;
pub extern fn g_atomic_int_exchange_and_add(atomic: [*c]volatile gint, val: gint) gint;
pub const struct___va_list = extern struct {
    __stack: ?*anyopaque,
    __gr_top: ?*anyopaque,
    __vr_top: ?*anyopaque,
    __gr_offs: c_int,
    __vr_offs: c_int,
};
pub const __builtin_va_list = struct___va_list;
pub const va_list = __builtin_va_list;
pub const __gnuc_va_list = __builtin_va_list;
pub const GQuark = guint32;
pub extern fn g_quark_try_string(string: [*c]const gchar) GQuark;
pub extern fn g_quark_from_static_string(string: [*c]const gchar) GQuark;
pub extern fn g_quark_from_string(string: [*c]const gchar) GQuark;
pub extern fn g_quark_to_string(quark: GQuark) [*c]const gchar;
pub extern fn g_intern_string(string: [*c]const gchar) [*c]const gchar;
pub extern fn g_intern_static_string(string: [*c]const gchar) [*c]const gchar;
pub const struct__GError = extern struct {
    domain: GQuark,
    code: gint,
    message: [*c]gchar,
};
pub const GError = struct__GError;
pub const GErrorInitFunc = ?fn ([*c]GError) callconv(.C) void;
pub const GErrorCopyFunc = ?fn ([*c]const GError, [*c]GError) callconv(.C) void;
pub const GErrorClearFunc = ?fn ([*c]GError) callconv(.C) void;
pub extern fn g_error_domain_register_static(error_type_name: [*c]const u8, error_type_private_size: gsize, error_type_init: GErrorInitFunc, error_type_copy: GErrorCopyFunc, error_type_clear: GErrorClearFunc) GQuark;
pub extern fn g_error_domain_register(error_type_name: [*c]const u8, error_type_private_size: gsize, error_type_init: GErrorInitFunc, error_type_copy: GErrorCopyFunc, error_type_clear: GErrorClearFunc) GQuark;
pub extern fn g_error_new(domain: GQuark, code: gint, format: [*c]const gchar, ...) [*c]GError;
pub extern fn g_error_new_literal(domain: GQuark, code: gint, message: [*c]const gchar) [*c]GError;
pub extern fn g_error_new_valist(domain: GQuark, code: gint, format: [*c]const gchar, args: va_list) [*c]GError;
pub extern fn g_error_free(@"error": [*c]GError) void;
pub extern fn g_error_copy(@"error": [*c]const GError) [*c]GError;
pub extern fn g_error_matches(@"error": [*c]const GError, domain: GQuark, code: gint) gboolean;
pub extern fn g_set_error(err: [*c][*c]GError, domain: GQuark, code: gint, format: [*c]const gchar, ...) void;
pub extern fn g_set_error_literal(err: [*c][*c]GError, domain: GQuark, code: gint, message: [*c]const gchar) void;
pub extern fn g_propagate_error(dest: [*c][*c]GError, src: [*c]GError) void;
pub extern fn g_clear_error(err: [*c][*c]GError) void;
pub extern fn g_prefix_error(err: [*c][*c]GError, format: [*c]const gchar, ...) void;
pub extern fn g_prefix_error_literal(err: [*c][*c]GError, prefix: [*c]const gchar) void;
pub extern fn g_propagate_prefixed_error(dest: [*c][*c]GError, src: [*c]GError, format: [*c]const gchar, ...) void;
pub extern fn g_get_user_name() [*c]const gchar;
pub extern fn g_get_real_name() [*c]const gchar;
pub extern fn g_get_home_dir() [*c]const gchar;
pub extern fn g_get_tmp_dir() [*c]const gchar;
pub extern fn g_get_host_name() [*c]const gchar;
pub extern fn g_get_prgname() [*c]const gchar;
pub extern fn g_set_prgname(prgname: [*c]const gchar) void;
pub extern fn g_get_application_name() [*c]const gchar;
pub extern fn g_set_application_name(application_name: [*c]const gchar) void;
pub extern fn g_get_os_info(key_name: [*c]const gchar) [*c]gchar;
pub extern fn g_reload_user_special_dirs_cache() void;
pub extern fn g_get_user_data_dir() [*c]const gchar;
pub extern fn g_get_user_config_dir() [*c]const gchar;
pub extern fn g_get_user_cache_dir() [*c]const gchar;
pub extern fn g_get_user_state_dir() [*c]const gchar;
pub extern fn g_get_system_data_dirs() [*c]const [*c]const gchar;
pub extern fn g_get_system_config_dirs() [*c]const [*c]const gchar;
pub extern fn g_get_user_runtime_dir() [*c]const gchar;
pub const G_USER_DIRECTORY_DESKTOP: c_int = 0;
pub const G_USER_DIRECTORY_DOCUMENTS: c_int = 1;
pub const G_USER_DIRECTORY_DOWNLOAD: c_int = 2;
pub const G_USER_DIRECTORY_MUSIC: c_int = 3;
pub const G_USER_DIRECTORY_PICTURES: c_int = 4;
pub const G_USER_DIRECTORY_PUBLIC_SHARE: c_int = 5;
pub const G_USER_DIRECTORY_TEMPLATES: c_int = 6;
pub const G_USER_DIRECTORY_VIDEOS: c_int = 7;
pub const G_USER_N_DIRECTORIES: c_int = 8;
pub const GUserDirectory = c_uint;
pub extern fn g_get_user_special_dir(directory: GUserDirectory) [*c]const gchar;
pub const struct__GDebugKey = extern struct {
    key: [*c]const gchar,
    value: guint,
};
pub const GDebugKey = struct__GDebugKey;
pub extern fn g_parse_debug_string(string: [*c]const gchar, keys: [*c]const GDebugKey, nkeys: guint) guint;
pub extern fn g_snprintf(string: [*c]gchar, n: gulong, format: [*c]const gchar, ...) gint;
pub extern fn g_vsnprintf(string: [*c]gchar, n: gulong, format: [*c]const gchar, args: va_list) gint;
pub extern fn g_nullify_pointer(nullify_location: [*c]gpointer) void;
pub const G_FORMAT_SIZE_DEFAULT: c_int = 0;
pub const G_FORMAT_SIZE_LONG_FORMAT: c_int = 1;
pub const G_FORMAT_SIZE_IEC_UNITS: c_int = 2;
pub const G_FORMAT_SIZE_BITS: c_int = 4;
pub const GFormatSizeFlags = c_uint;
pub extern fn g_format_size_full(size: guint64, flags: GFormatSizeFlags) [*c]gchar;
pub extern fn g_format_size(size: guint64) [*c]gchar;
pub extern fn g_format_size_for_display(size: goffset) [*c]gchar;
pub const GVoidFunc = ?fn () callconv(.C) void;
pub extern fn g_atexit(func: GVoidFunc) void;
pub extern fn g_find_program_in_path(program: [*c]const gchar) [*c]gchar;
pub extern fn g_bit_nth_lsf(mask: gulong, nth_bit: gint) gint;
pub extern fn g_bit_nth_msf(mask: gulong, nth_bit: gint) gint;
pub extern fn g_bit_storage(number: gulong) guint;
pub fn g_bit_nth_lsf_impl(arg_mask: gulong, arg_nth_bit: gint) callconv(.C) gint {
    var mask = arg_mask;
    var nth_bit = arg_nth_bit;
    if (nth_bit < -@as(c_int, 1)) {
        nth_bit = -@as(c_int, 1);
    }
    while (nth_bit < ((@as(c_int, 8) * @as(c_int, 8)) - @as(c_int, 1))) {
        nth_bit += 1;
        if ((mask & (@as(c_ulong, 1) << @intCast(@import("std").math.Log2Int(c_ulong), nth_bit))) != 0) return nth_bit;
    }
    return -@as(c_int, 1);
}
pub fn g_bit_nth_msf_impl(arg_mask: gulong, arg_nth_bit: gint) callconv(.C) gint {
    var mask = arg_mask;
    var nth_bit = arg_nth_bit;
    if ((nth_bit < @as(c_int, 0)) or (nth_bit > (@as(c_int, 8) * @as(c_int, 8)))) {
        nth_bit = @as(c_int, 8) * @as(c_int, 8);
    }
    while (nth_bit > @as(c_int, 0)) {
        nth_bit -= 1;
        if ((mask & (@as(c_ulong, 1) << @intCast(@import("std").math.Log2Int(c_ulong), nth_bit))) != 0) return nth_bit;
    }
    return -@as(c_int, 1);
}
pub fn g_bit_storage_impl(arg_number: gulong) callconv(.C) guint {
    var number = arg_number;
    var n_bits: guint = 0;
    while (true) {
        n_bits +%= 1;
        number >>= @intCast(@import("std").math.Log2Int(c_int), @as(c_int, 1));
        if (!(number != 0)) break;
    }
    return n_bits;
}
pub const P_ALL: c_int = 0;
pub const P_PID: c_int = 1;
pub const P_PGID: c_int = 2;
pub const idtype_t = c_uint;
pub const _Float128 = c_longdouble;
pub const _Float32 = f32;
pub const _Float64 = f64;
pub const _Float32x = f64;
pub const _Float64x = c_longdouble;
pub const div_t = extern struct {
    quot: c_int,
    rem: c_int,
};
pub const ldiv_t = extern struct {
    quot: c_long,
    rem: c_long,
};
pub const lldiv_t = extern struct {
    quot: c_longlong,
    rem: c_longlong,
};
pub extern fn __ctype_get_mb_cur_max() usize;
pub extern fn atof(__nptr: [*c]const u8) f64;
pub extern fn atoi(__nptr: [*c]const u8) c_int;
pub extern fn atol(__nptr: [*c]const u8) c_long;
pub extern fn atoll(__nptr: [*c]const u8) c_longlong;
pub extern fn strtod(__nptr: [*c]const u8, __endptr: [*c][*c]u8) f64;
pub extern fn strtof(__nptr: [*c]const u8, __endptr: [*c][*c]u8) f32;
pub extern fn strtold(__nptr: [*c]const u8, __endptr: [*c][*c]u8) c_longdouble;
pub extern fn strtol(__nptr: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_long;
pub extern fn strtoul(__nptr: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_ulong;
pub extern fn strtoq(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __base: c_int) c_longlong;
pub extern fn strtouq(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __base: c_int) c_ulonglong;
pub extern fn strtoll(__nptr: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_longlong;
pub extern fn strtoull(__nptr: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_ulonglong;
pub extern fn l64a(__n: c_long) [*c]u8;
pub extern fn a64l(__s: [*c]const u8) c_long;
pub const u_char = __u_char;
pub const u_short = __u_short;
pub const u_int = __u_int;
pub const u_long = __u_long;
pub const quad_t = __quad_t;
pub const u_quad_t = __u_quad_t;
pub const fsid_t = __fsid_t;
pub const loff_t = __loff_t;
pub const ino_t = __ino_t;
pub const dev_t = __dev_t;
pub const gid_t = __gid_t;
pub const mode_t = __mode_t;
pub const nlink_t = __nlink_t;
pub const uid_t = __uid_t;
pub const off_t = __off_t;
pub const id_t = __id_t;
pub const daddr_t = __daddr_t;
pub const caddr_t = __caddr_t;
pub const key_t = __key_t;
pub const ulong = c_ulong;
pub const ushort = c_ushort;
pub const uint = c_uint;
pub const u_int8_t = __uint8_t;
pub const u_int16_t = __uint16_t;
pub const u_int32_t = __uint32_t;
pub const u_int64_t = __uint64_t;
pub const register_t = c_long;
pub fn __bswap_16(arg___bsx: __uint16_t) callconv(.C) __uint16_t {
    var __bsx = arg___bsx;
    return @bitCast(__uint16_t, @truncate(c_short, ((@bitCast(c_int, @as(c_uint, __bsx)) >> @intCast(@import("std").math.Log2Int(c_int), 8)) & @as(c_int, 255)) | ((@bitCast(c_int, @as(c_uint, __bsx)) & @as(c_int, 255)) << @intCast(@import("std").math.Log2Int(c_int), 8))));
}
pub fn __bswap_32(arg___bsx: __uint32_t) callconv(.C) __uint32_t {
    var __bsx = arg___bsx;
    return ((((__bsx & @as(c_uint, 4278190080)) >> @intCast(@import("std").math.Log2Int(c_uint), 24)) | ((__bsx & @as(c_uint, 16711680)) >> @intCast(@import("std").math.Log2Int(c_uint), 8))) | ((__bsx & @as(c_uint, 65280)) << @intCast(@import("std").math.Log2Int(c_uint), 8))) | ((__bsx & @as(c_uint, 255)) << @intCast(@import("std").math.Log2Int(c_uint), 24));
}
pub fn __bswap_64(arg___bsx: __uint64_t) callconv(.C) __uint64_t {
    var __bsx = arg___bsx;
    return @bitCast(__uint64_t, @truncate(c_ulong, ((((((((@bitCast(c_ulonglong, @as(c_ulonglong, __bsx)) & @as(c_ulonglong, 18374686479671623680)) >> @intCast(@import("std").math.Log2Int(c_ulonglong), 56)) | ((@bitCast(c_ulonglong, @as(c_ulonglong, __bsx)) & @as(c_ulonglong, 71776119061217280)) >> @intCast(@import("std").math.Log2Int(c_ulonglong), 40))) | ((@bitCast(c_ulonglong, @as(c_ulonglong, __bsx)) & @as(c_ulonglong, 280375465082880)) >> @intCast(@import("std").math.Log2Int(c_ulonglong), 24))) | ((@bitCast(c_ulonglong, @as(c_ulonglong, __bsx)) & @as(c_ulonglong, 1095216660480)) >> @intCast(@import("std").math.Log2Int(c_ulonglong), 8))) | ((@bitCast(c_ulonglong, @as(c_ulonglong, __bsx)) & @as(c_ulonglong, 4278190080)) << @intCast(@import("std").math.Log2Int(c_ulonglong), 8))) | ((@bitCast(c_ulonglong, @as(c_ulonglong, __bsx)) & @as(c_ulonglong, 16711680)) << @intCast(@import("std").math.Log2Int(c_ulonglong), 24))) | ((@bitCast(c_ulonglong, @as(c_ulonglong, __bsx)) & @as(c_ulonglong, 65280)) << @intCast(@import("std").math.Log2Int(c_ulonglong), 40))) | ((@bitCast(c_ulonglong, @as(c_ulonglong, __bsx)) & @as(c_ulonglong, 255)) << @intCast(@import("std").math.Log2Int(c_ulonglong), 56))));
}
pub fn __uint16_identity(arg___x: __uint16_t) callconv(.C) __uint16_t {
    var __x = arg___x;
    return __x;
}
pub fn __uint32_identity(arg___x: __uint32_t) callconv(.C) __uint32_t {
    var __x = arg___x;
    return __x;
}
pub fn __uint64_identity(arg___x: __uint64_t) callconv(.C) __uint64_t {
    var __x = arg___x;
    return __x;
}
pub const __sigset_t = extern struct {
    __val: [16]c_ulong,
};
pub const sigset_t = __sigset_t;
pub const struct_timeval = extern struct {
    tv_sec: __time_t,
    tv_usec: __suseconds_t,
};
pub const suseconds_t = __suseconds_t;
pub const __fd_mask = c_long;
pub const fd_set = extern struct {
    __fds_bits: [16]__fd_mask,
};
pub const fd_mask = __fd_mask;
pub extern fn select(__nfds: c_int, noalias __readfds: [*c]fd_set, noalias __writefds: [*c]fd_set, noalias __exceptfds: [*c]fd_set, noalias __timeout: [*c]struct_timeval) c_int;
pub extern fn pselect(__nfds: c_int, noalias __readfds: [*c]fd_set, noalias __writefds: [*c]fd_set, noalias __exceptfds: [*c]fd_set, noalias __timeout: [*c]const struct_timespec, noalias __sigmask: [*c]const __sigset_t) c_int;
pub const blksize_t = __blksize_t;
pub const blkcnt_t = __blkcnt_t;
pub const fsblkcnt_t = __fsblkcnt_t;
pub const fsfilcnt_t = __fsfilcnt_t;
pub const struct___pthread_internal_list = extern struct {
    __prev: [*c]struct___pthread_internal_list,
    __next: [*c]struct___pthread_internal_list,
};
pub const __pthread_list_t = struct___pthread_internal_list;
pub const struct___pthread_internal_slist = extern struct {
    __next: [*c]struct___pthread_internal_slist,
};
pub const __pthread_slist_t = struct___pthread_internal_slist;
pub const struct___pthread_mutex_s = extern struct {
    __lock: c_int,
    __count: c_uint,
    __owner: c_int,
    __nusers: c_uint,
    __kind: c_int,
    __spins: c_int,
    __list: __pthread_list_t,
};
pub const struct___pthread_rwlock_arch_t = extern struct {
    __readers: c_uint,
    __writers: c_uint,
    __wrphase_futex: c_uint,
    __writers_futex: c_uint,
    __pad3: c_uint,
    __pad4: c_uint,
    __cur_writer: c_int,
    __shared: c_int,
    __pad1: c_ulong,
    __pad2: c_ulong,
    __flags: c_uint,
};
const struct_unnamed_6 = extern struct {
    __low: c_uint,
    __high: c_uint,
};
const union_unnamed_5 = extern union {
    __wseq: c_ulonglong,
    __wseq32: struct_unnamed_6,
};
const struct_unnamed_8 = extern struct {
    __low: c_uint,
    __high: c_uint,
};
const union_unnamed_7 = extern union {
    __g1_start: c_ulonglong,
    __g1_start32: struct_unnamed_8,
};
pub const struct___pthread_cond_s = extern struct {
    unnamed_0: union_unnamed_5,
    unnamed_1: union_unnamed_7,
    __g_refs: [2]c_uint,
    __g_size: [2]c_uint,
    __g1_orig_size: c_uint,
    __wrefs: c_uint,
    __g_signals: [2]c_uint,
};
pub const __tss_t = c_uint;
pub const __thrd_t = c_ulong;
pub const __once_flag = extern struct {
    __data: c_int,
};
pub const pthread_t = c_ulong;
pub const pthread_mutexattr_t = extern union {
    __size: [8]u8,
    __align: c_int,
};
pub const pthread_condattr_t = extern union {
    __size: [8]u8,
    __align: c_int,
};
pub const pthread_key_t = c_uint;
pub const pthread_once_t = c_int;
pub const pthread_mutex_t = extern union {
    __data: struct___pthread_mutex_s,
    __size: [48]u8,
    __align: c_long,
};
pub const pthread_cond_t = extern union {
    __data: struct___pthread_cond_s,
    __size: [48]u8,
    __align: c_longlong,
};
pub const pthread_rwlock_t = extern union {
    __data: struct___pthread_rwlock_arch_t,
    __size: [56]u8,
    __align: c_long,
};
pub const pthread_rwlockattr_t = extern union {
    __size: [8]u8,
    __align: c_long,
};
pub const pthread_spinlock_t = c_int;
pub const pthread_barrier_t = extern union {
    __size: [32]u8,
    __align: c_long,
};
pub const pthread_barrierattr_t = extern union {
    __size: [8]u8,
    __align: c_int,
};
pub extern fn random() c_long;
pub extern fn srandom(__seed: c_uint) void;
pub extern fn initstate(__seed: c_uint, __statebuf: [*c]u8, __statelen: usize) [*c]u8;
pub extern fn setstate(__statebuf: [*c]u8) [*c]u8;
pub const struct_random_data = extern struct {
    fptr: [*c]i32,
    rptr: [*c]i32,
    state: [*c]i32,
    rand_type: c_int,
    rand_deg: c_int,
    rand_sep: c_int,
    end_ptr: [*c]i32,
};
pub extern fn random_r(noalias __buf: [*c]struct_random_data, noalias __result: [*c]i32) c_int;
pub extern fn srandom_r(__seed: c_uint, __buf: [*c]struct_random_data) c_int;
pub extern fn initstate_r(__seed: c_uint, noalias __statebuf: [*c]u8, __statelen: usize, noalias __buf: [*c]struct_random_data) c_int;
pub extern fn setstate_r(noalias __statebuf: [*c]u8, noalias __buf: [*c]struct_random_data) c_int;
pub extern fn rand() c_int;
pub extern fn srand(__seed: c_uint) void;
pub extern fn rand_r(__seed: [*c]c_uint) c_int;
pub extern fn drand48() f64;
pub extern fn erand48(__xsubi: [*c]c_ushort) f64;
pub extern fn lrand48() c_long;
pub extern fn nrand48(__xsubi: [*c]c_ushort) c_long;
pub extern fn mrand48() c_long;
pub extern fn jrand48(__xsubi: [*c]c_ushort) c_long;
pub extern fn srand48(__seedval: c_long) void;
pub extern fn seed48(__seed16v: [*c]c_ushort) [*c]c_ushort;
pub extern fn lcong48(__param: [*c]c_ushort) void;
pub const struct_drand48_data = extern struct {
    __x: [3]c_ushort,
    __old_x: [3]c_ushort,
    __c: c_ushort,
    __init: c_ushort,
    __a: c_ulonglong,
};
pub extern fn drand48_r(noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]f64) c_int;
pub extern fn erand48_r(__xsubi: [*c]c_ushort, noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]f64) c_int;
pub extern fn lrand48_r(noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]c_long) c_int;
pub extern fn nrand48_r(__xsubi: [*c]c_ushort, noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]c_long) c_int;
pub extern fn mrand48_r(noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]c_long) c_int;
pub extern fn jrand48_r(__xsubi: [*c]c_ushort, noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]c_long) c_int;
pub extern fn srand48_r(__seedval: c_long, __buffer: [*c]struct_drand48_data) c_int;
pub extern fn seed48_r(__seed16v: [*c]c_ushort, __buffer: [*c]struct_drand48_data) c_int;
pub extern fn lcong48_r(__param: [*c]c_ushort, __buffer: [*c]struct_drand48_data) c_int;
pub extern fn malloc(__size: c_ulong) ?*anyopaque;
pub extern fn calloc(__nmemb: c_ulong, __size: c_ulong) ?*anyopaque;
pub extern fn realloc(__ptr: ?*anyopaque, __size: c_ulong) ?*anyopaque;
pub extern fn free(__ptr: ?*anyopaque) void;
pub extern fn reallocarray(__ptr: ?*anyopaque, __nmemb: usize, __size: usize) ?*anyopaque;
pub extern fn alloca(__size: c_ulong) ?*anyopaque;
pub extern fn valloc(__size: usize) ?*anyopaque;
pub extern fn posix_memalign(__memptr: [*c]?*anyopaque, __alignment: usize, __size: usize) c_int;
pub extern fn aligned_alloc(__alignment: c_ulong, __size: c_ulong) ?*anyopaque;
pub extern fn abort() noreturn;
pub extern fn atexit(__func: ?fn () callconv(.C) void) c_int;
pub extern fn at_quick_exit(__func: ?fn () callconv(.C) void) c_int;
pub extern fn on_exit(__func: ?fn (c_int, ?*anyopaque) callconv(.C) void, __arg: ?*anyopaque) c_int;
pub extern fn exit(__status: c_int) noreturn;
pub extern fn quick_exit(__status: c_int) noreturn;
pub extern fn _Exit(__status: c_int) noreturn;
pub extern fn getenv(__name: [*c]const u8) [*c]u8;
pub extern fn putenv(__string: [*c]u8) c_int;
pub extern fn setenv(__name: [*c]const u8, __value: [*c]const u8, __replace: c_int) c_int;
pub extern fn unsetenv(__name: [*c]const u8) c_int;
pub extern fn clearenv() c_int;
pub extern fn mktemp(__template: [*c]u8) [*c]u8;
pub extern fn mkstemp(__template: [*c]u8) c_int;
pub extern fn mkstemps(__template: [*c]u8, __suffixlen: c_int) c_int;
pub extern fn mkdtemp(__template: [*c]u8) [*c]u8;
pub extern fn system(__command: [*c]const u8) c_int;
pub extern fn realpath(noalias __name: [*c]const u8, noalias __resolved: [*c]u8) [*c]u8;
pub const __compar_fn_t = ?fn (?*const anyopaque, ?*const anyopaque) callconv(.C) c_int;
pub extern fn bsearch(__key: ?*const anyopaque, __base: ?*const anyopaque, __nmemb: usize, __size: usize, __compar: __compar_fn_t) ?*anyopaque;
pub extern fn qsort(__base: ?*anyopaque, __nmemb: usize, __size: usize, __compar: __compar_fn_t) void;
pub extern fn abs(__x: c_int) c_int;
pub extern fn labs(__x: c_long) c_long;
pub extern fn llabs(__x: c_longlong) c_longlong;
pub extern fn div(__numer: c_int, __denom: c_int) div_t;
pub extern fn ldiv(__numer: c_long, __denom: c_long) ldiv_t;
pub extern fn lldiv(__numer: c_longlong, __denom: c_longlong) lldiv_t;
pub extern fn ecvt(__value: f64, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int) [*c]u8;
pub extern fn fcvt(__value: f64, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int) [*c]u8;
pub extern fn gcvt(__value: f64, __ndigit: c_int, __buf: [*c]u8) [*c]u8;
pub extern fn qecvt(__value: c_longdouble, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int) [*c]u8;
pub extern fn qfcvt(__value: c_longdouble, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int) [*c]u8;
pub extern fn qgcvt(__value: c_longdouble, __ndigit: c_int, __buf: [*c]u8) [*c]u8;
pub extern fn ecvt_r(__value: f64, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int, noalias __buf: [*c]u8, __len: usize) c_int;
pub extern fn fcvt_r(__value: f64, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int, noalias __buf: [*c]u8, __len: usize) c_int;
pub extern fn qecvt_r(__value: c_longdouble, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int, noalias __buf: [*c]u8, __len: usize) c_int;
pub extern fn qfcvt_r(__value: c_longdouble, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int, noalias __buf: [*c]u8, __len: usize) c_int;
pub extern fn mblen(__s: [*c]const u8, __n: usize) c_int;
pub extern fn mbtowc(noalias __pwc: [*c]wchar_t, noalias __s: [*c]const u8, __n: usize) c_int;
pub extern fn wctomb(__s: [*c]u8, __wchar: wchar_t) c_int;
pub extern fn mbstowcs(noalias __pwcs: [*c]wchar_t, noalias __s: [*c]const u8, __n: usize) usize;
pub extern fn wcstombs(noalias __s: [*c]u8, noalias __pwcs: [*c]const wchar_t, __n: usize) usize;
pub extern fn rpmatch(__response: [*c]const u8) c_int;
pub extern fn getsubopt(noalias __optionp: [*c][*c]u8, noalias __tokens: [*c]const [*c]u8, noalias __valuep: [*c][*c]u8) c_int;
pub extern fn getloadavg(__loadavg: [*c]f64, __nelem: c_int) c_int;
pub extern fn g_thread_error_quark() GQuark;
pub const G_THREAD_ERROR_AGAIN: c_int = 0;
pub const GThreadError = c_uint;
pub const GThreadFunc = ?fn (gpointer) callconv(.C) gpointer;
pub const struct__GThread = extern struct {
    func: GThreadFunc,
    data: gpointer,
    joinable: gboolean,
    priority: GThreadPriority,
};
pub const GThread = struct__GThread;
pub const union__GMutex = extern union {
    p: gpointer,
    i: [2]guint,
};
pub const GMutex = union__GMutex;
pub const struct__GRecMutex = extern struct {
    p: gpointer,
    i: [2]guint,
};
pub const GRecMutex = struct__GRecMutex;
pub const struct__GRWLock = extern struct {
    p: gpointer,
    i: [2]guint,
};
pub const GRWLock = struct__GRWLock;
pub const struct__GCond = extern struct {
    p: gpointer,
    i: [2]guint,
};
pub const GCond = struct__GCond;
pub const struct__GPrivate = extern struct {
    p: gpointer,
    notify: GDestroyNotify,
    future: [2]gpointer,
};
pub const GPrivate = struct__GPrivate;
pub const struct__GOnce = extern struct {
    status: GOnceStatus,
    retval: gpointer,
};
pub const GOnce = struct__GOnce;
pub const G_ONCE_STATUS_NOTCALLED: c_int = 0;
pub const G_ONCE_STATUS_PROGRESS: c_int = 1;
pub const G_ONCE_STATUS_READY: c_int = 2;
pub const GOnceStatus = c_uint;
pub extern fn g_thread_ref(thread: [*c]GThread) [*c]GThread;
pub extern fn g_thread_unref(thread: [*c]GThread) void;
pub extern fn g_thread_new(name: [*c]const gchar, func: GThreadFunc, data: gpointer) [*c]GThread;
pub extern fn g_thread_try_new(name: [*c]const gchar, func: GThreadFunc, data: gpointer, @"error": [*c][*c]GError) [*c]GThread;
pub extern fn g_thread_self() [*c]GThread;
pub extern fn g_thread_exit(retval: gpointer) void;
pub extern fn g_thread_join(thread: [*c]GThread) gpointer;
pub extern fn g_thread_yield() void;
pub extern fn g_mutex_init(mutex: [*c]GMutex) void;
pub extern fn g_mutex_clear(mutex: [*c]GMutex) void;
pub extern fn g_mutex_lock(mutex: [*c]GMutex) void;
pub extern fn g_mutex_trylock(mutex: [*c]GMutex) gboolean;
pub extern fn g_mutex_unlock(mutex: [*c]GMutex) void;
pub extern fn g_rw_lock_init(rw_lock: [*c]GRWLock) void;
pub extern fn g_rw_lock_clear(rw_lock: [*c]GRWLock) void;
pub extern fn g_rw_lock_writer_lock(rw_lock: [*c]GRWLock) void;
pub extern fn g_rw_lock_writer_trylock(rw_lock: [*c]GRWLock) gboolean;
pub extern fn g_rw_lock_writer_unlock(rw_lock: [*c]GRWLock) void;
pub extern fn g_rw_lock_reader_lock(rw_lock: [*c]GRWLock) void;
pub extern fn g_rw_lock_reader_trylock(rw_lock: [*c]GRWLock) gboolean;
pub extern fn g_rw_lock_reader_unlock(rw_lock: [*c]GRWLock) void;
pub extern fn g_rec_mutex_init(rec_mutex: [*c]GRecMutex) void;
pub extern fn g_rec_mutex_clear(rec_mutex: [*c]GRecMutex) void;
pub extern fn g_rec_mutex_lock(rec_mutex: [*c]GRecMutex) void;
pub extern fn g_rec_mutex_trylock(rec_mutex: [*c]GRecMutex) gboolean;
pub extern fn g_rec_mutex_unlock(rec_mutex: [*c]GRecMutex) void;
pub extern fn g_cond_init(cond: [*c]GCond) void;
pub extern fn g_cond_clear(cond: [*c]GCond) void;
pub extern fn g_cond_wait(cond: [*c]GCond, mutex: [*c]GMutex) void;
pub extern fn g_cond_signal(cond: [*c]GCond) void;
pub extern fn g_cond_broadcast(cond: [*c]GCond) void;
pub extern fn g_cond_wait_until(cond: [*c]GCond, mutex: [*c]GMutex, end_time: gint64) gboolean;
pub extern fn g_private_get(key: [*c]GPrivate) gpointer;
pub extern fn g_private_set(key: [*c]GPrivate, value: gpointer) void;
pub extern fn g_private_replace(key: [*c]GPrivate, value: gpointer) void;
pub extern fn g_once_impl(once: [*c]GOnce, func: GThreadFunc, arg: gpointer) gpointer;
pub extern fn g_once_init_enter(location: ?*volatile anyopaque) gboolean;
pub extern fn g_once_init_leave(location: ?*volatile anyopaque, result: gsize) void;
pub extern fn g_get_num_processors() guint;
pub const GMutexLocker = anyopaque;
pub fn g_mutex_locker_new(arg_mutex: [*c]GMutex) callconv(.C) ?*GMutexLocker {
    var mutex = arg_mutex;
    g_mutex_lock(mutex);
    return @ptrCast(?*GMutexLocker, mutex);
}
pub fn g_mutex_locker_free(arg_locker: ?*GMutexLocker) callconv(.C) void {
    var locker = arg_locker;
    g_mutex_unlock(@ptrCast([*c]GMutex, @alignCast(@import("std").meta.alignment([*c]GMutex), locker)));
}
pub const GRecMutexLocker = anyopaque;
pub fn g_rec_mutex_locker_new(arg_rec_mutex: [*c]GRecMutex) callconv(.C) ?*GRecMutexLocker {
    var rec_mutex = arg_rec_mutex;
    g_rec_mutex_lock(rec_mutex);
    return @ptrCast(?*GRecMutexLocker, rec_mutex);
}
pub fn g_rec_mutex_locker_free(arg_locker: ?*GRecMutexLocker) callconv(.C) void {
    var locker = arg_locker;
    g_rec_mutex_unlock(@ptrCast([*c]GRecMutex, @alignCast(@import("std").meta.alignment([*c]GRecMutex), locker)));
}
pub const GRWLockWriterLocker = anyopaque;
pub fn g_rw_lock_writer_locker_new(arg_rw_lock: [*c]GRWLock) callconv(.C) ?*GRWLockWriterLocker {
    var rw_lock = arg_rw_lock;
    g_rw_lock_writer_lock(rw_lock);
    return @ptrCast(?*GRWLockWriterLocker, rw_lock);
}
pub fn g_rw_lock_writer_locker_free(arg_locker: ?*GRWLockWriterLocker) callconv(.C) void {
    var locker = arg_locker;
    g_rw_lock_writer_unlock(@ptrCast([*c]GRWLock, @alignCast(@import("std").meta.alignment([*c]GRWLock), locker)));
}
pub const GRWLockReaderLocker = anyopaque;
pub fn g_rw_lock_reader_locker_new(arg_rw_lock: [*c]GRWLock) callconv(.C) ?*GRWLockReaderLocker {
    var rw_lock = arg_rw_lock;
    g_rw_lock_reader_lock(rw_lock);
    return @ptrCast(?*GRWLockReaderLocker, rw_lock);
}
pub fn g_rw_lock_reader_locker_free(arg_locker: ?*GRWLockReaderLocker) callconv(.C) void {
    var locker = arg_locker;
    g_rw_lock_reader_unlock(@ptrCast([*c]GRWLock, @alignCast(@import("std").meta.alignment([*c]GRWLock), locker)));
}
pub const struct__GAsyncQueue = opaque {};
pub const GAsyncQueue = struct__GAsyncQueue;
pub extern fn g_async_queue_new() ?*GAsyncQueue;
pub extern fn g_async_queue_new_full(item_free_func: GDestroyNotify) ?*GAsyncQueue;
pub extern fn g_async_queue_lock(queue: ?*GAsyncQueue) void;
pub extern fn g_async_queue_unlock(queue: ?*GAsyncQueue) void;
pub extern fn g_async_queue_ref(queue: ?*GAsyncQueue) ?*GAsyncQueue;
pub extern fn g_async_queue_unref(queue: ?*GAsyncQueue) void;
pub extern fn g_async_queue_ref_unlocked(queue: ?*GAsyncQueue) void;
pub extern fn g_async_queue_unref_and_unlock(queue: ?*GAsyncQueue) void;
pub extern fn g_async_queue_push(queue: ?*GAsyncQueue, data: gpointer) void;
pub extern fn g_async_queue_push_unlocked(queue: ?*GAsyncQueue, data: gpointer) void;
pub extern fn g_async_queue_push_sorted(queue: ?*GAsyncQueue, data: gpointer, func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_async_queue_push_sorted_unlocked(queue: ?*GAsyncQueue, data: gpointer, func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_async_queue_pop(queue: ?*GAsyncQueue) gpointer;
pub extern fn g_async_queue_pop_unlocked(queue: ?*GAsyncQueue) gpointer;
pub extern fn g_async_queue_try_pop(queue: ?*GAsyncQueue) gpointer;
pub extern fn g_async_queue_try_pop_unlocked(queue: ?*GAsyncQueue) gpointer;
pub extern fn g_async_queue_timeout_pop(queue: ?*GAsyncQueue, timeout: guint64) gpointer;
pub extern fn g_async_queue_timeout_pop_unlocked(queue: ?*GAsyncQueue, timeout: guint64) gpointer;
pub extern fn g_async_queue_length(queue: ?*GAsyncQueue) gint;
pub extern fn g_async_queue_length_unlocked(queue: ?*GAsyncQueue) gint;
pub extern fn g_async_queue_sort(queue: ?*GAsyncQueue, func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_async_queue_sort_unlocked(queue: ?*GAsyncQueue, func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_async_queue_remove(queue: ?*GAsyncQueue, item: gpointer) gboolean;
pub extern fn g_async_queue_remove_unlocked(queue: ?*GAsyncQueue, item: gpointer) gboolean;
pub extern fn g_async_queue_push_front(queue: ?*GAsyncQueue, item: gpointer) void;
pub extern fn g_async_queue_push_front_unlocked(queue: ?*GAsyncQueue, item: gpointer) void;
pub extern fn g_async_queue_timed_pop(queue: ?*GAsyncQueue, end_time: [*c]GTimeVal) gpointer;
pub extern fn g_async_queue_timed_pop_unlocked(queue: ?*GAsyncQueue, end_time: [*c]GTimeVal) gpointer;
pub const sig_atomic_t = __sig_atomic_t;
const struct_unnamed_10 = extern struct {
    si_pid: __pid_t,
    si_uid: __uid_t,
};
const struct_unnamed_11 = extern struct {
    si_tid: c_int,
    si_overrun: c_int,
    si_sigval: __sigval_t,
};
const struct_unnamed_12 = extern struct {
    si_pid: __pid_t,
    si_uid: __uid_t,
    si_sigval: __sigval_t,
};
const struct_unnamed_13 = extern struct {
    si_pid: __pid_t,
    si_uid: __uid_t,
    si_status: c_int,
    si_utime: __clock_t,
    si_stime: __clock_t,
};
const struct_unnamed_16 = extern struct {
    _lower: ?*anyopaque,
    _upper: ?*anyopaque,
};
const union_unnamed_15 = extern union {
    _addr_bnd: struct_unnamed_16,
    _pkey: __uint32_t,
};
const struct_unnamed_14 = extern struct {
    si_addr: ?*anyopaque,
    si_addr_lsb: c_short,
    _bounds: union_unnamed_15,
};
const struct_unnamed_17 = extern struct {
    si_band: c_long,
    si_fd: c_int,
};
const struct_unnamed_18 = extern struct {
    _call_addr: ?*anyopaque,
    _syscall: c_int,
    _arch: c_uint,
};
const union_unnamed_9 = extern union {
    _pad: [28]c_int,
    _kill: struct_unnamed_10,
    _timer: struct_unnamed_11,
    _rt: struct_unnamed_12,
    _sigchld: struct_unnamed_13,
    _sigfault: struct_unnamed_14,
    _sigpoll: struct_unnamed_17,
    _sigsys: struct_unnamed_18,
};
pub const siginfo_t = extern struct {
    si_signo: c_int,
    si_errno: c_int,
    si_code: c_int,
    __pad0: c_int,
    _sifields: union_unnamed_9,
};
pub const SI_ASYNCNL: c_int = -60;
pub const SI_DETHREAD: c_int = -7;
pub const SI_TKILL: c_int = -6;
pub const SI_SIGIO: c_int = -5;
pub const SI_ASYNCIO: c_int = -4;
pub const SI_MESGQ: c_int = -3;
pub const SI_TIMER: c_int = -2;
pub const SI_QUEUE: c_int = -1;
pub const SI_USER: c_int = 0;
pub const SI_KERNEL: c_int = 128;
const enum_unnamed_19 = c_int;
pub const ILL_ILLOPC: c_int = 1;
pub const ILL_ILLOPN: c_int = 2;
pub const ILL_ILLADR: c_int = 3;
pub const ILL_ILLTRP: c_int = 4;
pub const ILL_PRVOPC: c_int = 5;
pub const ILL_PRVREG: c_int = 6;
pub const ILL_COPROC: c_int = 7;
pub const ILL_BADSTK: c_int = 8;
pub const ILL_BADIADDR: c_int = 9;
const enum_unnamed_20 = c_uint;
pub const FPE_INTDIV: c_int = 1;
pub const FPE_INTOVF: c_int = 2;
pub const FPE_FLTDIV: c_int = 3;
pub const FPE_FLTOVF: c_int = 4;
pub const FPE_FLTUND: c_int = 5;
pub const FPE_FLTRES: c_int = 6;
pub const FPE_FLTINV: c_int = 7;
pub const FPE_FLTSUB: c_int = 8;
pub const FPE_FLTUNK: c_int = 14;
pub const FPE_CONDTRAP: c_int = 15;
const enum_unnamed_21 = c_uint;
pub const SEGV_MAPERR: c_int = 1;
pub const SEGV_ACCERR: c_int = 2;
pub const SEGV_BNDERR: c_int = 3;
pub const SEGV_PKUERR: c_int = 4;
pub const SEGV_ACCADI: c_int = 5;
pub const SEGV_ADIDERR: c_int = 6;
pub const SEGV_ADIPERR: c_int = 7;
pub const SEGV_MTEAERR: c_int = 8;
pub const SEGV_MTESERR: c_int = 9;
const enum_unnamed_22 = c_uint;
pub const BUS_ADRALN: c_int = 1;
pub const BUS_ADRERR: c_int = 2;
pub const BUS_OBJERR: c_int = 3;
pub const BUS_MCEERR_AR: c_int = 4;
pub const BUS_MCEERR_AO: c_int = 5;
const enum_unnamed_23 = c_uint;
pub const CLD_EXITED: c_int = 1;
pub const CLD_KILLED: c_int = 2;
pub const CLD_DUMPED: c_int = 3;
pub const CLD_TRAPPED: c_int = 4;
pub const CLD_STOPPED: c_int = 5;
pub const CLD_CONTINUED: c_int = 6;
const enum_unnamed_24 = c_uint;
pub const POLL_IN: c_int = 1;
pub const POLL_OUT: c_int = 2;
pub const POLL_MSG: c_int = 3;
pub const POLL_ERR: c_int = 4;
pub const POLL_PRI: c_int = 5;
pub const POLL_HUP: c_int = 6;
const enum_unnamed_25 = c_uint;
pub const sigval_t = __sigval_t;
pub const sigevent_t = struct_sigevent;
pub const SIGEV_SIGNAL: c_int = 0;
pub const SIGEV_NONE: c_int = 1;
pub const SIGEV_THREAD: c_int = 2;
pub const SIGEV_THREAD_ID: c_int = 4;
const enum_unnamed_26 = c_uint;
pub const __sighandler_t = ?fn (c_int) callconv(.C) void;
pub extern fn __sysv_signal(__sig: c_int, __handler: __sighandler_t) __sighandler_t;
pub extern fn signal(__sig: c_int, __handler: __sighandler_t) __sighandler_t;
pub extern fn kill(__pid: __pid_t, __sig: c_int) c_int;
pub extern fn killpg(__pgrp: __pid_t, __sig: c_int) c_int;
pub extern fn raise(__sig: c_int) c_int;
pub extern fn ssignal(__sig: c_int, __handler: __sighandler_t) __sighandler_t;
pub extern fn gsignal(__sig: c_int) c_int;
pub extern fn psignal(__sig: c_int, __s: [*c]const u8) void;
pub extern fn psiginfo(__pinfo: [*c]const siginfo_t, __s: [*c]const u8) void;
pub extern fn sigblock(__mask: c_int) c_int;
pub extern fn sigsetmask(__mask: c_int) c_int;
pub extern fn siggetmask() c_int;
pub const sig_t = __sighandler_t;
pub extern fn sigemptyset(__set: [*c]sigset_t) c_int;
pub extern fn sigfillset(__set: [*c]sigset_t) c_int;
pub extern fn sigaddset(__set: [*c]sigset_t, __signo: c_int) c_int;
pub extern fn sigdelset(__set: [*c]sigset_t, __signo: c_int) c_int;
pub extern fn sigismember(__set: [*c]const sigset_t, __signo: c_int) c_int;
const union_unnamed_27 = extern union {
    sa_handler: __sighandler_t,
    sa_sigaction: ?fn (c_int, [*c]siginfo_t, ?*anyopaque) callconv(.C) void,
};
pub const struct_sigaction = extern struct {
    __sigaction_handler: union_unnamed_27,
    sa_mask: __sigset_t,
    sa_flags: c_int,
    sa_restorer: ?fn () callconv(.C) void,
};
pub extern fn sigprocmask(__how: c_int, noalias __set: [*c]const sigset_t, noalias __oset: [*c]sigset_t) c_int;
pub extern fn sigsuspend(__set: [*c]const sigset_t) c_int;
pub extern fn sigaction(__sig: c_int, noalias __act: [*c]const struct_sigaction, noalias __oact: [*c]struct_sigaction) c_int;
pub extern fn sigpending(__set: [*c]sigset_t) c_int;
pub extern fn sigwait(noalias __set: [*c]const sigset_t, noalias __sig: [*c]c_int) c_int;
pub extern fn sigwaitinfo(noalias __set: [*c]const sigset_t, noalias __info: [*c]siginfo_t) c_int;
pub extern fn sigtimedwait(noalias __set: [*c]const sigset_t, noalias __info: [*c]siginfo_t, noalias __timeout: [*c]const struct_timespec) c_int;
pub extern fn sigqueue(__pid: __pid_t, __sig: c_int, __val: union_sigval) c_int;
pub const __s8 = i8;
pub const __u8 = u8;
pub const __s16 = c_short;
pub const __u16 = c_ushort;
pub const __s32 = c_int;
pub const __u32 = c_uint;
pub const __s64 = c_longlong;
pub const __u64 = c_ulonglong;
pub const __kernel_fd_set = extern struct {
    fds_bits: [16]c_ulong,
};
pub const __kernel_sighandler_t = ?fn (c_int) callconv(.C) void;
pub const __kernel_key_t = c_int;
pub const __kernel_mqd_t = c_int;
pub const __kernel_old_uid_t = c_ushort;
pub const __kernel_old_gid_t = c_ushort;
pub const __kernel_long_t = c_long;
pub const __kernel_ulong_t = c_ulong;
pub const __kernel_ino_t = __kernel_ulong_t;
pub const __kernel_mode_t = c_uint;
pub const __kernel_pid_t = c_int;
pub const __kernel_ipc_pid_t = c_int;
pub const __kernel_uid_t = c_uint;
pub const __kernel_gid_t = c_uint;
pub const __kernel_suseconds_t = __kernel_long_t;
pub const __kernel_daddr_t = c_int;
pub const __kernel_uid32_t = c_uint;
pub const __kernel_gid32_t = c_uint;
pub const __kernel_old_dev_t = c_uint;
pub const __kernel_size_t = __kernel_ulong_t;
pub const __kernel_ssize_t = __kernel_long_t;
pub const __kernel_ptrdiff_t = __kernel_long_t;
pub const __kernel_fsid_t = extern struct {
    val: [2]c_int,
};
pub const __kernel_off_t = __kernel_long_t;
pub const __kernel_loff_t = c_longlong;
pub const __kernel_old_time_t = __kernel_long_t;
pub const __kernel_time_t = __kernel_long_t;
pub const __kernel_time64_t = c_longlong;
pub const __kernel_clock_t = __kernel_long_t;
pub const __kernel_timer_t = c_int;
pub const __kernel_clockid_t = c_int;
pub const __kernel_caddr_t = [*c]u8;
pub const __kernel_uid16_t = c_ushort;
pub const __kernel_gid16_t = c_ushort;
pub const __le16 = __u16;
pub const __be16 = __u16;
pub const __le32 = __u32;
pub const __be32 = __u32;
pub const __le64 = __u64;
pub const __be64 = __u64;
pub const __sum16 = __u16;
pub const __wsum = __u32;
pub const __poll_t = c_uint;
pub const struct_sigcontext = extern struct {
    fault_address: __u64,
    regs: [31]__u64,
    sp: __u64,
    pc: __u64,
    pstate: __u64,
    __reserved: [4096]__u8 align(16),
};
pub const struct__aarch64_ctx = extern struct {
    magic: __u32,
    size: __u32,
};
pub const __uint128_t = u128;
pub const struct_fpsimd_context = extern struct {
    head: struct__aarch64_ctx,
    fpsr: __u32,
    fpcr: __u32,
    vregs: [32]__uint128_t,
};
pub const struct_esr_context = extern struct {
    head: struct__aarch64_ctx,
    esr: __u64,
};
pub const struct_extra_context = extern struct {
    head: struct__aarch64_ctx,
    datap: __u64,
    size: __u32,
    __reserved: [3]__u32,
};
pub const struct_sve_context = extern struct {
    head: struct__aarch64_ctx,
    vl: __u16,
    __reserved: [3]__u16,
};
pub extern fn sigreturn(__scp: [*c]struct_sigcontext) c_int;
pub const stack_t = extern struct {
    ss_sp: ?*anyopaque,
    ss_flags: c_int,
    ss_size: usize,
};
pub const struct_timezone = extern struct {
    tz_minuteswest: c_int,
    tz_dsttime: c_int,
};
pub extern fn gettimeofday(noalias __tv: [*c]struct_timeval, noalias __tz: ?*anyopaque) c_int;
pub extern fn settimeofday(__tv: [*c]const struct_timeval, __tz: [*c]const struct_timezone) c_int;
pub extern fn adjtime(__delta: [*c]const struct_timeval, __olddelta: [*c]struct_timeval) c_int;
pub const ITIMER_REAL: c_int = 0;
pub const ITIMER_VIRTUAL: c_int = 1;
pub const ITIMER_PROF: c_int = 2;
pub const enum___itimer_which = c_uint;
pub const struct_itimerval = extern struct {
    it_interval: struct_timeval,
    it_value: struct_timeval,
};
pub const __itimer_which_t = c_int;
pub extern fn getitimer(__which: __itimer_which_t, __value: [*c]struct_itimerval) c_int;
pub extern fn setitimer(__which: __itimer_which_t, noalias __new: [*c]const struct_itimerval, noalias __old: [*c]struct_itimerval) c_int;
pub extern fn utimes(__file: [*c]const u8, __tvp: [*c]const struct_timeval) c_int;
pub extern fn lutimes(__file: [*c]const u8, __tvp: [*c]const struct_timeval) c_int;
pub extern fn futimes(__fd: c_int, __tvp: [*c]const struct_timeval) c_int;
pub const struct_user_regs_struct = extern struct {
    regs: [31]c_ulonglong,
    sp: c_ulonglong,
    pc: c_ulonglong,
    pstate: c_ulonglong,
};
pub const struct_user_fpsimd_struct = extern struct {
    vregs: [32]__uint128_t,
    fpsr: c_uint,
    fpcr: c_uint,
};
pub const elf_greg_t = __uint64_t;
pub const elf_gregset_t = [34]elf_greg_t;
pub const elf_fpregset_t = struct_user_fpsimd_struct;
pub const __pr_uid_t = c_uint;
pub const __pr_gid_t = c_uint;
pub const struct_elf_siginfo = extern struct {
    si_signo: c_int,
    si_code: c_int,
    si_errno: c_int,
};
pub const struct_elf_prstatus = extern struct {
    pr_info: struct_elf_siginfo,
    pr_cursig: c_short,
    pr_sigpend: c_ulong,
    pr_sighold: c_ulong,
    pr_pid: __pid_t,
    pr_ppid: __pid_t,
    pr_pgrp: __pid_t,
    pr_sid: __pid_t,
    pr_utime: struct_timeval,
    pr_stime: struct_timeval,
    pr_cutime: struct_timeval,
    pr_cstime: struct_timeval,
    pr_reg: elf_gregset_t,
    pr_fpvalid: c_int,
};
pub const struct_elf_prpsinfo = extern struct {
    pr_state: u8,
    pr_sname: u8,
    pr_zomb: u8,
    pr_nice: u8,
    pr_flag: c_ulong,
    pr_uid: __pr_uid_t,
    pr_gid: __pr_gid_t,
    pr_pid: c_int,
    pr_ppid: c_int,
    pr_pgrp: c_int,
    pr_sid: c_int,
    pr_fname: [16]u8,
    pr_psargs: [80]u8,
};
pub const psaddr_t = ?*anyopaque;
pub const __prgregset_t = elf_gregset_t;
pub const __prfpregset_t = elf_fpregset_t;
pub const prgregset_t = __prgregset_t;
pub const prfpregset_t = __prfpregset_t;
pub const lwpid_t = __pid_t;
pub const prstatus_t = struct_elf_prstatus;
pub const prpsinfo_t = struct_elf_prpsinfo;
pub const greg_t = elf_greg_t;
pub const gregset_t = elf_gregset_t;
pub const fpregset_t = elf_fpregset_t;
pub const mcontext_t = extern struct {
    fault_address: c_ulonglong,
    regs: [31]c_ulonglong,
    sp: c_ulonglong,
    pc: c_ulonglong,
    pstate: c_ulonglong,
    __reserved: [4096]u8 align(16),
};
pub const struct_ucontext_t = extern struct {
    uc_flags: c_ulong,
    uc_link: [*c]struct_ucontext_t,
    uc_stack: stack_t,
    uc_sigmask: sigset_t,
    uc_mcontext: mcontext_t,
};
pub const ucontext_t = struct_ucontext_t;
pub extern fn siginterrupt(__sig: c_int, __interrupt: c_int) c_int;
pub const SS_ONSTACK: c_int = 1;
pub const SS_DISABLE: c_int = 2;
const enum_unnamed_28 = c_uint;
pub extern fn sigaltstack(noalias __ss: [*c]const stack_t, noalias __oss: [*c]stack_t) c_int;
pub const struct_sigstack = extern struct {
    ss_sp: ?*anyopaque,
    ss_onstack: c_int,
};
pub extern fn sigstack(__ss: [*c]struct_sigstack, __oss: [*c]struct_sigstack) c_int;
pub extern fn pthread_sigmask(__how: c_int, noalias __newmask: [*c]const __sigset_t, noalias __oldmask: [*c]__sigset_t) c_int;
pub extern fn pthread_kill(__threadid: pthread_t, __signo: c_int) c_int;
pub extern fn __libc_current_sigrtmin() c_int;
pub extern fn __libc_current_sigrtmax() c_int;
pub extern fn g_on_error_query(prg_name: [*c]const gchar) void;
pub extern fn g_on_error_stack_trace(prg_name: [*c]const gchar) void;
pub extern fn g_base64_encode_step(in: [*c]const guchar, len: gsize, break_lines: gboolean, out: [*c]gchar, state: [*c]gint, save: [*c]gint) gsize;
pub extern fn g_base64_encode_close(break_lines: gboolean, out: [*c]gchar, state: [*c]gint, save: [*c]gint) gsize;
pub extern fn g_base64_encode(data: [*c]const guchar, len: gsize) [*c]gchar;
pub extern fn g_base64_decode_step(in: [*c]const gchar, len: gsize, out: [*c]guchar, state: [*c]gint, save: [*c]guint) gsize;
pub extern fn g_base64_decode(text: [*c]const gchar, out_len: [*c]gsize) [*c]guchar;
pub extern fn g_base64_decode_inplace(text: [*c]gchar, out_len: [*c]gsize) [*c]guchar;
pub extern fn g_bit_lock(address: [*c]volatile gint, lock_bit: gint) void;
pub extern fn g_bit_trylock(address: [*c]volatile gint, lock_bit: gint) gboolean;
pub extern fn g_bit_unlock(address: [*c]volatile gint, lock_bit: gint) void;
pub extern fn g_pointer_bit_lock(address: ?*volatile anyopaque, lock_bit: gint) void;
pub extern fn g_pointer_bit_trylock(address: ?*volatile anyopaque, lock_bit: gint) gboolean;
pub extern fn g_pointer_bit_unlock(address: ?*volatile anyopaque, lock_bit: gint) void;
pub const struct__GTimeZone = opaque {};
pub const GTimeZone = struct__GTimeZone;
pub const G_TIME_TYPE_STANDARD: c_int = 0;
pub const G_TIME_TYPE_DAYLIGHT: c_int = 1;
pub const G_TIME_TYPE_UNIVERSAL: c_int = 2;
pub const GTimeType = c_uint;
pub extern fn g_time_zone_new(identifier: [*c]const gchar) ?*GTimeZone;
pub extern fn g_time_zone_new_identifier(identifier: [*c]const gchar) ?*GTimeZone;
pub extern fn g_time_zone_new_utc() ?*GTimeZone;
pub extern fn g_time_zone_new_local() ?*GTimeZone;
pub extern fn g_time_zone_new_offset(seconds: gint32) ?*GTimeZone;
pub extern fn g_time_zone_ref(tz: ?*GTimeZone) ?*GTimeZone;
pub extern fn g_time_zone_unref(tz: ?*GTimeZone) void;
pub extern fn g_time_zone_find_interval(tz: ?*GTimeZone, @"type": GTimeType, time_: gint64) gint;
pub extern fn g_time_zone_adjust_time(tz: ?*GTimeZone, @"type": GTimeType, time_: [*c]gint64) gint;
pub extern fn g_time_zone_get_abbreviation(tz: ?*GTimeZone, interval: gint) [*c]const gchar;
pub extern fn g_time_zone_get_offset(tz: ?*GTimeZone, interval: gint) gint32;
pub extern fn g_time_zone_is_dst(tz: ?*GTimeZone, interval: gint) gboolean;
pub extern fn g_time_zone_get_identifier(tz: ?*GTimeZone) [*c]const gchar;
pub const GTimeSpan = gint64;
pub const struct__GDateTime = opaque {};
pub const GDateTime = struct__GDateTime;
pub extern fn g_date_time_unref(datetime: ?*GDateTime) void;
pub extern fn g_date_time_ref(datetime: ?*GDateTime) ?*GDateTime;
pub extern fn g_date_time_new_now(tz: ?*GTimeZone) ?*GDateTime;
pub extern fn g_date_time_new_now_local() ?*GDateTime;
pub extern fn g_date_time_new_now_utc() ?*GDateTime;
pub extern fn g_date_time_new_from_unix_local(t: gint64) ?*GDateTime;
pub extern fn g_date_time_new_from_unix_utc(t: gint64) ?*GDateTime;
pub extern fn g_date_time_new_from_timeval_local(tv: [*c]const GTimeVal) ?*GDateTime;
pub extern fn g_date_time_new_from_timeval_utc(tv: [*c]const GTimeVal) ?*GDateTime;
pub extern fn g_date_time_new_from_iso8601(text: [*c]const gchar, default_tz: ?*GTimeZone) ?*GDateTime;
pub extern fn g_date_time_new(tz: ?*GTimeZone, year: gint, month: gint, day: gint, hour: gint, minute: gint, seconds: gdouble) ?*GDateTime;
pub extern fn g_date_time_new_local(year: gint, month: gint, day: gint, hour: gint, minute: gint, seconds: gdouble) ?*GDateTime;
pub extern fn g_date_time_new_utc(year: gint, month: gint, day: gint, hour: gint, minute: gint, seconds: gdouble) ?*GDateTime;
pub extern fn g_date_time_add(datetime: ?*GDateTime, timespan: GTimeSpan) ?*GDateTime;
pub extern fn g_date_time_add_years(datetime: ?*GDateTime, years: gint) ?*GDateTime;
pub extern fn g_date_time_add_months(datetime: ?*GDateTime, months: gint) ?*GDateTime;
pub extern fn g_date_time_add_weeks(datetime: ?*GDateTime, weeks: gint) ?*GDateTime;
pub extern fn g_date_time_add_days(datetime: ?*GDateTime, days: gint) ?*GDateTime;
pub extern fn g_date_time_add_hours(datetime: ?*GDateTime, hours: gint) ?*GDateTime;
pub extern fn g_date_time_add_minutes(datetime: ?*GDateTime, minutes: gint) ?*GDateTime;
pub extern fn g_date_time_add_seconds(datetime: ?*GDateTime, seconds: gdouble) ?*GDateTime;
pub extern fn g_date_time_add_full(datetime: ?*GDateTime, years: gint, months: gint, days: gint, hours: gint, minutes: gint, seconds: gdouble) ?*GDateTime;
pub extern fn g_date_time_compare(dt1: gconstpointer, dt2: gconstpointer) gint;
pub extern fn g_date_time_difference(end: ?*GDateTime, begin: ?*GDateTime) GTimeSpan;
pub extern fn g_date_time_hash(datetime: gconstpointer) guint;
pub extern fn g_date_time_equal(dt1: gconstpointer, dt2: gconstpointer) gboolean;
pub extern fn g_date_time_get_ymd(datetime: ?*GDateTime, year: [*c]gint, month: [*c]gint, day: [*c]gint) void;
pub extern fn g_date_time_get_year(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_month(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_day_of_month(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_week_numbering_year(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_week_of_year(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_day_of_week(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_day_of_year(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_hour(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_minute(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_second(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_microsecond(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_seconds(datetime: ?*GDateTime) gdouble;
pub extern fn g_date_time_to_unix(datetime: ?*GDateTime) gint64;
pub extern fn g_date_time_to_timeval(datetime: ?*GDateTime, tv: [*c]GTimeVal) gboolean;
pub extern fn g_date_time_get_utc_offset(datetime: ?*GDateTime) GTimeSpan;
pub extern fn g_date_time_get_timezone(datetime: ?*GDateTime) ?*GTimeZone;
pub extern fn g_date_time_get_timezone_abbreviation(datetime: ?*GDateTime) [*c]const gchar;
pub extern fn g_date_time_is_daylight_savings(datetime: ?*GDateTime) gboolean;
pub extern fn g_date_time_to_timezone(datetime: ?*GDateTime, tz: ?*GTimeZone) ?*GDateTime;
pub extern fn g_date_time_to_local(datetime: ?*GDateTime) ?*GDateTime;
pub extern fn g_date_time_to_utc(datetime: ?*GDateTime) ?*GDateTime;
pub extern fn g_date_time_format(datetime: ?*GDateTime, format: [*c]const gchar) [*c]gchar;
pub extern fn g_date_time_format_iso8601(datetime: ?*GDateTime) [*c]gchar;
pub const G_BOOKMARK_FILE_ERROR_INVALID_URI: c_int = 0;
pub const G_BOOKMARK_FILE_ERROR_INVALID_VALUE: c_int = 1;
pub const G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: c_int = 2;
pub const G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: c_int = 3;
pub const G_BOOKMARK_FILE_ERROR_READ: c_int = 4;
pub const G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: c_int = 5;
pub const G_BOOKMARK_FILE_ERROR_WRITE: c_int = 6;
pub const G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: c_int = 7;
pub const GBookmarkFileError = c_uint;
pub extern fn g_bookmark_file_error_quark() GQuark;
pub const struct__GBookmarkFile = opaque {};
pub const GBookmarkFile = struct__GBookmarkFile;
pub extern fn g_bookmark_file_new() ?*GBookmarkFile;
pub extern fn g_bookmark_file_free(bookmark: ?*GBookmarkFile) void;
pub extern fn g_bookmark_file_load_from_file(bookmark: ?*GBookmarkFile, filename: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_load_from_data(bookmark: ?*GBookmarkFile, data: [*c]const gchar, length: gsize, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_load_from_data_dirs(bookmark: ?*GBookmarkFile, file: [*c]const gchar, full_path: [*c][*c]gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_to_data(bookmark: ?*GBookmarkFile, length: [*c]gsize, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_bookmark_file_to_file(bookmark: ?*GBookmarkFile, filename: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_set_title(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, title: [*c]const gchar) void;
pub extern fn g_bookmark_file_get_title(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_bookmark_file_set_description(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, description: [*c]const gchar) void;
pub extern fn g_bookmark_file_get_description(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_bookmark_file_set_mime_type(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, mime_type: [*c]const gchar) void;
pub extern fn g_bookmark_file_get_mime_type(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_bookmark_file_set_groups(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, groups: [*c][*c]const gchar, length: gsize) void;
pub extern fn g_bookmark_file_add_group(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, group: [*c]const gchar) void;
pub extern fn g_bookmark_file_has_group(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, group: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_get_groups(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, length: [*c]gsize, @"error": [*c][*c]GError) [*c][*c]gchar;
pub extern fn g_bookmark_file_add_application(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, name: [*c]const gchar, exec: [*c]const gchar) void;
pub extern fn g_bookmark_file_has_application(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, name: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_get_applications(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, length: [*c]gsize, @"error": [*c][*c]GError) [*c][*c]gchar;
pub extern fn g_bookmark_file_set_app_info(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, name: [*c]const gchar, exec: [*c]const gchar, count: gint, stamp: time_t, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_set_application_info(bookmark: ?*GBookmarkFile, uri: [*c]const u8, name: [*c]const u8, exec: [*c]const u8, count: c_int, stamp: ?*GDateTime, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_get_app_info(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, name: [*c]const gchar, exec: [*c][*c]gchar, count: [*c]guint, stamp: [*c]time_t, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_get_application_info(bookmark: ?*GBookmarkFile, uri: [*c]const u8, name: [*c]const u8, exec: [*c][*c]u8, count: [*c]c_uint, stamp: [*c]?*GDateTime, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_set_is_private(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, is_private: gboolean) void;
pub extern fn g_bookmark_file_get_is_private(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_set_icon(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, href: [*c]const gchar, mime_type: [*c]const gchar) void;
pub extern fn g_bookmark_file_get_icon(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, href: [*c][*c]gchar, mime_type: [*c][*c]gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_set_added(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, added: time_t) void;
pub extern fn g_bookmark_file_set_added_date_time(bookmark: ?*GBookmarkFile, uri: [*c]const u8, added: ?*GDateTime) void;
pub extern fn g_bookmark_file_get_added(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, @"error": [*c][*c]GError) time_t;
pub extern fn g_bookmark_file_get_added_date_time(bookmark: ?*GBookmarkFile, uri: [*c]const u8, @"error": [*c][*c]GError) ?*GDateTime;
pub extern fn g_bookmark_file_set_modified(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, modified: time_t) void;
pub extern fn g_bookmark_file_set_modified_date_time(bookmark: ?*GBookmarkFile, uri: [*c]const u8, modified: ?*GDateTime) void;
pub extern fn g_bookmark_file_get_modified(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, @"error": [*c][*c]GError) time_t;
pub extern fn g_bookmark_file_get_modified_date_time(bookmark: ?*GBookmarkFile, uri: [*c]const u8, @"error": [*c][*c]GError) ?*GDateTime;
pub extern fn g_bookmark_file_set_visited(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, visited: time_t) void;
pub extern fn g_bookmark_file_set_visited_date_time(bookmark: ?*GBookmarkFile, uri: [*c]const u8, visited: ?*GDateTime) void;
pub extern fn g_bookmark_file_get_visited(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, @"error": [*c][*c]GError) time_t;
pub extern fn g_bookmark_file_get_visited_date_time(bookmark: ?*GBookmarkFile, uri: [*c]const u8, @"error": [*c][*c]GError) ?*GDateTime;
pub extern fn g_bookmark_file_has_item(bookmark: ?*GBookmarkFile, uri: [*c]const gchar) gboolean;
pub extern fn g_bookmark_file_get_size(bookmark: ?*GBookmarkFile) gint;
pub extern fn g_bookmark_file_get_uris(bookmark: ?*GBookmarkFile, length: [*c]gsize) [*c][*c]gchar;
pub extern fn g_bookmark_file_remove_group(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, group: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_remove_application(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, name: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_remove_item(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_move_item(bookmark: ?*GBookmarkFile, old_uri: [*c]const gchar, new_uri: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bytes_new(data: gconstpointer, size: gsize) ?*GBytes;
pub extern fn g_bytes_new_take(data: gpointer, size: gsize) ?*GBytes;
pub extern fn g_bytes_new_static(data: gconstpointer, size: gsize) ?*GBytes;
pub extern fn g_bytes_new_with_free_func(data: gconstpointer, size: gsize, free_func: GDestroyNotify, user_data: gpointer) ?*GBytes;
pub extern fn g_bytes_new_from_bytes(bytes: ?*GBytes, offset: gsize, length: gsize) ?*GBytes;
pub extern fn g_bytes_get_data(bytes: ?*GBytes, size: [*c]gsize) gconstpointer;
pub extern fn g_bytes_get_size(bytes: ?*GBytes) gsize;
pub extern fn g_bytes_ref(bytes: ?*GBytes) ?*GBytes;
pub extern fn g_bytes_unref(bytes: ?*GBytes) void;
pub extern fn g_bytes_unref_to_data(bytes: ?*GBytes, size: [*c]gsize) gpointer;
pub extern fn g_bytes_unref_to_array(bytes: ?*GBytes) [*c]GByteArray;
pub extern fn g_bytes_hash(bytes: gconstpointer) guint;
pub extern fn g_bytes_equal(bytes1: gconstpointer, bytes2: gconstpointer) gboolean;
pub extern fn g_bytes_compare(bytes1: gconstpointer, bytes2: gconstpointer) gint;
pub extern fn g_bytes_get_region(bytes: ?*GBytes, element_size: gsize, offset: gsize, n_elements: gsize) gconstpointer;
pub extern fn g_get_charset(charset: [*c][*c]const u8) gboolean;
pub extern fn g_get_codeset() [*c]gchar;
pub extern fn g_get_console_charset(charset: [*c][*c]const u8) gboolean;
pub extern fn g_get_language_names() [*c]const [*c]const gchar;
pub extern fn g_get_language_names_with_category(category_name: [*c]const gchar) [*c]const [*c]const gchar;
pub extern fn g_get_locale_variants(locale: [*c]const gchar) [*c][*c]gchar;
pub const G_CHECKSUM_MD5: c_int = 0;
pub const G_CHECKSUM_SHA1: c_int = 1;
pub const G_CHECKSUM_SHA256: c_int = 2;
pub const G_CHECKSUM_SHA512: c_int = 3;
pub const G_CHECKSUM_SHA384: c_int = 4;
pub const GChecksumType = c_uint;
pub const struct__GChecksum = opaque {};
pub const GChecksum = struct__GChecksum;
pub extern fn g_checksum_type_get_length(checksum_type: GChecksumType) gssize;
pub extern fn g_checksum_new(checksum_type: GChecksumType) ?*GChecksum;
pub extern fn g_checksum_reset(checksum: ?*GChecksum) void;
pub extern fn g_checksum_copy(checksum: ?*const GChecksum) ?*GChecksum;
pub extern fn g_checksum_free(checksum: ?*GChecksum) void;
pub extern fn g_checksum_update(checksum: ?*GChecksum, data: [*c]const guchar, length: gssize) void;
pub extern fn g_checksum_get_string(checksum: ?*GChecksum) [*c]const gchar;
pub extern fn g_checksum_get_digest(checksum: ?*GChecksum, buffer: [*c]guint8, digest_len: [*c]gsize) void;
pub extern fn g_compute_checksum_for_data(checksum_type: GChecksumType, data: [*c]const guchar, length: gsize) [*c]gchar;
pub extern fn g_compute_checksum_for_string(checksum_type: GChecksumType, str: [*c]const gchar, length: gssize) [*c]gchar;
pub extern fn g_compute_checksum_for_bytes(checksum_type: GChecksumType, data: ?*GBytes) [*c]gchar;
pub const G_CONVERT_ERROR_NO_CONVERSION: c_int = 0;
pub const G_CONVERT_ERROR_ILLEGAL_SEQUENCE: c_int = 1;
pub const G_CONVERT_ERROR_FAILED: c_int = 2;
pub const G_CONVERT_ERROR_PARTIAL_INPUT: c_int = 3;
pub const G_CONVERT_ERROR_BAD_URI: c_int = 4;
pub const G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: c_int = 5;
pub const G_CONVERT_ERROR_NO_MEMORY: c_int = 6;
pub const G_CONVERT_ERROR_EMBEDDED_NUL: c_int = 7;
pub const GConvertError = c_uint;
pub extern fn g_convert_error_quark() GQuark;
pub const struct__GIConv = opaque {};
pub const GIConv = ?*struct__GIConv;
pub extern fn g_iconv_open(to_codeset: [*c]const gchar, from_codeset: [*c]const gchar) GIConv;
pub extern fn g_iconv(converter: GIConv, inbuf: [*c][*c]gchar, inbytes_left: [*c]gsize, outbuf: [*c][*c]gchar, outbytes_left: [*c]gsize) gsize;
pub extern fn g_iconv_close(converter: GIConv) gint;
pub extern fn g_convert(str: [*c]const gchar, len: gssize, to_codeset: [*c]const gchar, from_codeset: [*c]const gchar, bytes_read: [*c]gsize, bytes_written: [*c]gsize, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_convert_with_iconv(str: [*c]const gchar, len: gssize, converter: GIConv, bytes_read: [*c]gsize, bytes_written: [*c]gsize, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_convert_with_fallback(str: [*c]const gchar, len: gssize, to_codeset: [*c]const gchar, from_codeset: [*c]const gchar, fallback: [*c]const gchar, bytes_read: [*c]gsize, bytes_written: [*c]gsize, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_locale_to_utf8(opsysstring: [*c]const gchar, len: gssize, bytes_read: [*c]gsize, bytes_written: [*c]gsize, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_locale_from_utf8(utf8string: [*c]const gchar, len: gssize, bytes_read: [*c]gsize, bytes_written: [*c]gsize, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_filename_to_utf8(opsysstring: [*c]const gchar, len: gssize, bytes_read: [*c]gsize, bytes_written: [*c]gsize, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_filename_from_utf8(utf8string: [*c]const gchar, len: gssize, bytes_read: [*c]gsize, bytes_written: [*c]gsize, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_filename_from_uri(uri: [*c]const gchar, hostname: [*c][*c]gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_filename_to_uri(filename: [*c]const gchar, hostname: [*c]const gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_filename_display_name(filename: [*c]const gchar) [*c]gchar;
pub extern fn g_get_filename_charsets(filename_charsets: [*c][*c][*c]const gchar) gboolean;
pub extern fn g_filename_display_basename(filename: [*c]const gchar) [*c]gchar;
pub extern fn g_uri_list_extract_uris(uri_list: [*c]const gchar) [*c][*c]gchar;
pub const struct__GData = opaque {};
pub const GData = struct__GData;
pub const GDataForeachFunc = ?fn (GQuark, gpointer, gpointer) callconv(.C) void;
pub extern fn g_datalist_init(datalist: [*c]?*GData) void;
pub extern fn g_datalist_clear(datalist: [*c]?*GData) void;
pub extern fn g_datalist_id_get_data(datalist: [*c]?*GData, key_id: GQuark) gpointer;
pub extern fn g_datalist_id_set_data_full(datalist: [*c]?*GData, key_id: GQuark, data: gpointer, destroy_func: GDestroyNotify) void;
pub const GDuplicateFunc = ?fn (gpointer, gpointer) callconv(.C) gpointer;
pub extern fn g_datalist_id_dup_data(datalist: [*c]?*GData, key_id: GQuark, dup_func: GDuplicateFunc, user_data: gpointer) gpointer;
pub extern fn g_datalist_id_replace_data(datalist: [*c]?*GData, key_id: GQuark, oldval: gpointer, newval: gpointer, destroy: GDestroyNotify, old_destroy: [*c]GDestroyNotify) gboolean;
pub extern fn g_datalist_id_remove_no_notify(datalist: [*c]?*GData, key_id: GQuark) gpointer;
pub extern fn g_datalist_foreach(datalist: [*c]?*GData, func: GDataForeachFunc, user_data: gpointer) void;
pub extern fn g_datalist_set_flags(datalist: [*c]?*GData, flags: guint) void;
pub extern fn g_datalist_unset_flags(datalist: [*c]?*GData, flags: guint) void;
pub extern fn g_datalist_get_flags(datalist: [*c]?*GData) guint;
pub extern fn g_dataset_destroy(dataset_location: gconstpointer) void;
pub extern fn g_dataset_id_get_data(dataset_location: gconstpointer, key_id: GQuark) gpointer;
pub extern fn g_datalist_get_data(datalist: [*c]?*GData, key: [*c]const gchar) gpointer;
pub extern fn g_dataset_id_set_data_full(dataset_location: gconstpointer, key_id: GQuark, data: gpointer, destroy_func: GDestroyNotify) void;
pub extern fn g_dataset_id_remove_no_notify(dataset_location: gconstpointer, key_id: GQuark) gpointer;
pub extern fn g_dataset_foreach(dataset_location: gconstpointer, func: GDataForeachFunc, user_data: gpointer) void;
pub const GTime = gint32;
pub const GDateYear = guint16;
pub const GDateDay = guint8; // /usr/include/glib-2.0/glib/gdate.h:101:9: warning: struct demoted to opaque type - has bitfield
pub const struct__GDate = opaque {};
pub const GDate = struct__GDate;
pub const G_DATE_DAY: c_int = 0;
pub const G_DATE_MONTH: c_int = 1;
pub const G_DATE_YEAR: c_int = 2;
pub const GDateDMY = c_uint;
pub const G_DATE_BAD_WEEKDAY: c_int = 0;
pub const G_DATE_MONDAY: c_int = 1;
pub const G_DATE_TUESDAY: c_int = 2;
pub const G_DATE_WEDNESDAY: c_int = 3;
pub const G_DATE_THURSDAY: c_int = 4;
pub const G_DATE_FRIDAY: c_int = 5;
pub const G_DATE_SATURDAY: c_int = 6;
pub const G_DATE_SUNDAY: c_int = 7;
pub const GDateWeekday = c_uint;
pub const G_DATE_BAD_MONTH: c_int = 0;
pub const G_DATE_JANUARY: c_int = 1;
pub const G_DATE_FEBRUARY: c_int = 2;
pub const G_DATE_MARCH: c_int = 3;
pub const G_DATE_APRIL: c_int = 4;
pub const G_DATE_MAY: c_int = 5;
pub const G_DATE_JUNE: c_int = 6;
pub const G_DATE_JULY: c_int = 7;
pub const G_DATE_AUGUST: c_int = 8;
pub const G_DATE_SEPTEMBER: c_int = 9;
pub const G_DATE_OCTOBER: c_int = 10;
pub const G_DATE_NOVEMBER: c_int = 11;
pub const G_DATE_DECEMBER: c_int = 12;
pub const GDateMonth = c_uint;
pub extern fn g_date_new() ?*GDate;
pub extern fn g_date_new_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) ?*GDate;
pub extern fn g_date_new_julian(julian_day: guint32) ?*GDate;
pub extern fn g_date_free(date: ?*GDate) void;
pub extern fn g_date_copy(date: ?*const GDate) ?*GDate;
pub extern fn g_date_valid(date: ?*const GDate) gboolean;
pub extern fn g_date_valid_day(day: GDateDay) gboolean;
pub extern fn g_date_valid_month(month: GDateMonth) gboolean;
pub extern fn g_date_valid_year(year: GDateYear) gboolean;
pub extern fn g_date_valid_weekday(weekday: GDateWeekday) gboolean;
pub extern fn g_date_valid_julian(julian_date: guint32) gboolean;
pub extern fn g_date_valid_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) gboolean;
pub extern fn g_date_get_weekday(date: ?*const GDate) GDateWeekday;
pub extern fn g_date_get_month(date: ?*const GDate) GDateMonth;
pub extern fn g_date_get_year(date: ?*const GDate) GDateYear;
pub extern fn g_date_get_day(date: ?*const GDate) GDateDay;
pub extern fn g_date_get_julian(date: ?*const GDate) guint32;
pub extern fn g_date_get_day_of_year(date: ?*const GDate) guint;
pub extern fn g_date_get_monday_week_of_year(date: ?*const GDate) guint;
pub extern fn g_date_get_sunday_week_of_year(date: ?*const GDate) guint;
pub extern fn g_date_get_iso8601_week_of_year(date: ?*const GDate) guint;
pub extern fn g_date_clear(date: ?*GDate, n_dates: guint) void;
pub extern fn g_date_set_parse(date: ?*GDate, str: [*c]const gchar) void;
pub extern fn g_date_set_time_t(date: ?*GDate, timet: time_t) void;
pub extern fn g_date_set_time_val(date: ?*GDate, timeval: [*c]GTimeVal) void;
pub extern fn g_date_set_time(date: ?*GDate, time_: GTime) void;
pub extern fn g_date_set_month(date: ?*GDate, month: GDateMonth) void;
pub extern fn g_date_set_day(date: ?*GDate, day: GDateDay) void;
pub extern fn g_date_set_year(date: ?*GDate, year: GDateYear) void;
pub extern fn g_date_set_dmy(date: ?*GDate, day: GDateDay, month: GDateMonth, y: GDateYear) void;
pub extern fn g_date_set_julian(date: ?*GDate, julian_date: guint32) void;
pub extern fn g_date_is_first_of_month(date: ?*const GDate) gboolean;
pub extern fn g_date_is_last_of_month(date: ?*const GDate) gboolean;
pub extern fn g_date_add_days(date: ?*GDate, n_days: guint) void;
pub extern fn g_date_subtract_days(date: ?*GDate, n_days: guint) void;
pub extern fn g_date_add_months(date: ?*GDate, n_months: guint) void;
pub extern fn g_date_subtract_months(date: ?*GDate, n_months: guint) void;
pub extern fn g_date_add_years(date: ?*GDate, n_years: guint) void;
pub extern fn g_date_subtract_years(date: ?*GDate, n_years: guint) void;
pub extern fn g_date_is_leap_year(year: GDateYear) gboolean;
pub extern fn g_date_get_days_in_month(month: GDateMonth, year: GDateYear) guint8;
pub extern fn g_date_get_monday_weeks_in_year(year: GDateYear) guint8;
pub extern fn g_date_get_sunday_weeks_in_year(year: GDateYear) guint8;
pub extern fn g_date_days_between(date1: ?*const GDate, date2: ?*const GDate) gint;
pub extern fn g_date_compare(lhs: ?*const GDate, rhs: ?*const GDate) gint;
pub extern fn g_date_to_struct_tm(date: ?*const GDate, tm: [*c]struct_tm) void;
pub extern fn g_date_clamp(date: ?*GDate, min_date: ?*const GDate, max_date: ?*const GDate) void;
pub extern fn g_date_order(date1: ?*GDate, date2: ?*GDate) void;
pub extern fn g_date_strftime(s: [*c]gchar, slen: gsize, format: [*c]const gchar, date: ?*const GDate) gsize;
pub const struct_dirent = extern struct {
    d_ino: __ino_t,
    d_off: __off_t,
    d_reclen: c_ushort,
    d_type: u8,
    d_name: [256]u8,
};
pub const DT_UNKNOWN: c_int = 0;
pub const DT_FIFO: c_int = 1;
pub const DT_CHR: c_int = 2;
pub const DT_DIR: c_int = 4;
pub const DT_BLK: c_int = 6;
pub const DT_REG: c_int = 8;
pub const DT_LNK: c_int = 10;
pub const DT_SOCK: c_int = 12;
pub const DT_WHT: c_int = 14;
const enum_unnamed_29 = c_uint;
pub const struct___dirstream = opaque {};
pub const DIR = struct___dirstream;
pub extern fn opendir(__name: [*c]const u8) ?*DIR;
pub extern fn fdopendir(__fd: c_int) ?*DIR;
pub extern fn closedir(__dirp: ?*DIR) c_int;
pub extern fn readdir(__dirp: ?*DIR) [*c]struct_dirent;
pub extern fn readdir_r(noalias __dirp: ?*DIR, noalias __entry: [*c]struct_dirent, noalias __result: [*c][*c]struct_dirent) c_int;
pub extern fn rewinddir(__dirp: ?*DIR) void;
pub extern fn seekdir(__dirp: ?*DIR, __pos: c_long) void;
pub extern fn telldir(__dirp: ?*DIR) c_long;
pub extern fn dirfd(__dirp: ?*DIR) c_int;
pub extern fn scandir(noalias __dir: [*c]const u8, noalias __namelist: [*c][*c][*c]struct_dirent, __selector: ?fn ([*c]const struct_dirent) callconv(.C) c_int, __cmp: ?fn ([*c][*c]const struct_dirent, [*c][*c]const struct_dirent) callconv(.C) c_int) c_int;
pub extern fn alphasort(__e1: [*c][*c]const struct_dirent, __e2: [*c][*c]const struct_dirent) c_int;
pub extern fn getdirentries(__fd: c_int, noalias __buf: [*c]u8, __nbytes: usize, noalias __basep: [*c]__off_t) __ssize_t;
pub const struct__GDir = opaque {};
pub const GDir = struct__GDir;
pub extern fn g_dir_open(path: [*c]const gchar, flags: guint, @"error": [*c][*c]GError) ?*GDir;
pub extern fn g_dir_read_name(dir: ?*GDir) [*c]const gchar;
pub extern fn g_dir_rewind(dir: ?*GDir) void;
pub extern fn g_dir_close(dir: ?*GDir) void;
pub extern fn g_getenv(variable: [*c]const gchar) [*c]const gchar;
pub extern fn g_setenv(variable: [*c]const gchar, value: [*c]const gchar, overwrite: gboolean) gboolean;
pub extern fn g_unsetenv(variable: [*c]const gchar) void;
pub extern fn g_listenv() [*c][*c]gchar;
pub extern fn g_get_environ() [*c][*c]gchar;
pub extern fn g_environ_getenv(envp: [*c][*c]gchar, variable: [*c]const gchar) [*c]const gchar;
pub extern fn g_environ_setenv(envp: [*c][*c]gchar, variable: [*c]const gchar, value: [*c]const gchar, overwrite: gboolean) [*c][*c]gchar;
pub extern fn g_environ_unsetenv(envp: [*c][*c]gchar, variable: [*c]const gchar) [*c][*c]gchar;
pub const G_FILE_ERROR_EXIST: c_int = 0;
pub const G_FILE_ERROR_ISDIR: c_int = 1;
pub const G_FILE_ERROR_ACCES: c_int = 2;
pub const G_FILE_ERROR_NAMETOOLONG: c_int = 3;
pub const G_FILE_ERROR_NOENT: c_int = 4;
pub const G_FILE_ERROR_NOTDIR: c_int = 5;
pub const G_FILE_ERROR_NXIO: c_int = 6;
pub const G_FILE_ERROR_NODEV: c_int = 7;
pub const G_FILE_ERROR_ROFS: c_int = 8;
pub const G_FILE_ERROR_TXTBSY: c_int = 9;
pub const G_FILE_ERROR_FAULT: c_int = 10;
pub const G_FILE_ERROR_LOOP: c_int = 11;
pub const G_FILE_ERROR_NOSPC: c_int = 12;
pub const G_FILE_ERROR_NOMEM: c_int = 13;
pub const G_FILE_ERROR_MFILE: c_int = 14;
pub const G_FILE_ERROR_NFILE: c_int = 15;
pub const G_FILE_ERROR_BADF: c_int = 16;
pub const G_FILE_ERROR_INVAL: c_int = 17;
pub const G_FILE_ERROR_PIPE: c_int = 18;
pub const G_FILE_ERROR_AGAIN: c_int = 19;
pub const G_FILE_ERROR_INTR: c_int = 20;
pub const G_FILE_ERROR_IO: c_int = 21;
pub const G_FILE_ERROR_PERM: c_int = 22;
pub const G_FILE_ERROR_NOSYS: c_int = 23;
pub const G_FILE_ERROR_FAILED: c_int = 24;
pub const GFileError = c_uint;
pub const G_FILE_TEST_IS_REGULAR: c_int = 1;
pub const G_FILE_TEST_IS_SYMLINK: c_int = 2;
pub const G_FILE_TEST_IS_DIR: c_int = 4;
pub const G_FILE_TEST_IS_EXECUTABLE: c_int = 8;
pub const G_FILE_TEST_EXISTS: c_int = 16;
pub const GFileTest = c_uint;
pub const G_FILE_SET_CONTENTS_NONE: c_int = 0;
pub const G_FILE_SET_CONTENTS_CONSISTENT: c_int = 1;
pub const G_FILE_SET_CONTENTS_DURABLE: c_int = 2;
pub const G_FILE_SET_CONTENTS_ONLY_EXISTING: c_int = 4;
pub const GFileSetContentsFlags = c_uint;
pub extern fn g_file_error_quark() GQuark;
pub extern fn g_file_error_from_errno(err_no: gint) GFileError;
pub extern fn g_file_test(filename: [*c]const gchar, @"test": GFileTest) gboolean;
pub extern fn g_file_get_contents(filename: [*c]const gchar, contents: [*c][*c]gchar, length: [*c]gsize, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_set_contents(filename: [*c]const gchar, contents: [*c]const gchar, length: gssize, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_set_contents_full(filename: [*c]const gchar, contents: [*c]const gchar, length: gssize, flags: GFileSetContentsFlags, mode: c_int, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_read_link(filename: [*c]const gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_mkdtemp(tmpl: [*c]gchar) [*c]gchar;
pub extern fn g_mkdtemp_full(tmpl: [*c]gchar, mode: gint) [*c]gchar;
pub extern fn g_mkstemp(tmpl: [*c]gchar) gint;
pub extern fn g_mkstemp_full(tmpl: [*c]gchar, flags: gint, mode: gint) gint;
pub extern fn g_file_open_tmp(tmpl: [*c]const gchar, name_used: [*c][*c]gchar, @"error": [*c][*c]GError) gint;
pub extern fn g_dir_make_tmp(tmpl: [*c]const gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_build_path(separator: [*c]const gchar, first_element: [*c]const gchar, ...) [*c]gchar;
pub extern fn g_build_pathv(separator: [*c]const gchar, args: [*c][*c]gchar) [*c]gchar;
pub extern fn g_build_filename(first_element: [*c]const gchar, ...) [*c]gchar;
pub extern fn g_build_filenamev(args: [*c][*c]gchar) [*c]gchar;
pub extern fn g_build_filename_valist(first_element: [*c]const gchar, args: [*c]va_list) [*c]gchar;
pub extern fn g_mkdir_with_parents(pathname: [*c]const gchar, mode: gint) gint;
pub extern fn g_path_is_absolute(file_name: [*c]const gchar) gboolean;
pub extern fn g_path_skip_root(file_name: [*c]const gchar) [*c]const gchar;
pub extern fn g_basename(file_name: [*c]const gchar) [*c]const gchar;
pub extern fn g_get_current_dir() [*c]gchar;
pub extern fn g_path_get_basename(file_name: [*c]const gchar) [*c]gchar;
pub extern fn g_path_get_dirname(file_name: [*c]const gchar) [*c]gchar;
pub extern fn g_canonicalize_filename(filename: [*c]const gchar, relative_to: [*c]const gchar) [*c]gchar;
pub extern fn g_strip_context(msgid: [*c]const gchar, msgval: [*c]const gchar) [*c]const gchar;
pub extern fn g_dgettext(domain: [*c]const gchar, msgid: [*c]const gchar) [*c]const gchar;
pub extern fn g_dcgettext(domain: [*c]const gchar, msgid: [*c]const gchar, category: gint) [*c]const gchar;
pub extern fn g_dngettext(domain: [*c]const gchar, msgid: [*c]const gchar, msgid_plural: [*c]const gchar, n: gulong) [*c]const gchar;
pub extern fn g_dpgettext(domain: [*c]const gchar, msgctxtid: [*c]const gchar, msgidoffset: gsize) [*c]const gchar;
pub extern fn g_dpgettext2(domain: [*c]const gchar, context: [*c]const gchar, msgid: [*c]const gchar) [*c]const gchar;
pub const struct__GMemVTable = extern struct {
    malloc: ?fn (gsize) callconv(.C) gpointer,
    realloc: ?fn (gpointer, gsize) callconv(.C) gpointer,
    free: ?fn (gpointer) callconv(.C) void,
    calloc: ?fn (gsize, gsize) callconv(.C) gpointer,
    try_malloc: ?fn (gsize) callconv(.C) gpointer,
    try_realloc: ?fn (gpointer, gsize) callconv(.C) gpointer,
};
pub const GMemVTable = struct__GMemVTable;
pub extern fn g_free(mem: gpointer) void;
pub extern fn g_clear_pointer(pp: [*c]gpointer, destroy: GDestroyNotify) void;
pub extern fn g_malloc(n_bytes: gsize) gpointer;
pub extern fn g_malloc0(n_bytes: gsize) gpointer;
pub extern fn g_realloc(mem: gpointer, n_bytes: gsize) gpointer;
pub extern fn g_try_malloc(n_bytes: gsize) gpointer;
pub extern fn g_try_malloc0(n_bytes: gsize) gpointer;
pub extern fn g_try_realloc(mem: gpointer, n_bytes: gsize) gpointer;
pub extern fn g_malloc_n(n_blocks: gsize, n_block_bytes: gsize) gpointer;
pub extern fn g_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) gpointer;
pub extern fn g_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) gpointer;
pub extern fn g_try_malloc_n(n_blocks: gsize, n_block_bytes: gsize) gpointer;
pub extern fn g_try_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) gpointer;
pub extern fn g_try_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) gpointer;
pub extern fn g_aligned_alloc(n_blocks: gsize, n_block_bytes: gsize, alignment: gsize) gpointer;
pub extern fn g_aligned_alloc0(n_blocks: gsize, n_block_bytes: gsize, alignment: gsize) gpointer;
pub extern fn g_aligned_free(mem: gpointer) void;
pub fn g_steal_pointer(arg_pp: gpointer) callconv(.C) gpointer {
    var pp = arg_pp;
    var ptr: [*c]gpointer = @ptrCast([*c]gpointer, @alignCast(@import("std").meta.alignment([*c]gpointer), pp));
    var ref: gpointer = undefined;
    ref = ptr.*;
    ptr.* = @intToPtr(?*anyopaque, @as(c_int, 0));
    return ref;
}
pub extern fn g_mem_set_vtable(vtable: [*c]GMemVTable) void;
pub extern fn g_mem_is_system_malloc() gboolean;
pub extern var g_mem_gc_friendly: gboolean;
pub extern var glib_mem_profiler_table: [*c]GMemVTable;
pub extern fn g_mem_profile() void;
pub const GNode = struct__GNode;
pub const struct__GNode = extern struct {
    data: gpointer,
    next: [*c]GNode,
    prev: [*c]GNode,
    parent: [*c]GNode,
    children: [*c]GNode,
};
pub const G_TRAVERSE_LEAVES: c_int = 1;
pub const G_TRAVERSE_NON_LEAVES: c_int = 2;
pub const G_TRAVERSE_ALL: c_int = 3;
pub const G_TRAVERSE_MASK: c_int = 3;
pub const G_TRAVERSE_LEAFS: c_int = 1;
pub const G_TRAVERSE_NON_LEAFS: c_int = 2;
pub const GTraverseFlags = c_uint;
pub const G_IN_ORDER: c_int = 0;
pub const G_PRE_ORDER: c_int = 1;
pub const G_POST_ORDER: c_int = 2;
pub const G_LEVEL_ORDER: c_int = 3;
pub const GTraverseType = c_uint;
pub const GNodeTraverseFunc = ?fn ([*c]GNode, gpointer) callconv(.C) gboolean;
pub const GNodeForeachFunc = ?fn ([*c]GNode, gpointer) callconv(.C) void;
pub extern fn g_node_new(data: gpointer) [*c]GNode;
pub extern fn g_node_destroy(root: [*c]GNode) void;
pub extern fn g_node_unlink(node: [*c]GNode) void;
pub extern fn g_node_copy_deep(node: [*c]GNode, copy_func: GCopyFunc, data: gpointer) [*c]GNode;
pub extern fn g_node_copy(node: [*c]GNode) [*c]GNode;
pub extern fn g_node_insert(parent: [*c]GNode, position: gint, node: [*c]GNode) [*c]GNode;
pub extern fn g_node_insert_before(parent: [*c]GNode, sibling: [*c]GNode, node: [*c]GNode) [*c]GNode;
pub extern fn g_node_insert_after(parent: [*c]GNode, sibling: [*c]GNode, node: [*c]GNode) [*c]GNode;
pub extern fn g_node_prepend(parent: [*c]GNode, node: [*c]GNode) [*c]GNode;
pub extern fn g_node_n_nodes(root: [*c]GNode, flags: GTraverseFlags) guint;
pub extern fn g_node_get_root(node: [*c]GNode) [*c]GNode;
pub extern fn g_node_is_ancestor(node: [*c]GNode, descendant: [*c]GNode) gboolean;
pub extern fn g_node_depth(node: [*c]GNode) guint;
pub extern fn g_node_find(root: [*c]GNode, order: GTraverseType, flags: GTraverseFlags, data: gpointer) [*c]GNode;
pub extern fn g_node_traverse(root: [*c]GNode, order: GTraverseType, flags: GTraverseFlags, max_depth: gint, func: GNodeTraverseFunc, data: gpointer) void;
pub extern fn g_node_max_height(root: [*c]GNode) guint;
pub extern fn g_node_children_foreach(node: [*c]GNode, flags: GTraverseFlags, func: GNodeForeachFunc, data: gpointer) void;
pub extern fn g_node_reverse_children(node: [*c]GNode) void;
pub extern fn g_node_n_children(node: [*c]GNode) guint;
pub extern fn g_node_nth_child(node: [*c]GNode, n: guint) [*c]GNode;
pub extern fn g_node_last_child(node: [*c]GNode) [*c]GNode;
pub extern fn g_node_find_child(node: [*c]GNode, flags: GTraverseFlags, data: gpointer) [*c]GNode;
pub extern fn g_node_child_position(node: [*c]GNode, child: [*c]GNode) gint;
pub extern fn g_node_child_index(node: [*c]GNode, data: gpointer) gint;
pub extern fn g_node_first_sibling(node: [*c]GNode) [*c]GNode;
pub extern fn g_node_last_sibling(node: [*c]GNode) [*c]GNode;
pub const GList = struct__GList;
pub const struct__GList = extern struct {
    data: gpointer,
    next: [*c]GList,
    prev: [*c]GList,
};
pub extern fn g_list_alloc() [*c]GList;
pub extern fn g_list_free(list: [*c]GList) void;
pub extern fn g_list_free_1(list: [*c]GList) void;
pub extern fn g_list_free_full(list: [*c]GList, free_func: GDestroyNotify) void;
pub extern fn g_list_append(list: [*c]GList, data: gpointer) [*c]GList;
pub extern fn g_list_prepend(list: [*c]GList, data: gpointer) [*c]GList;
pub extern fn g_list_insert(list: [*c]GList, data: gpointer, position: gint) [*c]GList;
pub extern fn g_list_insert_sorted(list: [*c]GList, data: gpointer, func: GCompareFunc) [*c]GList;
pub extern fn g_list_insert_sorted_with_data(list: [*c]GList, data: gpointer, func: GCompareDataFunc, user_data: gpointer) [*c]GList;
pub extern fn g_list_insert_before(list: [*c]GList, sibling: [*c]GList, data: gpointer) [*c]GList;
pub extern fn g_list_insert_before_link(list: [*c]GList, sibling: [*c]GList, link_: [*c]GList) [*c]GList;
pub extern fn g_list_concat(list1: [*c]GList, list2: [*c]GList) [*c]GList;
pub extern fn g_list_remove(list: [*c]GList, data: gconstpointer) [*c]GList;
pub extern fn g_list_remove_all(list: [*c]GList, data: gconstpointer) [*c]GList;
pub extern fn g_list_remove_link(list: [*c]GList, llink: [*c]GList) [*c]GList;
pub extern fn g_list_delete_link(list: [*c]GList, link_: [*c]GList) [*c]GList;
pub extern fn g_list_reverse(list: [*c]GList) [*c]GList;
pub extern fn g_list_copy(list: [*c]GList) [*c]GList;
pub extern fn g_list_copy_deep(list: [*c]GList, func: GCopyFunc, user_data: gpointer) [*c]GList;
pub extern fn g_list_nth(list: [*c]GList, n: guint) [*c]GList;
pub extern fn g_list_nth_prev(list: [*c]GList, n: guint) [*c]GList;
pub extern fn g_list_find(list: [*c]GList, data: gconstpointer) [*c]GList;
pub extern fn g_list_find_custom(list: [*c]GList, data: gconstpointer, func: GCompareFunc) [*c]GList;
pub extern fn g_list_position(list: [*c]GList, llink: [*c]GList) gint;
pub extern fn g_list_index(list: [*c]GList, data: gconstpointer) gint;
pub extern fn g_list_last(list: [*c]GList) [*c]GList;
pub extern fn g_list_first(list: [*c]GList) [*c]GList;
pub extern fn g_list_length(list: [*c]GList) guint;
pub extern fn g_list_foreach(list: [*c]GList, func: GFunc, user_data: gpointer) void;
pub extern fn g_list_sort(list: [*c]GList, compare_func: GCompareFunc) [*c]GList;
pub extern fn g_list_sort_with_data(list: [*c]GList, compare_func: GCompareDataFunc, user_data: gpointer) [*c]GList;
pub extern fn g_list_nth_data(list: [*c]GList, n: guint) gpointer;
pub extern fn g_clear_list(list_ptr: [*c][*c]GList, destroy: GDestroyNotify) void;
pub const struct__GHashTable = opaque {};
pub const GHashTable = struct__GHashTable;
pub const GHRFunc = ?fn (gpointer, gpointer, gpointer) callconv(.C) gboolean;
pub const struct__GHashTableIter = extern struct {
    dummy1: gpointer,
    dummy2: gpointer,
    dummy3: gpointer,
    dummy4: c_int,
    dummy5: gboolean,
    dummy6: gpointer,
};
pub const GHashTableIter = struct__GHashTableIter;
pub extern fn g_hash_table_new(hash_func: GHashFunc, key_equal_func: GEqualFunc) ?*GHashTable;
pub extern fn g_hash_table_new_full(hash_func: GHashFunc, key_equal_func: GEqualFunc, key_destroy_func: GDestroyNotify, value_destroy_func: GDestroyNotify) ?*GHashTable;
pub extern fn g_hash_table_new_similar(other_hash_table: ?*GHashTable) ?*GHashTable;
pub extern fn g_hash_table_destroy(hash_table: ?*GHashTable) void;
pub extern fn g_hash_table_insert(hash_table: ?*GHashTable, key: gpointer, value: gpointer) gboolean;
pub extern fn g_hash_table_replace(hash_table: ?*GHashTable, key: gpointer, value: gpointer) gboolean;
pub extern fn g_hash_table_add(hash_table: ?*GHashTable, key: gpointer) gboolean;
pub extern fn g_hash_table_remove(hash_table: ?*GHashTable, key: gconstpointer) gboolean;
pub extern fn g_hash_table_remove_all(hash_table: ?*GHashTable) void;
pub extern fn g_hash_table_steal(hash_table: ?*GHashTable, key: gconstpointer) gboolean;
pub extern fn g_hash_table_steal_extended(hash_table: ?*GHashTable, lookup_key: gconstpointer, stolen_key: [*c]gpointer, stolen_value: [*c]gpointer) gboolean;
pub extern fn g_hash_table_steal_all(hash_table: ?*GHashTable) void;
pub extern fn g_hash_table_lookup(hash_table: ?*GHashTable, key: gconstpointer) gpointer;
pub extern fn g_hash_table_contains(hash_table: ?*GHashTable, key: gconstpointer) gboolean;
pub extern fn g_hash_table_lookup_extended(hash_table: ?*GHashTable, lookup_key: gconstpointer, orig_key: [*c]gpointer, value: [*c]gpointer) gboolean;
pub extern fn g_hash_table_foreach(hash_table: ?*GHashTable, func: GHFunc, user_data: gpointer) void;
pub extern fn g_hash_table_find(hash_table: ?*GHashTable, predicate: GHRFunc, user_data: gpointer) gpointer;
pub extern fn g_hash_table_foreach_remove(hash_table: ?*GHashTable, func: GHRFunc, user_data: gpointer) guint;
pub extern fn g_hash_table_foreach_steal(hash_table: ?*GHashTable, func: GHRFunc, user_data: gpointer) guint;
pub extern fn g_hash_table_size(hash_table: ?*GHashTable) guint;
pub extern fn g_hash_table_get_keys(hash_table: ?*GHashTable) [*c]GList;
pub extern fn g_hash_table_get_values(hash_table: ?*GHashTable) [*c]GList;
pub extern fn g_hash_table_get_keys_as_array(hash_table: ?*GHashTable, length: [*c]guint) [*c]gpointer;
pub extern fn g_hash_table_iter_init(iter: [*c]GHashTableIter, hash_table: ?*GHashTable) void;
pub extern fn g_hash_table_iter_next(iter: [*c]GHashTableIter, key: [*c]gpointer, value: [*c]gpointer) gboolean;
pub extern fn g_hash_table_iter_get_hash_table(iter: [*c]GHashTableIter) ?*GHashTable;
pub extern fn g_hash_table_iter_remove(iter: [*c]GHashTableIter) void;
pub extern fn g_hash_table_iter_replace(iter: [*c]GHashTableIter, value: gpointer) void;
pub extern fn g_hash_table_iter_steal(iter: [*c]GHashTableIter) void;
pub extern fn g_hash_table_ref(hash_table: ?*GHashTable) ?*GHashTable;
pub extern fn g_hash_table_unref(hash_table: ?*GHashTable) void;
pub extern fn g_str_equal(v1: gconstpointer, v2: gconstpointer) gboolean;
pub extern fn g_str_hash(v: gconstpointer) guint;
pub extern fn g_int_equal(v1: gconstpointer, v2: gconstpointer) gboolean;
pub extern fn g_int_hash(v: gconstpointer) guint;
pub extern fn g_int64_equal(v1: gconstpointer, v2: gconstpointer) gboolean;
pub extern fn g_int64_hash(v: gconstpointer) guint;
pub extern fn g_double_equal(v1: gconstpointer, v2: gconstpointer) gboolean;
pub extern fn g_double_hash(v: gconstpointer) guint;
pub extern fn g_direct_hash(v: gconstpointer) guint;
pub extern fn g_direct_equal(v1: gconstpointer, v2: gconstpointer) gboolean;
pub const struct__GHmac = opaque {};
pub const GHmac = struct__GHmac;
pub extern fn g_hmac_new(digest_type: GChecksumType, key: [*c]const guchar, key_len: gsize) ?*GHmac;
pub extern fn g_hmac_copy(hmac: ?*const GHmac) ?*GHmac;
pub extern fn g_hmac_ref(hmac: ?*GHmac) ?*GHmac;
pub extern fn g_hmac_unref(hmac: ?*GHmac) void;
pub extern fn g_hmac_update(hmac: ?*GHmac, data: [*c]const guchar, length: gssize) void;
pub extern fn g_hmac_get_string(hmac: ?*GHmac) [*c]const gchar;
pub extern fn g_hmac_get_digest(hmac: ?*GHmac, buffer: [*c]guint8, digest_len: [*c]gsize) void;
pub extern fn g_compute_hmac_for_data(digest_type: GChecksumType, key: [*c]const guchar, key_len: gsize, data: [*c]const guchar, length: gsize) [*c]gchar;
pub extern fn g_compute_hmac_for_string(digest_type: GChecksumType, key: [*c]const guchar, key_len: gsize, str: [*c]const gchar, length: gssize) [*c]gchar;
pub extern fn g_compute_hmac_for_bytes(digest_type: GChecksumType, key: ?*GBytes, data: ?*GBytes) [*c]gchar;
pub const GHook = struct__GHook;
pub const struct__GHook = extern struct {
    data: gpointer,
    next: [*c]GHook,
    prev: [*c]GHook,
    ref_count: guint,
    hook_id: gulong,
    flags: guint,
    func: gpointer,
    destroy: GDestroyNotify,
}; // /usr/include/glib-2.0/glib/ghook.h:66:14: warning: struct demoted to opaque type - has bitfield
pub const struct__GHookList = opaque {};
pub const GHookList = struct__GHookList;
pub const GHookCompareFunc = ?fn ([*c]GHook, [*c]GHook) callconv(.C) gint;
pub const GHookFindFunc = ?fn ([*c]GHook, gpointer) callconv(.C) gboolean;
pub const GHookMarshaller = ?fn ([*c]GHook, gpointer) callconv(.C) void;
pub const GHookCheckMarshaller = ?fn ([*c]GHook, gpointer) callconv(.C) gboolean;
pub const GHookFunc = ?fn (gpointer) callconv(.C) void;
pub const GHookCheckFunc = ?fn (gpointer) callconv(.C) gboolean;
pub const GHookFinalizeFunc = ?fn (?*GHookList, [*c]GHook) callconv(.C) void;
pub const G_HOOK_FLAG_ACTIVE: c_int = 1;
pub const G_HOOK_FLAG_IN_CALL: c_int = 2;
pub const G_HOOK_FLAG_MASK: c_int = 15;
pub const GHookFlagMask = c_uint;
pub extern fn g_hook_list_init(hook_list: ?*GHookList, hook_size: guint) void;
pub extern fn g_hook_list_clear(hook_list: ?*GHookList) void;
pub extern fn g_hook_alloc(hook_list: ?*GHookList) [*c]GHook;
pub extern fn g_hook_free(hook_list: ?*GHookList, hook: [*c]GHook) void;
pub extern fn g_hook_ref(hook_list: ?*GHookList, hook: [*c]GHook) [*c]GHook;
pub extern fn g_hook_unref(hook_list: ?*GHookList, hook: [*c]GHook) void;
pub extern fn g_hook_destroy(hook_list: ?*GHookList, hook_id: gulong) gboolean;
pub extern fn g_hook_destroy_link(hook_list: ?*GHookList, hook: [*c]GHook) void;
pub extern fn g_hook_prepend(hook_list: ?*GHookList, hook: [*c]GHook) void;
pub extern fn g_hook_insert_before(hook_list: ?*GHookList, sibling: [*c]GHook, hook: [*c]GHook) void;
pub extern fn g_hook_insert_sorted(hook_list: ?*GHookList, hook: [*c]GHook, func: GHookCompareFunc) void;
pub extern fn g_hook_get(hook_list: ?*GHookList, hook_id: gulong) [*c]GHook;
pub extern fn g_hook_find(hook_list: ?*GHookList, need_valids: gboolean, func: GHookFindFunc, data: gpointer) [*c]GHook;
pub extern fn g_hook_find_data(hook_list: ?*GHookList, need_valids: gboolean, data: gpointer) [*c]GHook;
pub extern fn g_hook_find_func(hook_list: ?*GHookList, need_valids: gboolean, func: gpointer) [*c]GHook;
pub extern fn g_hook_find_func_data(hook_list: ?*GHookList, need_valids: gboolean, func: gpointer, data: gpointer) [*c]GHook;
pub extern fn g_hook_first_valid(hook_list: ?*GHookList, may_be_in_call: gboolean) [*c]GHook;
pub extern fn g_hook_next_valid(hook_list: ?*GHookList, hook: [*c]GHook, may_be_in_call: gboolean) [*c]GHook;
pub extern fn g_hook_compare_ids(new_hook: [*c]GHook, sibling: [*c]GHook) gint;
pub extern fn g_hook_list_invoke(hook_list: ?*GHookList, may_recurse: gboolean) void;
pub extern fn g_hook_list_invoke_check(hook_list: ?*GHookList, may_recurse: gboolean) void;
pub extern fn g_hook_list_marshal(hook_list: ?*GHookList, may_recurse: gboolean, marshaller: GHookMarshaller, marshal_data: gpointer) void;
pub extern fn g_hook_list_marshal_check(hook_list: ?*GHookList, may_recurse: gboolean, marshaller: GHookCheckMarshaller, marshal_data: gpointer) void;
pub extern fn g_hostname_is_non_ascii(hostname: [*c]const gchar) gboolean;
pub extern fn g_hostname_is_ascii_encoded(hostname: [*c]const gchar) gboolean;
pub extern fn g_hostname_is_ip_address(hostname: [*c]const gchar) gboolean;
pub extern fn g_hostname_to_ascii(hostname: [*c]const gchar) [*c]gchar;
pub extern fn g_hostname_to_unicode(hostname: [*c]const gchar) [*c]gchar;
pub const struct__GPollFD = extern struct {
    fd: gint,
    events: gushort,
    revents: gushort,
};
pub const GPollFD = struct__GPollFD;
pub const GPollFunc = ?fn ([*c]GPollFD, guint, gint) callconv(.C) gint;
pub extern fn g_poll(fds: [*c]GPollFD, nfds: guint, timeout: gint) gint;
pub const GSList = struct__GSList;
pub const struct__GSList = extern struct {
    data: gpointer,
    next: [*c]GSList,
};
pub extern fn g_slist_alloc() [*c]GSList;
pub extern fn g_slist_free(list: [*c]GSList) void;
pub extern fn g_slist_free_1(list: [*c]GSList) void;
pub extern fn g_slist_free_full(list: [*c]GSList, free_func: GDestroyNotify) void;
pub extern fn g_slist_append(list: [*c]GSList, data: gpointer) [*c]GSList;
pub extern fn g_slist_prepend(list: [*c]GSList, data: gpointer) [*c]GSList;
pub extern fn g_slist_insert(list: [*c]GSList, data: gpointer, position: gint) [*c]GSList;
pub extern fn g_slist_insert_sorted(list: [*c]GSList, data: gpointer, func: GCompareFunc) [*c]GSList;
pub extern fn g_slist_insert_sorted_with_data(list: [*c]GSList, data: gpointer, func: GCompareDataFunc, user_data: gpointer) [*c]GSList;
pub extern fn g_slist_insert_before(slist: [*c]GSList, sibling: [*c]GSList, data: gpointer) [*c]GSList;
pub extern fn g_slist_concat(list1: [*c]GSList, list2: [*c]GSList) [*c]GSList;
pub extern fn g_slist_remove(list: [*c]GSList, data: gconstpointer) [*c]GSList;
pub extern fn g_slist_remove_all(list: [*c]GSList, data: gconstpointer) [*c]GSList;
pub extern fn g_slist_remove_link(list: [*c]GSList, link_: [*c]GSList) [*c]GSList;
pub extern fn g_slist_delete_link(list: [*c]GSList, link_: [*c]GSList) [*c]GSList;
pub extern fn g_slist_reverse(list: [*c]GSList) [*c]GSList;
pub extern fn g_slist_copy(list: [*c]GSList) [*c]GSList;
pub extern fn g_slist_copy_deep(list: [*c]GSList, func: GCopyFunc, user_data: gpointer) [*c]GSList;
pub extern fn g_slist_nth(list: [*c]GSList, n: guint) [*c]GSList;
pub extern fn g_slist_find(list: [*c]GSList, data: gconstpointer) [*c]GSList;
pub extern fn g_slist_find_custom(list: [*c]GSList, data: gconstpointer, func: GCompareFunc) [*c]GSList;
pub extern fn g_slist_position(list: [*c]GSList, llink: [*c]GSList) gint;
pub extern fn g_slist_index(list: [*c]GSList, data: gconstpointer) gint;
pub extern fn g_slist_last(list: [*c]GSList) [*c]GSList;
pub extern fn g_slist_length(list: [*c]GSList) guint;
pub extern fn g_slist_foreach(list: [*c]GSList, func: GFunc, user_data: gpointer) void;
pub extern fn g_slist_sort(list: [*c]GSList, compare_func: GCompareFunc) [*c]GSList;
pub extern fn g_slist_sort_with_data(list: [*c]GSList, compare_func: GCompareDataFunc, user_data: gpointer) [*c]GSList;
pub extern fn g_slist_nth_data(list: [*c]GSList, n: guint) gpointer;
pub extern fn g_clear_slist(slist_ptr: [*c][*c]GSList, destroy: GDestroyNotify) void;
pub const G_IO_IN: c_int = 1;
pub const G_IO_OUT: c_int = 4;
pub const G_IO_PRI: c_int = 2;
pub const G_IO_ERR: c_int = 8;
pub const G_IO_HUP: c_int = 16;
pub const G_IO_NVAL: c_int = 32;
pub const GIOCondition = c_uint;
pub const G_MAIN_CONTEXT_FLAGS_NONE: c_int = 0;
pub const G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING: c_int = 1;
pub const GMainContextFlags = c_uint;
pub const struct__GMainContext = opaque {};
pub const GMainContext = struct__GMainContext;
pub const struct__GMainLoop = opaque {};
pub const GMainLoop = struct__GMainLoop;
pub const GSource = struct__GSource;
pub const GSourceFunc = ?fn (gpointer) callconv(.C) gboolean;
pub const struct__GSourceCallbackFuncs = extern struct {
    ref: ?fn (gpointer) callconv(.C) void,
    unref: ?fn (gpointer) callconv(.C) void,
    get: ?fn (gpointer, [*c]GSource, [*c]GSourceFunc, [*c]gpointer) callconv(.C) void,
};
pub const GSourceCallbackFuncs = struct__GSourceCallbackFuncs;
pub const GSourceDummyMarshal = ?fn () callconv(.C) void;
pub const struct__GSourceFuncs = extern struct {
    prepare: ?fn ([*c]GSource, [*c]gint) callconv(.C) gboolean,
    check: ?fn ([*c]GSource) callconv(.C) gboolean,
    dispatch: ?fn ([*c]GSource, GSourceFunc, gpointer) callconv(.C) gboolean,
    finalize: ?fn ([*c]GSource) callconv(.C) void,
    closure_callback: GSourceFunc,
    closure_marshal: GSourceDummyMarshal,
};
pub const GSourceFuncs = struct__GSourceFuncs;
pub const struct__GSourcePrivate = opaque {};
pub const GSourcePrivate = struct__GSourcePrivate;
pub const struct__GSource = extern struct {
    callback_data: gpointer,
    callback_funcs: [*c]GSourceCallbackFuncs,
    source_funcs: [*c]const GSourceFuncs,
    ref_count: guint,
    context: ?*GMainContext,
    priority: gint,
    flags: guint,
    source_id: guint,
    poll_fds: [*c]GSList,
    prev: [*c]GSource,
    next: [*c]GSource,
    name: [*c]u8,
    priv: ?*GSourcePrivate,
};
pub const GChildWatchFunc = ?fn (GPid, gint, gpointer) callconv(.C) void;
pub const GSourceDisposeFunc = ?fn ([*c]GSource) callconv(.C) void;
pub extern fn g_main_context_new() ?*GMainContext;
pub extern fn g_main_context_new_with_flags(flags: GMainContextFlags) ?*GMainContext;
pub extern fn g_main_context_ref(context: ?*GMainContext) ?*GMainContext;
pub extern fn g_main_context_unref(context: ?*GMainContext) void;
pub extern fn g_main_context_default() ?*GMainContext;
pub extern fn g_main_context_iteration(context: ?*GMainContext, may_block: gboolean) gboolean;
pub extern fn g_main_context_pending(context: ?*GMainContext) gboolean;
pub extern fn g_main_context_find_source_by_id(context: ?*GMainContext, source_id: guint) [*c]GSource;
pub extern fn g_main_context_find_source_by_user_data(context: ?*GMainContext, user_data: gpointer) [*c]GSource;
pub extern fn g_main_context_find_source_by_funcs_user_data(context: ?*GMainContext, funcs: [*c]GSourceFuncs, user_data: gpointer) [*c]GSource;
pub extern fn g_main_context_wakeup(context: ?*GMainContext) void;
pub extern fn g_main_context_acquire(context: ?*GMainContext) gboolean;
pub extern fn g_main_context_release(context: ?*GMainContext) void;
pub extern fn g_main_context_is_owner(context: ?*GMainContext) gboolean;
pub extern fn g_main_context_wait(context: ?*GMainContext, cond: [*c]GCond, mutex: [*c]GMutex) gboolean;
pub extern fn g_main_context_prepare(context: ?*GMainContext, priority: [*c]gint) gboolean;
pub extern fn g_main_context_query(context: ?*GMainContext, max_priority: gint, timeout_: [*c]gint, fds: [*c]GPollFD, n_fds: gint) gint;
pub extern fn g_main_context_check(context: ?*GMainContext, max_priority: gint, fds: [*c]GPollFD, n_fds: gint) gboolean;
pub extern fn g_main_context_dispatch(context: ?*GMainContext) void;
pub extern fn g_main_context_set_poll_func(context: ?*GMainContext, func: GPollFunc) void;
pub extern fn g_main_context_get_poll_func(context: ?*GMainContext) GPollFunc;
pub extern fn g_main_context_add_poll(context: ?*GMainContext, fd: [*c]GPollFD, priority: gint) void;
pub extern fn g_main_context_remove_poll(context: ?*GMainContext, fd: [*c]GPollFD) void;
pub extern fn g_main_depth() gint;
pub extern fn g_main_current_source() [*c]GSource;
pub extern fn g_main_context_push_thread_default(context: ?*GMainContext) void;
pub extern fn g_main_context_pop_thread_default(context: ?*GMainContext) void;
pub extern fn g_main_context_get_thread_default() ?*GMainContext;
pub extern fn g_main_context_ref_thread_default() ?*GMainContext;
pub const GMainContextPusher = anyopaque;
pub fn g_main_context_pusher_new(arg_main_context: ?*GMainContext) callconv(.C) ?*GMainContextPusher {
    var main_context = arg_main_context;
    g_main_context_push_thread_default(main_context);
    return @ptrCast(?*GMainContextPusher, main_context);
}
pub fn g_main_context_pusher_free(arg_pusher: ?*GMainContextPusher) callconv(.C) void {
    var pusher = arg_pusher;
    g_main_context_pop_thread_default(@ptrCast(?*GMainContext, pusher));
}
pub extern fn g_main_loop_new(context: ?*GMainContext, is_running: gboolean) ?*GMainLoop;
pub extern fn g_main_loop_run(loop: ?*GMainLoop) void;
pub extern fn g_main_loop_quit(loop: ?*GMainLoop) void;
pub extern fn g_main_loop_ref(loop: ?*GMainLoop) ?*GMainLoop;
pub extern fn g_main_loop_unref(loop: ?*GMainLoop) void;
pub extern fn g_main_loop_is_running(loop: ?*GMainLoop) gboolean;
pub extern fn g_main_loop_get_context(loop: ?*GMainLoop) ?*GMainContext;
pub extern fn g_source_new(source_funcs: [*c]GSourceFuncs, struct_size: guint) [*c]GSource;
pub extern fn g_source_set_dispose_function(source: [*c]GSource, dispose: GSourceDisposeFunc) void;
pub extern fn g_source_ref(source: [*c]GSource) [*c]GSource;
pub extern fn g_source_unref(source: [*c]GSource) void;
pub extern fn g_source_attach(source: [*c]GSource, context: ?*GMainContext) guint;
pub extern fn g_source_destroy(source: [*c]GSource) void;
pub extern fn g_source_set_priority(source: [*c]GSource, priority: gint) void;
pub extern fn g_source_get_priority(source: [*c]GSource) gint;
pub extern fn g_source_set_can_recurse(source: [*c]GSource, can_recurse: gboolean) void;
pub extern fn g_source_get_can_recurse(source: [*c]GSource) gboolean;
pub extern fn g_source_get_id(source: [*c]GSource) guint;
pub extern fn g_source_get_context(source: [*c]GSource) ?*GMainContext;
pub extern fn g_source_set_callback(source: [*c]GSource, func: GSourceFunc, data: gpointer, notify: GDestroyNotify) void;
pub extern fn g_source_set_funcs(source: [*c]GSource, funcs: [*c]GSourceFuncs) void;
pub extern fn g_source_is_destroyed(source: [*c]GSource) gboolean;
pub extern fn g_source_set_name(source: [*c]GSource, name: [*c]const u8) void;
pub extern fn g_source_set_static_name(source: [*c]GSource, name: [*c]const u8) void;
pub extern fn g_source_get_name(source: [*c]GSource) [*c]const u8;
pub extern fn g_source_set_name_by_id(tag: guint, name: [*c]const u8) void;
pub extern fn g_source_set_ready_time(source: [*c]GSource, ready_time: gint64) void;
pub extern fn g_source_get_ready_time(source: [*c]GSource) gint64;
pub extern fn g_source_add_unix_fd(source: [*c]GSource, fd: gint, events: GIOCondition) gpointer;
pub extern fn g_source_modify_unix_fd(source: [*c]GSource, tag: gpointer, new_events: GIOCondition) void;
pub extern fn g_source_remove_unix_fd(source: [*c]GSource, tag: gpointer) void;
pub extern fn g_source_query_unix_fd(source: [*c]GSource, tag: gpointer) GIOCondition;
pub extern fn g_source_set_callback_indirect(source: [*c]GSource, callback_data: gpointer, callback_funcs: [*c]GSourceCallbackFuncs) void;
pub extern fn g_source_add_poll(source: [*c]GSource, fd: [*c]GPollFD) void;
pub extern fn g_source_remove_poll(source: [*c]GSource, fd: [*c]GPollFD) void;
pub extern fn g_source_add_child_source(source: [*c]GSource, child_source: [*c]GSource) void;
pub extern fn g_source_remove_child_source(source: [*c]GSource, child_source: [*c]GSource) void;
pub extern fn g_source_get_current_time(source: [*c]GSource, timeval: [*c]GTimeVal) void;
pub extern fn g_source_get_time(source: [*c]GSource) gint64;
pub extern fn g_idle_source_new() [*c]GSource;
pub extern fn g_child_watch_source_new(pid: GPid) [*c]GSource;
pub extern fn g_timeout_source_new(interval: guint) [*c]GSource;
pub extern fn g_timeout_source_new_seconds(interval: guint) [*c]GSource;
pub extern fn g_get_current_time(result: [*c]GTimeVal) void;
pub extern fn g_get_monotonic_time() gint64;
pub extern fn g_get_real_time() gint64;
pub extern fn g_source_remove(tag: guint) gboolean;
pub extern fn g_source_remove_by_user_data(user_data: gpointer) gboolean;
pub extern fn g_source_remove_by_funcs_user_data(funcs: [*c]GSourceFuncs, user_data: gpointer) gboolean;
pub const GClearHandleFunc = ?fn (guint) callconv(.C) void;
pub extern fn g_clear_handle_id(tag_ptr: [*c]guint, clear_func: GClearHandleFunc) void;
pub extern fn g_timeout_add_full(priority: gint, interval: guint, function: GSourceFunc, data: gpointer, notify: GDestroyNotify) guint;
pub extern fn g_timeout_add(interval: guint, function: GSourceFunc, data: gpointer) guint;
pub extern fn g_timeout_add_seconds_full(priority: gint, interval: guint, function: GSourceFunc, data: gpointer, notify: GDestroyNotify) guint;
pub extern fn g_timeout_add_seconds(interval: guint, function: GSourceFunc, data: gpointer) guint;
pub extern fn g_child_watch_add_full(priority: gint, pid: GPid, function: GChildWatchFunc, data: gpointer, notify: GDestroyNotify) guint;
pub extern fn g_child_watch_add(pid: GPid, function: GChildWatchFunc, data: gpointer) guint;
pub extern fn g_idle_add(function: GSourceFunc, data: gpointer) guint;
pub extern fn g_idle_add_full(priority: gint, function: GSourceFunc, data: gpointer, notify: GDestroyNotify) guint;
pub extern fn g_idle_remove_by_data(data: gpointer) gboolean;
pub extern fn g_main_context_invoke_full(context: ?*GMainContext, priority: gint, function: GSourceFunc, data: gpointer, notify: GDestroyNotify) void;
pub extern fn g_main_context_invoke(context: ?*GMainContext, function: GSourceFunc, data: gpointer) void;
pub fn g_steal_fd(arg_fd_ptr: [*c]c_int) callconv(.C) c_int {
    var fd_ptr = arg_fd_ptr;
    var fd: c_int = fd_ptr.*;
    fd_ptr.* = -@as(c_int, 1);
    return fd;
}
pub extern var g_timeout_funcs: GSourceFuncs;
pub extern var g_child_watch_funcs: GSourceFuncs;
pub extern var g_idle_funcs: GSourceFuncs;
pub extern var g_unix_signal_funcs: GSourceFuncs;
pub extern var g_unix_fd_source_funcs: GSourceFuncs;
pub const gunichar = guint32;
pub const gunichar2 = guint16;
pub const G_UNICODE_CONTROL: c_int = 0;
pub const G_UNICODE_FORMAT: c_int = 1;
pub const G_UNICODE_UNASSIGNED: c_int = 2;
pub const G_UNICODE_PRIVATE_USE: c_int = 3;
pub const G_UNICODE_SURROGATE: c_int = 4;
pub const G_UNICODE_LOWERCASE_LETTER: c_int = 5;
pub const G_UNICODE_MODIFIER_LETTER: c_int = 6;
pub const G_UNICODE_OTHER_LETTER: c_int = 7;
pub const G_UNICODE_TITLECASE_LETTER: c_int = 8;
pub const G_UNICODE_UPPERCASE_LETTER: c_int = 9;
pub const G_UNICODE_SPACING_MARK: c_int = 10;
pub const G_UNICODE_ENCLOSING_MARK: c_int = 11;
pub const G_UNICODE_NON_SPACING_MARK: c_int = 12;
pub const G_UNICODE_DECIMAL_NUMBER: c_int = 13;
pub const G_UNICODE_LETTER_NUMBER: c_int = 14;
pub const G_UNICODE_OTHER_NUMBER: c_int = 15;
pub const G_UNICODE_CONNECT_PUNCTUATION: c_int = 16;
pub const G_UNICODE_DASH_PUNCTUATION: c_int = 17;
pub const G_UNICODE_CLOSE_PUNCTUATION: c_int = 18;
pub const G_UNICODE_FINAL_PUNCTUATION: c_int = 19;
pub const G_UNICODE_INITIAL_PUNCTUATION: c_int = 20;
pub const G_UNICODE_OTHER_PUNCTUATION: c_int = 21;
pub const G_UNICODE_OPEN_PUNCTUATION: c_int = 22;
pub const G_UNICODE_CURRENCY_SYMBOL: c_int = 23;
pub const G_UNICODE_MODIFIER_SYMBOL: c_int = 24;
pub const G_UNICODE_MATH_SYMBOL: c_int = 25;
pub const G_UNICODE_OTHER_SYMBOL: c_int = 26;
pub const G_UNICODE_LINE_SEPARATOR: c_int = 27;
pub const G_UNICODE_PARAGRAPH_SEPARATOR: c_int = 28;
pub const G_UNICODE_SPACE_SEPARATOR: c_int = 29;
pub const GUnicodeType = c_uint;
pub const G_UNICODE_BREAK_MANDATORY: c_int = 0;
pub const G_UNICODE_BREAK_CARRIAGE_RETURN: c_int = 1;
pub const G_UNICODE_BREAK_LINE_FEED: c_int = 2;
pub const G_UNICODE_BREAK_COMBINING_MARK: c_int = 3;
pub const G_UNICODE_BREAK_SURROGATE: c_int = 4;
pub const G_UNICODE_BREAK_ZERO_WIDTH_SPACE: c_int = 5;
pub const G_UNICODE_BREAK_INSEPARABLE: c_int = 6;
pub const G_UNICODE_BREAK_NON_BREAKING_GLUE: c_int = 7;
pub const G_UNICODE_BREAK_CONTINGENT: c_int = 8;
pub const G_UNICODE_BREAK_SPACE: c_int = 9;
pub const G_UNICODE_BREAK_AFTER: c_int = 10;
pub const G_UNICODE_BREAK_BEFORE: c_int = 11;
pub const G_UNICODE_BREAK_BEFORE_AND_AFTER: c_int = 12;
pub const G_UNICODE_BREAK_HYPHEN: c_int = 13;
pub const G_UNICODE_BREAK_NON_STARTER: c_int = 14;
pub const G_UNICODE_BREAK_OPEN_PUNCTUATION: c_int = 15;
pub const G_UNICODE_BREAK_CLOSE_PUNCTUATION: c_int = 16;
pub const G_UNICODE_BREAK_QUOTATION: c_int = 17;
pub const G_UNICODE_BREAK_EXCLAMATION: c_int = 18;
pub const G_UNICODE_BREAK_IDEOGRAPHIC: c_int = 19;
pub const G_UNICODE_BREAK_NUMERIC: c_int = 20;
pub const G_UNICODE_BREAK_INFIX_SEPARATOR: c_int = 21;
pub const G_UNICODE_BREAK_SYMBOL: c_int = 22;
pub const G_UNICODE_BREAK_ALPHABETIC: c_int = 23;
pub const G_UNICODE_BREAK_PREFIX: c_int = 24;
pub const G_UNICODE_BREAK_POSTFIX: c_int = 25;
pub const G_UNICODE_BREAK_COMPLEX_CONTEXT: c_int = 26;
pub const G_UNICODE_BREAK_AMBIGUOUS: c_int = 27;
pub const G_UNICODE_BREAK_UNKNOWN: c_int = 28;
pub const G_UNICODE_BREAK_NEXT_LINE: c_int = 29;
pub const G_UNICODE_BREAK_WORD_JOINER: c_int = 30;
pub const G_UNICODE_BREAK_HANGUL_L_JAMO: c_int = 31;
pub const G_UNICODE_BREAK_HANGUL_V_JAMO: c_int = 32;
pub const G_UNICODE_BREAK_HANGUL_T_JAMO: c_int = 33;
pub const G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: c_int = 34;
pub const G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: c_int = 35;
pub const G_UNICODE_BREAK_CLOSE_PARANTHESIS: c_int = 36;
pub const G_UNICODE_BREAK_CLOSE_PARENTHESIS: c_int = 36;
pub const G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: c_int = 37;
pub const G_UNICODE_BREAK_HEBREW_LETTER: c_int = 38;
pub const G_UNICODE_BREAK_REGIONAL_INDICATOR: c_int = 39;
pub const G_UNICODE_BREAK_EMOJI_BASE: c_int = 40;
pub const G_UNICODE_BREAK_EMOJI_MODIFIER: c_int = 41;
pub const G_UNICODE_BREAK_ZERO_WIDTH_JOINER: c_int = 42;
pub const GUnicodeBreakType = c_uint;
pub const G_UNICODE_SCRIPT_INVALID_CODE: c_int = -1;
pub const G_UNICODE_SCRIPT_COMMON: c_int = 0;
pub const G_UNICODE_SCRIPT_INHERITED: c_int = 1;
pub const G_UNICODE_SCRIPT_ARABIC: c_int = 2;
pub const G_UNICODE_SCRIPT_ARMENIAN: c_int = 3;
pub const G_UNICODE_SCRIPT_BENGALI: c_int = 4;
pub const G_UNICODE_SCRIPT_BOPOMOFO: c_int = 5;
pub const G_UNICODE_SCRIPT_CHEROKEE: c_int = 6;
pub const G_UNICODE_SCRIPT_COPTIC: c_int = 7;
pub const G_UNICODE_SCRIPT_CYRILLIC: c_int = 8;
pub const G_UNICODE_SCRIPT_DESERET: c_int = 9;
pub const G_UNICODE_SCRIPT_DEVANAGARI: c_int = 10;
pub const G_UNICODE_SCRIPT_ETHIOPIC: c_int = 11;
pub const G_UNICODE_SCRIPT_GEORGIAN: c_int = 12;
pub const G_UNICODE_SCRIPT_GOTHIC: c_int = 13;
pub const G_UNICODE_SCRIPT_GREEK: c_int = 14;
pub const G_UNICODE_SCRIPT_GUJARATI: c_int = 15;
pub const G_UNICODE_SCRIPT_GURMUKHI: c_int = 16;
pub const G_UNICODE_SCRIPT_HAN: c_int = 17;
pub const G_UNICODE_SCRIPT_HANGUL: c_int = 18;
pub const G_UNICODE_SCRIPT_HEBREW: c_int = 19;
pub const G_UNICODE_SCRIPT_HIRAGANA: c_int = 20;
pub const G_UNICODE_SCRIPT_KANNADA: c_int = 21;
pub const G_UNICODE_SCRIPT_KATAKANA: c_int = 22;
pub const G_UNICODE_SCRIPT_KHMER: c_int = 23;
pub const G_UNICODE_SCRIPT_LAO: c_int = 24;
pub const G_UNICODE_SCRIPT_LATIN: c_int = 25;
pub const G_UNICODE_SCRIPT_MALAYALAM: c_int = 26;
pub const G_UNICODE_SCRIPT_MONGOLIAN: c_int = 27;
pub const G_UNICODE_SCRIPT_MYANMAR: c_int = 28;
pub const G_UNICODE_SCRIPT_OGHAM: c_int = 29;
pub const G_UNICODE_SCRIPT_OLD_ITALIC: c_int = 30;
pub const G_UNICODE_SCRIPT_ORIYA: c_int = 31;
pub const G_UNICODE_SCRIPT_RUNIC: c_int = 32;
pub const G_UNICODE_SCRIPT_SINHALA: c_int = 33;
pub const G_UNICODE_SCRIPT_SYRIAC: c_int = 34;
pub const G_UNICODE_SCRIPT_TAMIL: c_int = 35;
pub const G_UNICODE_SCRIPT_TELUGU: c_int = 36;
pub const G_UNICODE_SCRIPT_THAANA: c_int = 37;
pub const G_UNICODE_SCRIPT_THAI: c_int = 38;
pub const G_UNICODE_SCRIPT_TIBETAN: c_int = 39;
pub const G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL: c_int = 40;
pub const G_UNICODE_SCRIPT_YI: c_int = 41;
pub const G_UNICODE_SCRIPT_TAGALOG: c_int = 42;
pub const G_UNICODE_SCRIPT_HANUNOO: c_int = 43;
pub const G_UNICODE_SCRIPT_BUHID: c_int = 44;
pub const G_UNICODE_SCRIPT_TAGBANWA: c_int = 45;
pub const G_UNICODE_SCRIPT_BRAILLE: c_int = 46;
pub const G_UNICODE_SCRIPT_CYPRIOT: c_int = 47;
pub const G_UNICODE_SCRIPT_LIMBU: c_int = 48;
pub const G_UNICODE_SCRIPT_OSMANYA: c_int = 49;
pub const G_UNICODE_SCRIPT_SHAVIAN: c_int = 50;
pub const G_UNICODE_SCRIPT_LINEAR_B: c_int = 51;
pub const G_UNICODE_SCRIPT_TAI_LE: c_int = 52;
pub const G_UNICODE_SCRIPT_UGARITIC: c_int = 53;
pub const G_UNICODE_SCRIPT_NEW_TAI_LUE: c_int = 54;
pub const G_UNICODE_SCRIPT_BUGINESE: c_int = 55;
pub const G_UNICODE_SCRIPT_GLAGOLITIC: c_int = 56;
pub const G_UNICODE_SCRIPT_TIFINAGH: c_int = 57;
pub const G_UNICODE_SCRIPT_SYLOTI_NAGRI: c_int = 58;
pub const G_UNICODE_SCRIPT_OLD_PERSIAN: c_int = 59;
pub const G_UNICODE_SCRIPT_KHAROSHTHI: c_int = 60;
pub const G_UNICODE_SCRIPT_UNKNOWN: c_int = 61;
pub const G_UNICODE_SCRIPT_BALINESE: c_int = 62;
pub const G_UNICODE_SCRIPT_CUNEIFORM: c_int = 63;
pub const G_UNICODE_SCRIPT_PHOENICIAN: c_int = 64;
pub const G_UNICODE_SCRIPT_PHAGS_PA: c_int = 65;
pub const G_UNICODE_SCRIPT_NKO: c_int = 66;
pub const G_UNICODE_SCRIPT_KAYAH_LI: c_int = 67;
pub const G_UNICODE_SCRIPT_LEPCHA: c_int = 68;
pub const G_UNICODE_SCRIPT_REJANG: c_int = 69;
pub const G_UNICODE_SCRIPT_SUNDANESE: c_int = 70;
pub const G_UNICODE_SCRIPT_SAURASHTRA: c_int = 71;
pub const G_UNICODE_SCRIPT_CHAM: c_int = 72;
pub const G_UNICODE_SCRIPT_OL_CHIKI: c_int = 73;
pub const G_UNICODE_SCRIPT_VAI: c_int = 74;
pub const G_UNICODE_SCRIPT_CARIAN: c_int = 75;
pub const G_UNICODE_SCRIPT_LYCIAN: c_int = 76;
pub const G_UNICODE_SCRIPT_LYDIAN: c_int = 77;
pub const G_UNICODE_SCRIPT_AVESTAN: c_int = 78;
pub const G_UNICODE_SCRIPT_BAMUM: c_int = 79;
pub const G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS: c_int = 80;
pub const G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC: c_int = 81;
pub const G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI: c_int = 82;
pub const G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN: c_int = 83;
pub const G_UNICODE_SCRIPT_JAVANESE: c_int = 84;
pub const G_UNICODE_SCRIPT_KAITHI: c_int = 85;
pub const G_UNICODE_SCRIPT_LISU: c_int = 86;
pub const G_UNICODE_SCRIPT_MEETEI_MAYEK: c_int = 87;
pub const G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN: c_int = 88;
pub const G_UNICODE_SCRIPT_OLD_TURKIC: c_int = 89;
pub const G_UNICODE_SCRIPT_SAMARITAN: c_int = 90;
pub const G_UNICODE_SCRIPT_TAI_THAM: c_int = 91;
pub const G_UNICODE_SCRIPT_TAI_VIET: c_int = 92;
pub const G_UNICODE_SCRIPT_BATAK: c_int = 93;
pub const G_UNICODE_SCRIPT_BRAHMI: c_int = 94;
pub const G_UNICODE_SCRIPT_MANDAIC: c_int = 95;
pub const G_UNICODE_SCRIPT_CHAKMA: c_int = 96;
pub const G_UNICODE_SCRIPT_MEROITIC_CURSIVE: c_int = 97;
pub const G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: c_int = 98;
pub const G_UNICODE_SCRIPT_MIAO: c_int = 99;
pub const G_UNICODE_SCRIPT_SHARADA: c_int = 100;
pub const G_UNICODE_SCRIPT_SORA_SOMPENG: c_int = 101;
pub const G_UNICODE_SCRIPT_TAKRI: c_int = 102;
pub const G_UNICODE_SCRIPT_BASSA_VAH: c_int = 103;
pub const G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN: c_int = 104;
pub const G_UNICODE_SCRIPT_DUPLOYAN: c_int = 105;
pub const G_UNICODE_SCRIPT_ELBASAN: c_int = 106;
pub const G_UNICODE_SCRIPT_GRANTHA: c_int = 107;
pub const G_UNICODE_SCRIPT_KHOJKI: c_int = 108;
pub const G_UNICODE_SCRIPT_KHUDAWADI: c_int = 109;
pub const G_UNICODE_SCRIPT_LINEAR_A: c_int = 110;
pub const G_UNICODE_SCRIPT_MAHAJANI: c_int = 111;
pub const G_UNICODE_SCRIPT_MANICHAEAN: c_int = 112;
pub const G_UNICODE_SCRIPT_MENDE_KIKAKUI: c_int = 113;
pub const G_UNICODE_SCRIPT_MODI: c_int = 114;
pub const G_UNICODE_SCRIPT_MRO: c_int = 115;
pub const G_UNICODE_SCRIPT_NABATAEAN: c_int = 116;
pub const G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN: c_int = 117;
pub const G_UNICODE_SCRIPT_OLD_PERMIC: c_int = 118;
pub const G_UNICODE_SCRIPT_PAHAWH_HMONG: c_int = 119;
pub const G_UNICODE_SCRIPT_PALMYRENE: c_int = 120;
pub const G_UNICODE_SCRIPT_PAU_CIN_HAU: c_int = 121;
pub const G_UNICODE_SCRIPT_PSALTER_PAHLAVI: c_int = 122;
pub const G_UNICODE_SCRIPT_SIDDHAM: c_int = 123;
pub const G_UNICODE_SCRIPT_TIRHUTA: c_int = 124;
pub const G_UNICODE_SCRIPT_WARANG_CITI: c_int = 125;
pub const G_UNICODE_SCRIPT_AHOM: c_int = 126;
pub const G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: c_int = 127;
pub const G_UNICODE_SCRIPT_HATRAN: c_int = 128;
pub const G_UNICODE_SCRIPT_MULTANI: c_int = 129;
pub const G_UNICODE_SCRIPT_OLD_HUNGARIAN: c_int = 130;
pub const G_UNICODE_SCRIPT_SIGNWRITING: c_int = 131;
pub const G_UNICODE_SCRIPT_ADLAM: c_int = 132;
pub const G_UNICODE_SCRIPT_BHAIKSUKI: c_int = 133;
pub const G_UNICODE_SCRIPT_MARCHEN: c_int = 134;
pub const G_UNICODE_SCRIPT_NEWA: c_int = 135;
pub const G_UNICODE_SCRIPT_OSAGE: c_int = 136;
pub const G_UNICODE_SCRIPT_TANGUT: c_int = 137;
pub const G_UNICODE_SCRIPT_MASARAM_GONDI: c_int = 138;
pub const G_UNICODE_SCRIPT_NUSHU: c_int = 139;
pub const G_UNICODE_SCRIPT_SOYOMBO: c_int = 140;
pub const G_UNICODE_SCRIPT_ZANABAZAR_SQUARE: c_int = 141;
pub const G_UNICODE_SCRIPT_DOGRA: c_int = 142;
pub const G_UNICODE_SCRIPT_GUNJALA_GONDI: c_int = 143;
pub const G_UNICODE_SCRIPT_HANIFI_ROHINGYA: c_int = 144;
pub const G_UNICODE_SCRIPT_MAKASAR: c_int = 145;
pub const G_UNICODE_SCRIPT_MEDEFAIDRIN: c_int = 146;
pub const G_UNICODE_SCRIPT_OLD_SOGDIAN: c_int = 147;
pub const G_UNICODE_SCRIPT_SOGDIAN: c_int = 148;
pub const G_UNICODE_SCRIPT_ELYMAIC: c_int = 149;
pub const G_UNICODE_SCRIPT_NANDINAGARI: c_int = 150;
pub const G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG: c_int = 151;
pub const G_UNICODE_SCRIPT_WANCHO: c_int = 152;
pub const G_UNICODE_SCRIPT_CHORASMIAN: c_int = 153;
pub const G_UNICODE_SCRIPT_DIVES_AKURU: c_int = 154;
pub const G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT: c_int = 155;
pub const G_UNICODE_SCRIPT_YEZIDI: c_int = 156;
pub const G_UNICODE_SCRIPT_CYPRO_MINOAN: c_int = 157;
pub const G_UNICODE_SCRIPT_OLD_UYGHUR: c_int = 158;
pub const G_UNICODE_SCRIPT_TANGSA: c_int = 159;
pub const G_UNICODE_SCRIPT_TOTO: c_int = 160;
pub const G_UNICODE_SCRIPT_VITHKUQI: c_int = 161;
pub const G_UNICODE_SCRIPT_MATH: c_int = 162;
pub const GUnicodeScript = c_int;
pub extern fn g_unicode_script_to_iso15924(script: GUnicodeScript) guint32;
pub extern fn g_unicode_script_from_iso15924(iso15924: guint32) GUnicodeScript;
pub extern fn g_unichar_isalnum(c: gunichar) gboolean;
pub extern fn g_unichar_isalpha(c: gunichar) gboolean;
pub extern fn g_unichar_iscntrl(c: gunichar) gboolean;
pub extern fn g_unichar_isdigit(c: gunichar) gboolean;
pub extern fn g_unichar_isgraph(c: gunichar) gboolean;
pub extern fn g_unichar_islower(c: gunichar) gboolean;
pub extern fn g_unichar_isprint(c: gunichar) gboolean;
pub extern fn g_unichar_ispunct(c: gunichar) gboolean;
pub extern fn g_unichar_isspace(c: gunichar) gboolean;
pub extern fn g_unichar_isupper(c: gunichar) gboolean;
pub extern fn g_unichar_isxdigit(c: gunichar) gboolean;
pub extern fn g_unichar_istitle(c: gunichar) gboolean;
pub extern fn g_unichar_isdefined(c: gunichar) gboolean;
pub extern fn g_unichar_iswide(c: gunichar) gboolean;
pub extern fn g_unichar_iswide_cjk(c: gunichar) gboolean;
pub extern fn g_unichar_iszerowidth(c: gunichar) gboolean;
pub extern fn g_unichar_ismark(c: gunichar) gboolean;
pub extern fn g_unichar_toupper(c: gunichar) gunichar;
pub extern fn g_unichar_tolower(c: gunichar) gunichar;
pub extern fn g_unichar_totitle(c: gunichar) gunichar;
pub extern fn g_unichar_digit_value(c: gunichar) gint;
pub extern fn g_unichar_xdigit_value(c: gunichar) gint;
pub extern fn g_unichar_type(c: gunichar) GUnicodeType;
pub extern fn g_unichar_break_type(c: gunichar) GUnicodeBreakType;
pub extern fn g_unichar_combining_class(uc: gunichar) gint;
pub extern fn g_unichar_get_mirror_char(ch: gunichar, mirrored_ch: [*c]gunichar) gboolean;
pub extern fn g_unichar_get_script(ch: gunichar) GUnicodeScript;
pub extern fn g_unichar_validate(ch: gunichar) gboolean;
pub extern fn g_unichar_compose(a: gunichar, b: gunichar, ch: [*c]gunichar) gboolean;
pub extern fn g_unichar_decompose(ch: gunichar, a: [*c]gunichar, b: [*c]gunichar) gboolean;
pub extern fn g_unichar_fully_decompose(ch: gunichar, compat: gboolean, result: [*c]gunichar, result_len: gsize) gsize;
pub extern fn g_unicode_canonical_ordering(string: [*c]gunichar, len: gsize) void;
pub extern fn g_unicode_canonical_decomposition(ch: gunichar, result_len: [*c]gsize) [*c]gunichar;
pub extern const g_utf8_skip: [*c]const gchar;
pub extern fn g_utf8_get_char(p: [*c]const gchar) gunichar;
pub extern fn g_utf8_get_char_validated(p: [*c]const gchar, max_len: gssize) gunichar;
pub extern fn g_utf8_offset_to_pointer(str: [*c]const gchar, offset: glong) [*c]gchar;
pub extern fn g_utf8_pointer_to_offset(str: [*c]const gchar, pos: [*c]const gchar) glong;
pub extern fn g_utf8_prev_char(p: [*c]const gchar) [*c]gchar;
pub extern fn g_utf8_find_next_char(p: [*c]const gchar, end: [*c]const gchar) [*c]gchar;
pub extern fn g_utf8_find_prev_char(str: [*c]const gchar, p: [*c]const gchar) [*c]gchar;
pub extern fn g_utf8_strlen(p: [*c]const gchar, max: gssize) glong;
pub extern fn g_utf8_substring(str: [*c]const gchar, start_pos: glong, end_pos: glong) [*c]gchar;
pub extern fn g_utf8_strncpy(dest: [*c]gchar, src: [*c]const gchar, n: gsize) [*c]gchar;
pub extern fn g_utf8_strchr(p: [*c]const gchar, len: gssize, c: gunichar) [*c]gchar;
pub extern fn g_utf8_strrchr(p: [*c]const gchar, len: gssize, c: gunichar) [*c]gchar;
pub extern fn g_utf8_strreverse(str: [*c]const gchar, len: gssize) [*c]gchar;
pub extern fn g_utf8_to_utf16(str: [*c]const gchar, len: glong, items_read: [*c]glong, items_written: [*c]glong, @"error": [*c][*c]GError) [*c]gunichar2;
pub extern fn g_utf8_to_ucs4(str: [*c]const gchar, len: glong, items_read: [*c]glong, items_written: [*c]glong, @"error": [*c][*c]GError) [*c]gunichar;
pub extern fn g_utf8_to_ucs4_fast(str: [*c]const gchar, len: glong, items_written: [*c]glong) [*c]gunichar;
pub extern fn g_utf16_to_ucs4(str: [*c]const gunichar2, len: glong, items_read: [*c]glong, items_written: [*c]glong, @"error": [*c][*c]GError) [*c]gunichar;
pub extern fn g_utf16_to_utf8(str: [*c]const gunichar2, len: glong, items_read: [*c]glong, items_written: [*c]glong, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_ucs4_to_utf16(str: [*c]const gunichar, len: glong, items_read: [*c]glong, items_written: [*c]glong, @"error": [*c][*c]GError) [*c]gunichar2;
pub extern fn g_ucs4_to_utf8(str: [*c]const gunichar, len: glong, items_read: [*c]glong, items_written: [*c]glong, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_unichar_to_utf8(c: gunichar, outbuf: [*c]gchar) gint;
pub extern fn g_utf8_validate(str: [*c]const gchar, max_len: gssize, end: [*c][*c]const gchar) gboolean;
pub extern fn g_utf8_validate_len(str: [*c]const gchar, max_len: gsize, end: [*c][*c]const gchar) gboolean;
pub extern fn g_utf8_strup(str: [*c]const gchar, len: gssize) [*c]gchar;
pub extern fn g_utf8_strdown(str: [*c]const gchar, len: gssize) [*c]gchar;
pub extern fn g_utf8_casefold(str: [*c]const gchar, len: gssize) [*c]gchar;
pub const G_NORMALIZE_DEFAULT: c_int = 0;
pub const G_NORMALIZE_NFD: c_int = 0;
pub const G_NORMALIZE_DEFAULT_COMPOSE: c_int = 1;
pub const G_NORMALIZE_NFC: c_int = 1;
pub const G_NORMALIZE_ALL: c_int = 2;
pub const G_NORMALIZE_NFKD: c_int = 2;
pub const G_NORMALIZE_ALL_COMPOSE: c_int = 3;
pub const G_NORMALIZE_NFKC: c_int = 3;
pub const GNormalizeMode = c_uint;
pub extern fn g_utf8_normalize(str: [*c]const gchar, len: gssize, mode: GNormalizeMode) [*c]gchar;
pub extern fn g_utf8_collate(str1: [*c]const gchar, str2: [*c]const gchar) gint;
pub extern fn g_utf8_collate_key(str: [*c]const gchar, len: gssize) [*c]gchar;
pub extern fn g_utf8_collate_key_for_filename(str: [*c]const gchar, len: gssize) [*c]gchar;
pub extern fn g_utf8_make_valid(str: [*c]const gchar, len: gssize) [*c]gchar;
pub const struct__GString = extern struct {
    str: [*c]gchar,
    len: gsize,
    allocated_len: gsize,
};
pub const GString = struct__GString;
pub extern fn g_string_new(init: [*c]const gchar) [*c]GString;
pub extern fn g_string_new_len(init: [*c]const gchar, len: gssize) [*c]GString;
pub extern fn g_string_sized_new(dfl_size: gsize) [*c]GString;
pub extern fn g_string_free(string: [*c]GString, free_segment: gboolean) [*c]gchar;
pub extern fn g_string_free_to_bytes(string: [*c]GString) ?*GBytes;
pub extern fn g_string_equal(v: [*c]const GString, v2: [*c]const GString) gboolean;
pub extern fn g_string_hash(str: [*c]const GString) guint;
pub extern fn g_string_assign(string: [*c]GString, rval: [*c]const gchar) [*c]GString;
pub extern fn g_string_truncate(string: [*c]GString, len: gsize) [*c]GString;
pub extern fn g_string_set_size(string: [*c]GString, len: gsize) [*c]GString;
pub extern fn g_string_insert_len(string: [*c]GString, pos: gssize, val: [*c]const gchar, len: gssize) [*c]GString;
pub extern fn g_string_append(string: [*c]GString, val: [*c]const gchar) [*c]GString;
pub extern fn g_string_append_len(string: [*c]GString, val: [*c]const gchar, len: gssize) [*c]GString;
pub extern fn g_string_append_c(string: [*c]GString, c: gchar) [*c]GString;
pub extern fn g_string_append_unichar(string: [*c]GString, wc: gunichar) [*c]GString;
pub extern fn g_string_prepend(string: [*c]GString, val: [*c]const gchar) [*c]GString;
pub extern fn g_string_prepend_c(string: [*c]GString, c: gchar) [*c]GString;
pub extern fn g_string_prepend_unichar(string: [*c]GString, wc: gunichar) [*c]GString;
pub extern fn g_string_prepend_len(string: [*c]GString, val: [*c]const gchar, len: gssize) [*c]GString;
pub extern fn g_string_insert(string: [*c]GString, pos: gssize, val: [*c]const gchar) [*c]GString;
pub extern fn g_string_insert_c(string: [*c]GString, pos: gssize, c: gchar) [*c]GString;
pub extern fn g_string_insert_unichar(string: [*c]GString, pos: gssize, wc: gunichar) [*c]GString;
pub extern fn g_string_overwrite(string: [*c]GString, pos: gsize, val: [*c]const gchar) [*c]GString;
pub extern fn g_string_overwrite_len(string: [*c]GString, pos: gsize, val: [*c]const gchar, len: gssize) [*c]GString;
pub extern fn g_string_erase(string: [*c]GString, pos: gssize, len: gssize) [*c]GString;
pub extern fn g_string_replace(string: [*c]GString, find: [*c]const gchar, replace: [*c]const gchar, limit: guint) guint;
pub extern fn g_string_ascii_down(string: [*c]GString) [*c]GString;
pub extern fn g_string_ascii_up(string: [*c]GString) [*c]GString;
pub extern fn g_string_vprintf(string: [*c]GString, format: [*c]const gchar, args: va_list) void;
pub extern fn g_string_printf(string: [*c]GString, format: [*c]const gchar, ...) void;
pub extern fn g_string_append_vprintf(string: [*c]GString, format: [*c]const gchar, args: va_list) void;
pub extern fn g_string_append_printf(string: [*c]GString, format: [*c]const gchar, ...) void;
pub extern fn g_string_append_uri_escaped(string: [*c]GString, unescaped: [*c]const gchar, reserved_chars_allowed: [*c]const gchar, allow_utf8: gboolean) [*c]GString;
pub fn g_string_append_c_inline(arg_gstring: [*c]GString, arg_c: gchar) callconv(.C) [*c]GString {
    var gstring = arg_gstring;
    var c = arg_c;
    if ((gstring.*.len +% @bitCast(c_ulong, @as(c_long, @as(c_int, 1)))) < gstring.*.allocated_len) {
        gstring.*.str[blk: {
                const ref = &gstring.*.len;
                const tmp = ref.*;
                ref.* +%= 1;
                break :blk tmp;
            }] = c;
        gstring.*.str[gstring.*.len] = 0;
    } else {
        _ = g_string_insert_c(gstring, @bitCast(gssize, @as(c_long, -@as(c_int, 1))), c);
    }
    return gstring;
}
pub extern fn g_string_down(string: [*c]GString) [*c]GString;
pub extern fn g_string_up(string: [*c]GString) [*c]GString;
pub const GIOChannel = struct__GIOChannel;
pub const struct__GIOFuncs = extern struct {
    io_read: ?fn (?*GIOChannel, [*c]gchar, gsize, [*c]gsize, [*c][*c]GError) callconv(.C) GIOStatus,
    io_write: ?fn (?*GIOChannel, [*c]const gchar, gsize, [*c]gsize, [*c][*c]GError) callconv(.C) GIOStatus,
    io_seek: ?fn (?*GIOChannel, gint64, GSeekType, [*c][*c]GError) callconv(.C) GIOStatus,
    io_close: ?fn (?*GIOChannel, [*c][*c]GError) callconv(.C) GIOStatus,
    io_create_watch: ?fn (?*GIOChannel, GIOCondition) callconv(.C) [*c]GSource,
    io_free: ?fn (?*GIOChannel) callconv(.C) void,
    io_set_flags: ?fn (?*GIOChannel, GIOFlags, [*c][*c]GError) callconv(.C) GIOStatus,
    io_get_flags: ?fn (?*GIOChannel) callconv(.C) GIOFlags,
};
pub const GIOFuncs = struct__GIOFuncs; // /usr/include/glib-2.0/glib/giochannel.h:117:9: warning: struct demoted to opaque type - has bitfield
pub const struct__GIOChannel = opaque {};
pub const G_IO_ERROR_NONE: c_int = 0;
pub const G_IO_ERROR_AGAIN: c_int = 1;
pub const G_IO_ERROR_INVAL: c_int = 2;
pub const G_IO_ERROR_UNKNOWN: c_int = 3;
pub const GIOError = c_uint;
pub const G_IO_CHANNEL_ERROR_FBIG: c_int = 0;
pub const G_IO_CHANNEL_ERROR_INVAL: c_int = 1;
pub const G_IO_CHANNEL_ERROR_IO: c_int = 2;
pub const G_IO_CHANNEL_ERROR_ISDIR: c_int = 3;
pub const G_IO_CHANNEL_ERROR_NOSPC: c_int = 4;
pub const G_IO_CHANNEL_ERROR_NXIO: c_int = 5;
pub const G_IO_CHANNEL_ERROR_OVERFLOW: c_int = 6;
pub const G_IO_CHANNEL_ERROR_PIPE: c_int = 7;
pub const G_IO_CHANNEL_ERROR_FAILED: c_int = 8;
pub const GIOChannelError = c_uint;
pub const G_IO_STATUS_ERROR: c_int = 0;
pub const G_IO_STATUS_NORMAL: c_int = 1;
pub const G_IO_STATUS_EOF: c_int = 2;
pub const G_IO_STATUS_AGAIN: c_int = 3;
pub const GIOStatus = c_uint;
pub const G_SEEK_CUR: c_int = 0;
pub const G_SEEK_SET: c_int = 1;
pub const G_SEEK_END: c_int = 2;
pub const GSeekType = c_uint;
pub const G_IO_FLAG_APPEND: c_int = 1;
pub const G_IO_FLAG_NONBLOCK: c_int = 2;
pub const G_IO_FLAG_IS_READABLE: c_int = 4;
pub const G_IO_FLAG_IS_WRITABLE: c_int = 8;
pub const G_IO_FLAG_IS_WRITEABLE: c_int = 8;
pub const G_IO_FLAG_IS_SEEKABLE: c_int = 16;
pub const G_IO_FLAG_MASK: c_int = 31;
pub const G_IO_FLAG_GET_MASK: c_int = 31;
pub const G_IO_FLAG_SET_MASK: c_int = 3;
pub const GIOFlags = c_uint;
pub const GIOFunc = ?fn (?*GIOChannel, GIOCondition, gpointer) callconv(.C) gboolean;
pub extern fn g_io_channel_init(channel: ?*GIOChannel) void;
pub extern fn g_io_channel_ref(channel: ?*GIOChannel) ?*GIOChannel;
pub extern fn g_io_channel_unref(channel: ?*GIOChannel) void;
pub extern fn g_io_channel_read(channel: ?*GIOChannel, buf: [*c]gchar, count: gsize, bytes_read: [*c]gsize) GIOError;
pub extern fn g_io_channel_write(channel: ?*GIOChannel, buf: [*c]const gchar, count: gsize, bytes_written: [*c]gsize) GIOError;
pub extern fn g_io_channel_seek(channel: ?*GIOChannel, offset: gint64, @"type": GSeekType) GIOError;
pub extern fn g_io_channel_close(channel: ?*GIOChannel) void;
pub extern fn g_io_channel_shutdown(channel: ?*GIOChannel, flush: gboolean, err: [*c][*c]GError) GIOStatus;
pub extern fn g_io_add_watch_full(channel: ?*GIOChannel, priority: gint, condition: GIOCondition, func: GIOFunc, user_data: gpointer, notify: GDestroyNotify) guint;
pub extern fn g_io_create_watch(channel: ?*GIOChannel, condition: GIOCondition) [*c]GSource;
pub extern fn g_io_add_watch(channel: ?*GIOChannel, condition: GIOCondition, func: GIOFunc, user_data: gpointer) guint;
pub extern fn g_io_channel_set_buffer_size(channel: ?*GIOChannel, size: gsize) void;
pub extern fn g_io_channel_get_buffer_size(channel: ?*GIOChannel) gsize;
pub extern fn g_io_channel_get_buffer_condition(channel: ?*GIOChannel) GIOCondition;
pub extern fn g_io_channel_set_flags(channel: ?*GIOChannel, flags: GIOFlags, @"error": [*c][*c]GError) GIOStatus;
pub extern fn g_io_channel_get_flags(channel: ?*GIOChannel) GIOFlags;
pub extern fn g_io_channel_set_line_term(channel: ?*GIOChannel, line_term: [*c]const gchar, length: gint) void;
pub extern fn g_io_channel_get_line_term(channel: ?*GIOChannel, length: [*c]gint) [*c]const gchar;
pub extern fn g_io_channel_set_buffered(channel: ?*GIOChannel, buffered: gboolean) void;
pub extern fn g_io_channel_get_buffered(channel: ?*GIOChannel) gboolean;
pub extern fn g_io_channel_set_encoding(channel: ?*GIOChannel, encoding: [*c]const gchar, @"error": [*c][*c]GError) GIOStatus;
pub extern fn g_io_channel_get_encoding(channel: ?*GIOChannel) [*c]const gchar;
pub extern fn g_io_channel_set_close_on_unref(channel: ?*GIOChannel, do_close: gboolean) void;
pub extern fn g_io_channel_get_close_on_unref(channel: ?*GIOChannel) gboolean;
pub extern fn g_io_channel_flush(channel: ?*GIOChannel, @"error": [*c][*c]GError) GIOStatus;
pub extern fn g_io_channel_read_line(channel: ?*GIOChannel, str_return: [*c][*c]gchar, length: [*c]gsize, terminator_pos: [*c]gsize, @"error": [*c][*c]GError) GIOStatus;
pub extern fn g_io_channel_read_line_string(channel: ?*GIOChannel, buffer: [*c]GString, terminator_pos: [*c]gsize, @"error": [*c][*c]GError) GIOStatus;
pub extern fn g_io_channel_read_to_end(channel: ?*GIOChannel, str_return: [*c][*c]gchar, length: [*c]gsize, @"error": [*c][*c]GError) GIOStatus;
pub extern fn g_io_channel_read_chars(channel: ?*GIOChannel, buf: [*c]gchar, count: gsize, bytes_read: [*c]gsize, @"error": [*c][*c]GError) GIOStatus;
pub extern fn g_io_channel_read_unichar(channel: ?*GIOChannel, thechar: [*c]gunichar, @"error": [*c][*c]GError) GIOStatus;
pub extern fn g_io_channel_write_chars(channel: ?*GIOChannel, buf: [*c]const gchar, count: gssize, bytes_written: [*c]gsize, @"error": [*c][*c]GError) GIOStatus;
pub extern fn g_io_channel_write_unichar(channel: ?*GIOChannel, thechar: gunichar, @"error": [*c][*c]GError) GIOStatus;
pub extern fn g_io_channel_seek_position(channel: ?*GIOChannel, offset: gint64, @"type": GSeekType, @"error": [*c][*c]GError) GIOStatus;
pub extern fn g_io_channel_new_file(filename: [*c]const gchar, mode: [*c]const gchar, @"error": [*c][*c]GError) ?*GIOChannel;
pub extern fn g_io_channel_error_quark() GQuark;
pub extern fn g_io_channel_error_from_errno(en: gint) GIOChannelError;
pub extern fn g_io_channel_unix_new(fd: c_int) ?*GIOChannel;
pub extern fn g_io_channel_unix_get_fd(channel: ?*GIOChannel) gint;
pub extern var g_io_watch_funcs: GSourceFuncs;
pub const G_KEY_FILE_ERROR_UNKNOWN_ENCODING: c_int = 0;
pub const G_KEY_FILE_ERROR_PARSE: c_int = 1;
pub const G_KEY_FILE_ERROR_NOT_FOUND: c_int = 2;
pub const G_KEY_FILE_ERROR_KEY_NOT_FOUND: c_int = 3;
pub const G_KEY_FILE_ERROR_GROUP_NOT_FOUND: c_int = 4;
pub const G_KEY_FILE_ERROR_INVALID_VALUE: c_int = 5;
pub const GKeyFileError = c_uint;
pub extern fn g_key_file_error_quark() GQuark;
pub const struct__GKeyFile = opaque {};
pub const GKeyFile = struct__GKeyFile;
pub const G_KEY_FILE_NONE: c_int = 0;
pub const G_KEY_FILE_KEEP_COMMENTS: c_int = 1;
pub const G_KEY_FILE_KEEP_TRANSLATIONS: c_int = 2;
pub const GKeyFileFlags = c_uint;
pub extern fn g_key_file_new() ?*GKeyFile;
pub extern fn g_key_file_ref(key_file: ?*GKeyFile) ?*GKeyFile;
pub extern fn g_key_file_unref(key_file: ?*GKeyFile) void;
pub extern fn g_key_file_free(key_file: ?*GKeyFile) void;
pub extern fn g_key_file_set_list_separator(key_file: ?*GKeyFile, separator: gchar) void;
pub extern fn g_key_file_load_from_file(key_file: ?*GKeyFile, file: [*c]const gchar, flags: GKeyFileFlags, @"error": [*c][*c]GError) gboolean;
pub extern fn g_key_file_load_from_data(key_file: ?*GKeyFile, data: [*c]const gchar, length: gsize, flags: GKeyFileFlags, @"error": [*c][*c]GError) gboolean;
pub extern fn g_key_file_load_from_bytes(key_file: ?*GKeyFile, bytes: ?*GBytes, flags: GKeyFileFlags, @"error": [*c][*c]GError) gboolean;
pub extern fn g_key_file_load_from_dirs(key_file: ?*GKeyFile, file: [*c]const gchar, search_dirs: [*c][*c]const gchar, full_path: [*c][*c]gchar, flags: GKeyFileFlags, @"error": [*c][*c]GError) gboolean;
pub extern fn g_key_file_load_from_data_dirs(key_file: ?*GKeyFile, file: [*c]const gchar, full_path: [*c][*c]gchar, flags: GKeyFileFlags, @"error": [*c][*c]GError) gboolean;
pub extern fn g_key_file_to_data(key_file: ?*GKeyFile, length: [*c]gsize, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_key_file_save_to_file(key_file: ?*GKeyFile, filename: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_key_file_get_start_group(key_file: ?*GKeyFile) [*c]gchar;
pub extern fn g_key_file_get_groups(key_file: ?*GKeyFile, length: [*c]gsize) [*c][*c]gchar;
pub extern fn g_key_file_get_keys(key_file: ?*GKeyFile, group_name: [*c]const gchar, length: [*c]gsize, @"error": [*c][*c]GError) [*c][*c]gchar;
pub extern fn g_key_file_has_group(key_file: ?*GKeyFile, group_name: [*c]const gchar) gboolean;
pub extern fn g_key_file_has_key(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_key_file_get_value(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_key_file_set_value(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, value: [*c]const gchar) void;
pub extern fn g_key_file_get_string(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_key_file_set_string(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, string: [*c]const gchar) void;
pub extern fn g_key_file_get_locale_string(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, locale: [*c]const gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_key_file_get_locale_for_key(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, locale: [*c]const gchar) [*c]gchar;
pub extern fn g_key_file_set_locale_string(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, locale: [*c]const gchar, string: [*c]const gchar) void;
pub extern fn g_key_file_get_boolean(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_key_file_set_boolean(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, value: gboolean) void;
pub extern fn g_key_file_get_integer(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c][*c]GError) gint;
pub extern fn g_key_file_set_integer(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, value: gint) void;
pub extern fn g_key_file_get_int64(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c][*c]GError) gint64;
pub extern fn g_key_file_set_int64(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, value: gint64) void;
pub extern fn g_key_file_get_uint64(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c][*c]GError) guint64;
pub extern fn g_key_file_set_uint64(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, value: guint64) void;
pub extern fn g_key_file_get_double(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c][*c]GError) gdouble;
pub extern fn g_key_file_set_double(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, value: gdouble) void;
pub extern fn g_key_file_get_string_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, length: [*c]gsize, @"error": [*c][*c]GError) [*c][*c]gchar;
pub extern fn g_key_file_set_string_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, list: [*c]const [*c]const gchar, length: gsize) void;
pub extern fn g_key_file_get_locale_string_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, locale: [*c]const gchar, length: [*c]gsize, @"error": [*c][*c]GError) [*c][*c]gchar;
pub extern fn g_key_file_set_locale_string_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, locale: [*c]const gchar, list: [*c]const [*c]const gchar, length: gsize) void;
pub extern fn g_key_file_get_boolean_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, length: [*c]gsize, @"error": [*c][*c]GError) [*c]gboolean;
pub extern fn g_key_file_set_boolean_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, list: [*c]gboolean, length: gsize) void;
pub extern fn g_key_file_get_integer_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, length: [*c]gsize, @"error": [*c][*c]GError) [*c]gint;
pub extern fn g_key_file_set_double_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, list: [*c]gdouble, length: gsize) void;
pub extern fn g_key_file_get_double_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, length: [*c]gsize, @"error": [*c][*c]GError) [*c]gdouble;
pub extern fn g_key_file_set_integer_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, list: [*c]gint, length: gsize) void;
pub extern fn g_key_file_set_comment(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, comment: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_key_file_get_comment(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_key_file_remove_comment(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_key_file_remove_key(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_key_file_remove_group(key_file: ?*GKeyFile, group_name: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub const struct__GMappedFile = opaque {};
pub const GMappedFile = struct__GMappedFile;
pub extern fn g_mapped_file_new(filename: [*c]const gchar, writable: gboolean, @"error": [*c][*c]GError) ?*GMappedFile;
pub extern fn g_mapped_file_new_from_fd(fd: gint, writable: gboolean, @"error": [*c][*c]GError) ?*GMappedFile;
pub extern fn g_mapped_file_get_length(file: ?*GMappedFile) gsize;
pub extern fn g_mapped_file_get_contents(file: ?*GMappedFile) [*c]gchar;
pub extern fn g_mapped_file_get_bytes(file: ?*GMappedFile) ?*GBytes;
pub extern fn g_mapped_file_ref(file: ?*GMappedFile) ?*GMappedFile;
pub extern fn g_mapped_file_unref(file: ?*GMappedFile) void;
pub extern fn g_mapped_file_free(file: ?*GMappedFile) void;
pub const G_MARKUP_ERROR_BAD_UTF8: c_int = 0;
pub const G_MARKUP_ERROR_EMPTY: c_int = 1;
pub const G_MARKUP_ERROR_PARSE: c_int = 2;
pub const G_MARKUP_ERROR_UNKNOWN_ELEMENT: c_int = 3;
pub const G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: c_int = 4;
pub const G_MARKUP_ERROR_INVALID_CONTENT: c_int = 5;
pub const G_MARKUP_ERROR_MISSING_ATTRIBUTE: c_int = 6;
pub const GMarkupError = c_uint;
pub extern fn g_markup_error_quark() GQuark;
pub const G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: c_int = 1;
pub const G_MARKUP_TREAT_CDATA_AS_TEXT: c_int = 2;
pub const G_MARKUP_PREFIX_ERROR_POSITION: c_int = 4;
pub const G_MARKUP_IGNORE_QUALIFIED: c_int = 8;
pub const GMarkupParseFlags = c_uint;
pub const struct__GMarkupParseContext = opaque {};
pub const GMarkupParseContext = struct__GMarkupParseContext;
pub const struct__GMarkupParser = extern struct {
    start_element: ?fn (?*GMarkupParseContext, [*c]const gchar, [*c][*c]const gchar, [*c][*c]const gchar, gpointer, [*c][*c]GError) callconv(.C) void,
    end_element: ?fn (?*GMarkupParseContext, [*c]const gchar, gpointer, [*c][*c]GError) callconv(.C) void,
    text: ?fn (?*GMarkupParseContext, [*c]const gchar, gsize, gpointer, [*c][*c]GError) callconv(.C) void,
    passthrough: ?fn (?*GMarkupParseContext, [*c]const gchar, gsize, gpointer, [*c][*c]GError) callconv(.C) void,
    @"error": ?fn (?*GMarkupParseContext, [*c]GError, gpointer) callconv(.C) void,
};
pub const GMarkupParser = struct__GMarkupParser;
pub extern fn g_markup_parse_context_new(parser: [*c]const GMarkupParser, flags: GMarkupParseFlags, user_data: gpointer, user_data_dnotify: GDestroyNotify) ?*GMarkupParseContext;
pub extern fn g_markup_parse_context_ref(context: ?*GMarkupParseContext) ?*GMarkupParseContext;
pub extern fn g_markup_parse_context_unref(context: ?*GMarkupParseContext) void;
pub extern fn g_markup_parse_context_free(context: ?*GMarkupParseContext) void;
pub extern fn g_markup_parse_context_parse(context: ?*GMarkupParseContext, text: [*c]const gchar, text_len: gssize, @"error": [*c][*c]GError) gboolean;
pub extern fn g_markup_parse_context_push(context: ?*GMarkupParseContext, parser: [*c]const GMarkupParser, user_data: gpointer) void;
pub extern fn g_markup_parse_context_pop(context: ?*GMarkupParseContext) gpointer;
pub extern fn g_markup_parse_context_end_parse(context: ?*GMarkupParseContext, @"error": [*c][*c]GError) gboolean;
pub extern fn g_markup_parse_context_get_element(context: ?*GMarkupParseContext) [*c]const gchar;
pub extern fn g_markup_parse_context_get_element_stack(context: ?*GMarkupParseContext) [*c]const GSList;
pub extern fn g_markup_parse_context_get_position(context: ?*GMarkupParseContext, line_number: [*c]gint, char_number: [*c]gint) void;
pub extern fn g_markup_parse_context_get_user_data(context: ?*GMarkupParseContext) gpointer;
pub extern fn g_markup_escape_text(text: [*c]const gchar, length: gssize) [*c]gchar;
pub extern fn g_markup_printf_escaped(format: [*c]const u8, ...) [*c]gchar;
pub extern fn g_markup_vprintf_escaped(format: [*c]const u8, args: va_list) [*c]gchar;
pub const G_MARKUP_COLLECT_INVALID: c_int = 0;
pub const G_MARKUP_COLLECT_STRING: c_int = 1;
pub const G_MARKUP_COLLECT_STRDUP: c_int = 2;
pub const G_MARKUP_COLLECT_BOOLEAN: c_int = 3;
pub const G_MARKUP_COLLECT_TRISTATE: c_int = 4;
pub const G_MARKUP_COLLECT_OPTIONAL: c_int = 65536;
pub const GMarkupCollectType = c_uint;
pub extern fn g_markup_collect_attributes(element_name: [*c]const gchar, attribute_names: [*c][*c]const gchar, attribute_values: [*c][*c]const gchar, @"error": [*c][*c]GError, first_type: GMarkupCollectType, first_attr: [*c]const gchar, ...) gboolean;
pub const struct__GVariantType = opaque {};
pub const GVariantType = struct__GVariantType;
pub extern fn g_variant_type_string_is_valid(type_string: [*c]const gchar) gboolean;
pub extern fn g_variant_type_string_scan(string: [*c]const gchar, limit: [*c]const gchar, endptr: [*c][*c]const gchar) gboolean;
pub extern fn g_variant_type_free(@"type": ?*GVariantType) void;
pub extern fn g_variant_type_copy(@"type": ?*const GVariantType) ?*GVariantType;
pub extern fn g_variant_type_new(type_string: [*c]const gchar) ?*GVariantType;
pub extern fn g_variant_type_get_string_length(@"type": ?*const GVariantType) gsize;
pub extern fn g_variant_type_peek_string(@"type": ?*const GVariantType) [*c]const gchar;
pub extern fn g_variant_type_dup_string(@"type": ?*const GVariantType) [*c]gchar;
pub extern fn g_variant_type_is_definite(@"type": ?*const GVariantType) gboolean;
pub extern fn g_variant_type_is_container(@"type": ?*const GVariantType) gboolean;
pub extern fn g_variant_type_is_basic(@"type": ?*const GVariantType) gboolean;
pub extern fn g_variant_type_is_maybe(@"type": ?*const GVariantType) gboolean;
pub extern fn g_variant_type_is_array(@"type": ?*const GVariantType) gboolean;
pub extern fn g_variant_type_is_tuple(@"type": ?*const GVariantType) gboolean;
pub extern fn g_variant_type_is_dict_entry(@"type": ?*const GVariantType) gboolean;
pub extern fn g_variant_type_is_variant(@"type": ?*const GVariantType) gboolean;
pub extern fn g_variant_type_hash(@"type": gconstpointer) guint;
pub extern fn g_variant_type_equal(type1: gconstpointer, type2: gconstpointer) gboolean;
pub extern fn g_variant_type_is_subtype_of(@"type": ?*const GVariantType, supertype: ?*const GVariantType) gboolean;
pub extern fn g_variant_type_element(@"type": ?*const GVariantType) ?*const GVariantType;
pub extern fn g_variant_type_first(@"type": ?*const GVariantType) ?*const GVariantType;
pub extern fn g_variant_type_next(@"type": ?*const GVariantType) ?*const GVariantType;
pub extern fn g_variant_type_n_items(@"type": ?*const GVariantType) gsize;
pub extern fn g_variant_type_key(@"type": ?*const GVariantType) ?*const GVariantType;
pub extern fn g_variant_type_value(@"type": ?*const GVariantType) ?*const GVariantType;
pub extern fn g_variant_type_new_array(element: ?*const GVariantType) ?*GVariantType;
pub extern fn g_variant_type_new_maybe(element: ?*const GVariantType) ?*GVariantType;
pub extern fn g_variant_type_new_tuple(items: [*c]const ?*const GVariantType, length: gint) ?*GVariantType;
pub extern fn g_variant_type_new_dict_entry(key: ?*const GVariantType, value: ?*const GVariantType) ?*GVariantType;
pub extern fn g_variant_type_checked_([*c]const gchar) ?*const GVariantType;
pub extern fn g_variant_type_string_get_depth_(type_string: [*c]const gchar) gsize;
pub const struct__GVariant = opaque {};
pub const GVariant = struct__GVariant;
pub const G_VARIANT_CLASS_BOOLEAN: c_int = 98;
pub const G_VARIANT_CLASS_BYTE: c_int = 121;
pub const G_VARIANT_CLASS_INT16: c_int = 110;
pub const G_VARIANT_CLASS_UINT16: c_int = 113;
pub const G_VARIANT_CLASS_INT32: c_int = 105;
pub const G_VARIANT_CLASS_UINT32: c_int = 117;
pub const G_VARIANT_CLASS_INT64: c_int = 120;
pub const G_VARIANT_CLASS_UINT64: c_int = 116;
pub const G_VARIANT_CLASS_HANDLE: c_int = 104;
pub const G_VARIANT_CLASS_DOUBLE: c_int = 100;
pub const G_VARIANT_CLASS_STRING: c_int = 115;
pub const G_VARIANT_CLASS_OBJECT_PATH: c_int = 111;
pub const G_VARIANT_CLASS_SIGNATURE: c_int = 103;
pub const G_VARIANT_CLASS_VARIANT: c_int = 118;
pub const G_VARIANT_CLASS_MAYBE: c_int = 109;
pub const G_VARIANT_CLASS_ARRAY: c_int = 97;
pub const G_VARIANT_CLASS_TUPLE: c_int = 40;
pub const G_VARIANT_CLASS_DICT_ENTRY: c_int = 123;
pub const GVariantClass = c_uint;
pub extern fn g_variant_unref(value: ?*GVariant) void;
pub extern fn g_variant_ref(value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_ref_sink(value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_is_floating(value: ?*GVariant) gboolean;
pub extern fn g_variant_take_ref(value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_get_type(value: ?*GVariant) ?*const GVariantType;
pub extern fn g_variant_get_type_string(value: ?*GVariant) [*c]const gchar;
pub extern fn g_variant_is_of_type(value: ?*GVariant, @"type": ?*const GVariantType) gboolean;
pub extern fn g_variant_is_container(value: ?*GVariant) gboolean;
pub extern fn g_variant_classify(value: ?*GVariant) GVariantClass;
pub extern fn g_variant_new_boolean(value: gboolean) ?*GVariant;
pub extern fn g_variant_new_byte(value: guint8) ?*GVariant;
pub extern fn g_variant_new_int16(value: gint16) ?*GVariant;
pub extern fn g_variant_new_uint16(value: guint16) ?*GVariant;
pub extern fn g_variant_new_int32(value: gint32) ?*GVariant;
pub extern fn g_variant_new_uint32(value: guint32) ?*GVariant;
pub extern fn g_variant_new_int64(value: gint64) ?*GVariant;
pub extern fn g_variant_new_uint64(value: guint64) ?*GVariant;
pub extern fn g_variant_new_handle(value: gint32) ?*GVariant;
pub extern fn g_variant_new_double(value: gdouble) ?*GVariant;
pub extern fn g_variant_new_string(string: [*c]const gchar) ?*GVariant;
pub extern fn g_variant_new_take_string(string: [*c]gchar) ?*GVariant;
pub extern fn g_variant_new_printf(format_string: [*c]const gchar, ...) ?*GVariant;
pub extern fn g_variant_new_object_path(object_path: [*c]const gchar) ?*GVariant;
pub extern fn g_variant_is_object_path(string: [*c]const gchar) gboolean;
pub extern fn g_variant_new_signature(signature: [*c]const gchar) ?*GVariant;
pub extern fn g_variant_is_signature(string: [*c]const gchar) gboolean;
pub extern fn g_variant_new_variant(value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_new_strv(strv: [*c]const [*c]const gchar, length: gssize) ?*GVariant;
pub extern fn g_variant_new_objv(strv: [*c]const [*c]const gchar, length: gssize) ?*GVariant;
pub extern fn g_variant_new_bytestring(string: [*c]const gchar) ?*GVariant;
pub extern fn g_variant_new_bytestring_array(strv: [*c]const [*c]const gchar, length: gssize) ?*GVariant;
pub extern fn g_variant_new_fixed_array(element_type: ?*const GVariantType, elements: gconstpointer, n_elements: gsize, element_size: gsize) ?*GVariant;
pub extern fn g_variant_get_boolean(value: ?*GVariant) gboolean;
pub extern fn g_variant_get_byte(value: ?*GVariant) guint8;
pub extern fn g_variant_get_int16(value: ?*GVariant) gint16;
pub extern fn g_variant_get_uint16(value: ?*GVariant) guint16;
pub extern fn g_variant_get_int32(value: ?*GVariant) gint32;
pub extern fn g_variant_get_uint32(value: ?*GVariant) guint32;
pub extern fn g_variant_get_int64(value: ?*GVariant) gint64;
pub extern fn g_variant_get_uint64(value: ?*GVariant) guint64;
pub extern fn g_variant_get_handle(value: ?*GVariant) gint32;
pub extern fn g_variant_get_double(value: ?*GVariant) gdouble;
pub extern fn g_variant_get_variant(value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_get_string(value: ?*GVariant, length: [*c]gsize) [*c]const gchar;
pub extern fn g_variant_dup_string(value: ?*GVariant, length: [*c]gsize) [*c]gchar;
pub extern fn g_variant_get_strv(value: ?*GVariant, length: [*c]gsize) [*c][*c]const gchar;
pub extern fn g_variant_dup_strv(value: ?*GVariant, length: [*c]gsize) [*c][*c]gchar;
pub extern fn g_variant_get_objv(value: ?*GVariant, length: [*c]gsize) [*c][*c]const gchar;
pub extern fn g_variant_dup_objv(value: ?*GVariant, length: [*c]gsize) [*c][*c]gchar;
pub extern fn g_variant_get_bytestring(value: ?*GVariant) [*c]const gchar;
pub extern fn g_variant_dup_bytestring(value: ?*GVariant, length: [*c]gsize) [*c]gchar;
pub extern fn g_variant_get_bytestring_array(value: ?*GVariant, length: [*c]gsize) [*c][*c]const gchar;
pub extern fn g_variant_dup_bytestring_array(value: ?*GVariant, length: [*c]gsize) [*c][*c]gchar;
pub extern fn g_variant_new_maybe(child_type: ?*const GVariantType, child: ?*GVariant) ?*GVariant;
pub extern fn g_variant_new_array(child_type: ?*const GVariantType, children: [*c]const ?*GVariant, n_children: gsize) ?*GVariant;
pub extern fn g_variant_new_tuple(children: [*c]const ?*GVariant, n_children: gsize) ?*GVariant;
pub extern fn g_variant_new_dict_entry(key: ?*GVariant, value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_get_maybe(value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_n_children(value: ?*GVariant) gsize;
pub extern fn g_variant_get_child(value: ?*GVariant, index_: gsize, format_string: [*c]const gchar, ...) void;
pub extern fn g_variant_get_child_value(value: ?*GVariant, index_: gsize) ?*GVariant;
pub extern fn g_variant_lookup(dictionary: ?*GVariant, key: [*c]const gchar, format_string: [*c]const gchar, ...) gboolean;
pub extern fn g_variant_lookup_value(dictionary: ?*GVariant, key: [*c]const gchar, expected_type: ?*const GVariantType) ?*GVariant;
pub extern fn g_variant_get_fixed_array(value: ?*GVariant, n_elements: [*c]gsize, element_size: gsize) gconstpointer;
pub extern fn g_variant_get_size(value: ?*GVariant) gsize;
pub extern fn g_variant_get_data(value: ?*GVariant) gconstpointer;
pub extern fn g_variant_get_data_as_bytes(value: ?*GVariant) ?*GBytes;
pub extern fn g_variant_store(value: ?*GVariant, data: gpointer) void;
pub extern fn g_variant_print(value: ?*GVariant, type_annotate: gboolean) [*c]gchar;
pub extern fn g_variant_print_string(value: ?*GVariant, string: [*c]GString, type_annotate: gboolean) [*c]GString;
pub extern fn g_variant_hash(value: gconstpointer) guint;
pub extern fn g_variant_equal(one: gconstpointer, two: gconstpointer) gboolean;
pub extern fn g_variant_get_normal_form(value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_is_normal_form(value: ?*GVariant) gboolean;
pub extern fn g_variant_byteswap(value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_new_from_bytes(@"type": ?*const GVariantType, bytes: ?*GBytes, trusted: gboolean) ?*GVariant;
pub extern fn g_variant_new_from_data(@"type": ?*const GVariantType, data: gconstpointer, size: gsize, trusted: gboolean, notify: GDestroyNotify, user_data: gpointer) ?*GVariant;
pub const struct__GVariantIter = extern struct {
    x: [16]gsize,
};
pub const GVariantIter = struct__GVariantIter;
pub extern fn g_variant_iter_new(value: ?*GVariant) [*c]GVariantIter;
pub extern fn g_variant_iter_init(iter: [*c]GVariantIter, value: ?*GVariant) gsize;
pub extern fn g_variant_iter_copy(iter: [*c]GVariantIter) [*c]GVariantIter;
pub extern fn g_variant_iter_n_children(iter: [*c]GVariantIter) gsize;
pub extern fn g_variant_iter_free(iter: [*c]GVariantIter) void;
pub extern fn g_variant_iter_next_value(iter: [*c]GVariantIter) ?*GVariant;
pub extern fn g_variant_iter_next(iter: [*c]GVariantIter, format_string: [*c]const gchar, ...) gboolean;
pub extern fn g_variant_iter_loop(iter: [*c]GVariantIter, format_string: [*c]const gchar, ...) gboolean;
const struct_unnamed_31 = extern struct {
    partial_magic: gsize,
    type: ?*const GVariantType,
    y: [14]gsize,
};
const union_unnamed_30 = extern union {
    s: struct_unnamed_31,
    x: [16]gsize,
};
pub const struct__GVariantBuilder = extern struct {
    u: union_unnamed_30,
};
pub const GVariantBuilder = struct__GVariantBuilder;
pub const G_VARIANT_PARSE_ERROR_FAILED: c_int = 0;
pub const G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED: c_int = 1;
pub const G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE: c_int = 2;
pub const G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED: c_int = 3;
pub const G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END: c_int = 4;
pub const G_VARIANT_PARSE_ERROR_INVALID_CHARACTER: c_int = 5;
pub const G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING: c_int = 6;
pub const G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH: c_int = 7;
pub const G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE: c_int = 8;
pub const G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING: c_int = 9;
pub const G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE: c_int = 10;
pub const G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE: c_int = 11;
pub const G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG: c_int = 12;
pub const G_VARIANT_PARSE_ERROR_TYPE_ERROR: c_int = 13;
pub const G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN: c_int = 14;
pub const G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD: c_int = 15;
pub const G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT: c_int = 16;
pub const G_VARIANT_PARSE_ERROR_VALUE_EXPECTED: c_int = 17;
pub const G_VARIANT_PARSE_ERROR_RECURSION: c_int = 18;
pub const GVariantParseError = c_uint;
pub extern fn g_variant_parser_get_error_quark() GQuark;
pub extern fn g_variant_parse_error_quark() GQuark;
pub extern fn g_variant_builder_new(@"type": ?*const GVariantType) [*c]GVariantBuilder;
pub extern fn g_variant_builder_unref(builder: [*c]GVariantBuilder) void;
pub extern fn g_variant_builder_ref(builder: [*c]GVariantBuilder) [*c]GVariantBuilder;
pub extern fn g_variant_builder_init(builder: [*c]GVariantBuilder, @"type": ?*const GVariantType) void;
pub extern fn g_variant_builder_end(builder: [*c]GVariantBuilder) ?*GVariant;
pub extern fn g_variant_builder_clear(builder: [*c]GVariantBuilder) void;
pub extern fn g_variant_builder_open(builder: [*c]GVariantBuilder, @"type": ?*const GVariantType) void;
pub extern fn g_variant_builder_close(builder: [*c]GVariantBuilder) void;
pub extern fn g_variant_builder_add_value(builder: [*c]GVariantBuilder, value: ?*GVariant) void;
pub extern fn g_variant_builder_add(builder: [*c]GVariantBuilder, format_string: [*c]const gchar, ...) void;
pub extern fn g_variant_builder_add_parsed(builder: [*c]GVariantBuilder, format: [*c]const gchar, ...) void;
pub extern fn g_variant_new(format_string: [*c]const gchar, ...) ?*GVariant;
pub extern fn g_variant_get(value: ?*GVariant, format_string: [*c]const gchar, ...) void;
pub extern fn g_variant_new_va(format_string: [*c]const gchar, endptr: [*c][*c]const gchar, app: [*c]va_list) ?*GVariant;
pub extern fn g_variant_get_va(value: ?*GVariant, format_string: [*c]const gchar, endptr: [*c][*c]const gchar, app: [*c]va_list) void;
pub extern fn g_variant_check_format_string(value: ?*GVariant, format_string: [*c]const gchar, copy_only: gboolean) gboolean;
pub extern fn g_variant_parse(@"type": ?*const GVariantType, text: [*c]const gchar, limit: [*c]const gchar, endptr: [*c][*c]const gchar, @"error": [*c][*c]GError) ?*GVariant;
pub extern fn g_variant_new_parsed(format: [*c]const gchar, ...) ?*GVariant;
pub extern fn g_variant_new_parsed_va(format: [*c]const gchar, app: [*c]va_list) ?*GVariant;
pub extern fn g_variant_parse_error_print_context(@"error": [*c]GError, source_str: [*c]const gchar) [*c]gchar;
pub extern fn g_variant_compare(one: gconstpointer, two: gconstpointer) gint;
const struct_unnamed_33 = extern struct {
    asv: ?*GVariant,
    partial_magic: gsize,
    y: [14]gsize,
};
const union_unnamed_32 = extern union {
    s: struct_unnamed_33,
    x: [16]gsize,
};
pub const struct__GVariantDict = extern struct {
    u: union_unnamed_32,
};
pub const GVariantDict = struct__GVariantDict;
pub extern fn g_variant_dict_new(from_asv: ?*GVariant) [*c]GVariantDict;
pub extern fn g_variant_dict_init(dict: [*c]GVariantDict, from_asv: ?*GVariant) void;
pub extern fn g_variant_dict_lookup(dict: [*c]GVariantDict, key: [*c]const gchar, format_string: [*c]const gchar, ...) gboolean;
pub extern fn g_variant_dict_lookup_value(dict: [*c]GVariantDict, key: [*c]const gchar, expected_type: ?*const GVariantType) ?*GVariant;
pub extern fn g_variant_dict_contains(dict: [*c]GVariantDict, key: [*c]const gchar) gboolean;
pub extern fn g_variant_dict_insert(dict: [*c]GVariantDict, key: [*c]const gchar, format_string: [*c]const gchar, ...) void;
pub extern fn g_variant_dict_insert_value(dict: [*c]GVariantDict, key: [*c]const gchar, value: ?*GVariant) void;
pub extern fn g_variant_dict_remove(dict: [*c]GVariantDict, key: [*c]const gchar) gboolean;
pub extern fn g_variant_dict_clear(dict: [*c]GVariantDict) void;
pub extern fn g_variant_dict_end(dict: [*c]GVariantDict) ?*GVariant;
pub extern fn g_variant_dict_ref(dict: [*c]GVariantDict) [*c]GVariantDict;
pub extern fn g_variant_dict_unref(dict: [*c]GVariantDict) void;
pub extern fn g_printf_string_upper_bound(format: [*c]const gchar, args: va_list) gsize;
pub const G_LOG_FLAG_RECURSION: c_int = 1;
pub const G_LOG_FLAG_FATAL: c_int = 2;
pub const G_LOG_LEVEL_ERROR: c_int = 4;
pub const G_LOG_LEVEL_CRITICAL: c_int = 8;
pub const G_LOG_LEVEL_WARNING: c_int = 16;
pub const G_LOG_LEVEL_MESSAGE: c_int = 32;
pub const G_LOG_LEVEL_INFO: c_int = 64;
pub const G_LOG_LEVEL_DEBUG: c_int = 128;
pub const G_LOG_LEVEL_MASK: c_int = -4;
pub const GLogLevelFlags = c_int;
pub const GLogFunc = ?fn ([*c]const gchar, GLogLevelFlags, [*c]const gchar, gpointer) callconv(.C) void;
pub extern fn g_log_set_handler(log_domain: [*c]const gchar, log_levels: GLogLevelFlags, log_func: GLogFunc, user_data: gpointer) guint;
pub extern fn g_log_set_handler_full(log_domain: [*c]const gchar, log_levels: GLogLevelFlags, log_func: GLogFunc, user_data: gpointer, destroy: GDestroyNotify) guint;
pub extern fn g_log_remove_handler(log_domain: [*c]const gchar, handler_id: guint) void;
pub extern fn g_log_default_handler(log_domain: [*c]const gchar, log_level: GLogLevelFlags, message: [*c]const gchar, unused_data: gpointer) void;
pub extern fn g_log_set_default_handler(log_func: GLogFunc, user_data: gpointer) GLogFunc;
pub extern fn g_log(log_domain: [*c]const gchar, log_level: GLogLevelFlags, format: [*c]const gchar, ...) void;
pub extern fn g_logv(log_domain: [*c]const gchar, log_level: GLogLevelFlags, format: [*c]const gchar, args: va_list) void;
pub extern fn g_log_set_fatal_mask(log_domain: [*c]const gchar, fatal_mask: GLogLevelFlags) GLogLevelFlags;
pub extern fn g_log_set_always_fatal(fatal_mask: GLogLevelFlags) GLogLevelFlags;
pub const G_LOG_WRITER_HANDLED: c_int = 1;
pub const G_LOG_WRITER_UNHANDLED: c_int = 0;
pub const GLogWriterOutput = c_uint;
pub const struct__GLogField = extern struct {
    key: [*c]const gchar,
    value: gconstpointer,
    length: gssize,
};
pub const GLogField = struct__GLogField;
pub const GLogWriterFunc = ?fn (GLogLevelFlags, [*c]const GLogField, gsize, gpointer) callconv(.C) GLogWriterOutput;
pub extern fn g_log_structured(log_domain: [*c]const gchar, log_level: GLogLevelFlags, ...) void;
pub extern fn g_log_structured_array(log_level: GLogLevelFlags, fields: [*c]const GLogField, n_fields: gsize) void;
pub extern fn g_log_variant(log_domain: [*c]const gchar, log_level: GLogLevelFlags, fields: ?*GVariant) void;
pub extern fn g_log_set_writer_func(func: GLogWriterFunc, user_data: gpointer, user_data_free: GDestroyNotify) void;
pub extern fn g_log_writer_supports_color(output_fd: gint) gboolean;
pub extern fn g_log_writer_is_journald(output_fd: gint) gboolean;
pub extern fn g_log_writer_format_fields(log_level: GLogLevelFlags, fields: [*c]const GLogField, n_fields: gsize, use_color: gboolean) [*c]gchar;
pub extern fn g_log_writer_journald(log_level: GLogLevelFlags, fields: [*c]const GLogField, n_fields: gsize, user_data: gpointer) GLogWriterOutput;
pub extern fn g_log_writer_standard_streams(log_level: GLogLevelFlags, fields: [*c]const GLogField, n_fields: gsize, user_data: gpointer) GLogWriterOutput;
pub extern fn g_log_writer_default(log_level: GLogLevelFlags, fields: [*c]const GLogField, n_fields: gsize, user_data: gpointer) GLogWriterOutput;
pub extern fn g_log_writer_default_set_use_stderr(use_stderr: gboolean) void;
pub extern fn g_log_writer_default_would_drop(log_level: GLogLevelFlags, log_domain: [*c]const u8) gboolean;
pub extern fn g_log_get_debug_enabled() gboolean;
pub extern fn g_log_set_debug_enabled(enabled: gboolean) void;
pub extern fn _g_log_fallback_handler(log_domain: [*c]const gchar, log_level: GLogLevelFlags, message: [*c]const gchar, unused_data: gpointer) void;
pub extern fn g_return_if_fail_warning(log_domain: [*c]const u8, pretty_function: [*c]const u8, expression: [*c]const u8) void;
pub extern fn g_warn_message(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8, warnexpr: [*c]const u8) void;
pub extern fn g_assert_warning(log_domain: [*c]const u8, file: [*c]const u8, line: c_int, pretty_function: [*c]const u8, expression: [*c]const u8) noreturn;
pub extern fn g_log_structured_standard(log_domain: [*c]const gchar, log_level: GLogLevelFlags, file: [*c]const gchar, line: [*c]const gchar, func: [*c]const gchar, message_format: [*c]const gchar, ...) void;
pub const GPrintFunc = ?fn ([*c]const gchar) callconv(.C) void;
pub extern fn g_print(format: [*c]const gchar, ...) void;
pub extern fn g_set_print_handler(func: GPrintFunc) GPrintFunc;
pub extern fn g_printerr(format: [*c]const gchar, ...) void;
pub extern fn g_set_printerr_handler(func: GPrintFunc) GPrintFunc;
pub const struct__GOptionContext = opaque {};
pub const GOptionContext = struct__GOptionContext;
pub const struct__GOptionGroup = opaque {};
pub const GOptionGroup = struct__GOptionGroup;
pub const struct__GOptionEntry = extern struct {
    long_name: [*c]const gchar,
    short_name: gchar,
    flags: gint,
    arg: GOptionArg,
    arg_data: gpointer,
    description: [*c]const gchar,
    arg_description: [*c]const gchar,
};
pub const GOptionEntry = struct__GOptionEntry;
pub const G_OPTION_FLAG_NONE: c_int = 0;
pub const G_OPTION_FLAG_HIDDEN: c_int = 1;
pub const G_OPTION_FLAG_IN_MAIN: c_int = 2;
pub const G_OPTION_FLAG_REVERSE: c_int = 4;
pub const G_OPTION_FLAG_NO_ARG: c_int = 8;
pub const G_OPTION_FLAG_FILENAME: c_int = 16;
pub const G_OPTION_FLAG_OPTIONAL_ARG: c_int = 32;
pub const G_OPTION_FLAG_NOALIAS: c_int = 64;
pub const GOptionFlags = c_uint;
pub const G_OPTION_ARG_NONE: c_int = 0;
pub const G_OPTION_ARG_STRING: c_int = 1;
pub const G_OPTION_ARG_INT: c_int = 2;
pub const G_OPTION_ARG_CALLBACK: c_int = 3;
pub const G_OPTION_ARG_FILENAME: c_int = 4;
pub const G_OPTION_ARG_STRING_ARRAY: c_int = 5;
pub const G_OPTION_ARG_FILENAME_ARRAY: c_int = 6;
pub const G_OPTION_ARG_DOUBLE: c_int = 7;
pub const G_OPTION_ARG_INT64: c_int = 8;
pub const GOptionArg = c_uint;
pub const GOptionArgFunc = ?fn ([*c]const gchar, [*c]const gchar, gpointer, [*c][*c]GError) callconv(.C) gboolean;
pub const GOptionParseFunc = ?fn (?*GOptionContext, ?*GOptionGroup, gpointer, [*c][*c]GError) callconv(.C) gboolean;
pub const GOptionErrorFunc = ?fn (?*GOptionContext, ?*GOptionGroup, gpointer, [*c][*c]GError) callconv(.C) void;
pub const G_OPTION_ERROR_UNKNOWN_OPTION: c_int = 0;
pub const G_OPTION_ERROR_BAD_VALUE: c_int = 1;
pub const G_OPTION_ERROR_FAILED: c_int = 2;
pub const GOptionError = c_uint;
pub extern fn g_option_error_quark() GQuark;
pub extern fn g_option_context_new(parameter_string: [*c]const gchar) ?*GOptionContext;
pub extern fn g_option_context_set_summary(context: ?*GOptionContext, summary: [*c]const gchar) void;
pub extern fn g_option_context_get_summary(context: ?*GOptionContext) [*c]const gchar;
pub extern fn g_option_context_set_description(context: ?*GOptionContext, description: [*c]const gchar) void;
pub extern fn g_option_context_get_description(context: ?*GOptionContext) [*c]const gchar;
pub extern fn g_option_context_free(context: ?*GOptionContext) void;
pub extern fn g_option_context_set_help_enabled(context: ?*GOptionContext, help_enabled: gboolean) void;
pub extern fn g_option_context_get_help_enabled(context: ?*GOptionContext) gboolean;
pub extern fn g_option_context_set_ignore_unknown_options(context: ?*GOptionContext, ignore_unknown: gboolean) void;
pub extern fn g_option_context_get_ignore_unknown_options(context: ?*GOptionContext) gboolean;
pub extern fn g_option_context_set_strict_posix(context: ?*GOptionContext, strict_posix: gboolean) void;
pub extern fn g_option_context_get_strict_posix(context: ?*GOptionContext) gboolean;
pub extern fn g_option_context_add_main_entries(context: ?*GOptionContext, entries: [*c]const GOptionEntry, translation_domain: [*c]const gchar) void;
pub extern fn g_option_context_parse(context: ?*GOptionContext, argc: [*c]gint, argv: [*c][*c][*c]gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_option_context_parse_strv(context: ?*GOptionContext, arguments: [*c][*c][*c]gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_option_context_set_translate_func(context: ?*GOptionContext, func: GTranslateFunc, data: gpointer, destroy_notify: GDestroyNotify) void;
pub extern fn g_option_context_set_translation_domain(context: ?*GOptionContext, domain: [*c]const gchar) void;
pub extern fn g_option_context_add_group(context: ?*GOptionContext, group: ?*GOptionGroup) void;
pub extern fn g_option_context_set_main_group(context: ?*GOptionContext, group: ?*GOptionGroup) void;
pub extern fn g_option_context_get_main_group(context: ?*GOptionContext) ?*GOptionGroup;
pub extern fn g_option_context_get_help(context: ?*GOptionContext, main_help: gboolean, group: ?*GOptionGroup) [*c]gchar;
pub extern fn g_option_group_new(name: [*c]const gchar, description: [*c]const gchar, help_description: [*c]const gchar, user_data: gpointer, destroy: GDestroyNotify) ?*GOptionGroup;
pub extern fn g_option_group_set_parse_hooks(group: ?*GOptionGroup, pre_parse_func: GOptionParseFunc, post_parse_func: GOptionParseFunc) void;
pub extern fn g_option_group_set_error_hook(group: ?*GOptionGroup, error_func: GOptionErrorFunc) void;
pub extern fn g_option_group_free(group: ?*GOptionGroup) void;
pub extern fn g_option_group_ref(group: ?*GOptionGroup) ?*GOptionGroup;
pub extern fn g_option_group_unref(group: ?*GOptionGroup) void;
pub extern fn g_option_group_add_entries(group: ?*GOptionGroup, entries: [*c]const GOptionEntry) void;
pub extern fn g_option_group_set_translate_func(group: ?*GOptionGroup, func: GTranslateFunc, data: gpointer, destroy_notify: GDestroyNotify) void;
pub extern fn g_option_group_set_translation_domain(group: ?*GOptionGroup, domain: [*c]const gchar) void;
pub const struct__GPatternSpec = opaque {};
pub const GPatternSpec = struct__GPatternSpec;
pub extern fn g_pattern_spec_new(pattern: [*c]const gchar) ?*GPatternSpec;
pub extern fn g_pattern_spec_free(pspec: ?*GPatternSpec) void;
pub extern fn g_pattern_spec_copy(pspec: ?*GPatternSpec) ?*GPatternSpec;
pub extern fn g_pattern_spec_equal(pspec1: ?*GPatternSpec, pspec2: ?*GPatternSpec) gboolean;
pub extern fn g_pattern_spec_match(pspec: ?*GPatternSpec, string_length: gsize, string: [*c]const gchar, string_reversed: [*c]const gchar) gboolean;
pub extern fn g_pattern_spec_match_string(pspec: ?*GPatternSpec, string: [*c]const gchar) gboolean;
pub extern fn g_pattern_match(pspec: ?*GPatternSpec, string_length: guint, string: [*c]const gchar, string_reversed: [*c]const gchar) gboolean;
pub extern fn g_pattern_match_string(pspec: ?*GPatternSpec, string: [*c]const gchar) gboolean;
pub extern fn g_pattern_match_simple(pattern: [*c]const gchar, string: [*c]const gchar) gboolean;
pub extern fn g_spaced_primes_closest(num: guint) guint;
pub extern fn g_qsort_with_data(pbase: gconstpointer, total_elems: gint, size: gsize, compare_func: GCompareDataFunc, user_data: gpointer) void;
pub const struct__GQueue = extern struct {
    head: [*c]GList,
    tail: [*c]GList,
    length: guint,
};
pub const GQueue = struct__GQueue;
pub extern fn g_queue_new() [*c]GQueue;
pub extern fn g_queue_free(queue: [*c]GQueue) void;
pub extern fn g_queue_free_full(queue: [*c]GQueue, free_func: GDestroyNotify) void;
pub extern fn g_queue_init(queue: [*c]GQueue) void;
pub extern fn g_queue_clear(queue: [*c]GQueue) void;
pub extern fn g_queue_is_empty(queue: [*c]GQueue) gboolean;
pub extern fn g_queue_clear_full(queue: [*c]GQueue, free_func: GDestroyNotify) void;
pub extern fn g_queue_get_length(queue: [*c]GQueue) guint;
pub extern fn g_queue_reverse(queue: [*c]GQueue) void;
pub extern fn g_queue_copy(queue: [*c]GQueue) [*c]GQueue;
pub extern fn g_queue_foreach(queue: [*c]GQueue, func: GFunc, user_data: gpointer) void;
pub extern fn g_queue_find(queue: [*c]GQueue, data: gconstpointer) [*c]GList;
pub extern fn g_queue_find_custom(queue: [*c]GQueue, data: gconstpointer, func: GCompareFunc) [*c]GList;
pub extern fn g_queue_sort(queue: [*c]GQueue, compare_func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_queue_push_head(queue: [*c]GQueue, data: gpointer) void;
pub extern fn g_queue_push_tail(queue: [*c]GQueue, data: gpointer) void;
pub extern fn g_queue_push_nth(queue: [*c]GQueue, data: gpointer, n: gint) void;
pub extern fn g_queue_pop_head(queue: [*c]GQueue) gpointer;
pub extern fn g_queue_pop_tail(queue: [*c]GQueue) gpointer;
pub extern fn g_queue_pop_nth(queue: [*c]GQueue, n: guint) gpointer;
pub extern fn g_queue_peek_head(queue: [*c]GQueue) gpointer;
pub extern fn g_queue_peek_tail(queue: [*c]GQueue) gpointer;
pub extern fn g_queue_peek_nth(queue: [*c]GQueue, n: guint) gpointer;
pub extern fn g_queue_index(queue: [*c]GQueue, data: gconstpointer) gint;
pub extern fn g_queue_remove(queue: [*c]GQueue, data: gconstpointer) gboolean;
pub extern fn g_queue_remove_all(queue: [*c]GQueue, data: gconstpointer) guint;
pub extern fn g_queue_insert_before(queue: [*c]GQueue, sibling: [*c]GList, data: gpointer) void;
pub extern fn g_queue_insert_before_link(queue: [*c]GQueue, sibling: [*c]GList, link_: [*c]GList) void;
pub extern fn g_queue_insert_after(queue: [*c]GQueue, sibling: [*c]GList, data: gpointer) void;
pub extern fn g_queue_insert_after_link(queue: [*c]GQueue, sibling: [*c]GList, link_: [*c]GList) void;
pub extern fn g_queue_insert_sorted(queue: [*c]GQueue, data: gpointer, func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_queue_push_head_link(queue: [*c]GQueue, link_: [*c]GList) void;
pub extern fn g_queue_push_tail_link(queue: [*c]GQueue, link_: [*c]GList) void;
pub extern fn g_queue_push_nth_link(queue: [*c]GQueue, n: gint, link_: [*c]GList) void;
pub extern fn g_queue_pop_head_link(queue: [*c]GQueue) [*c]GList;
pub extern fn g_queue_pop_tail_link(queue: [*c]GQueue) [*c]GList;
pub extern fn g_queue_pop_nth_link(queue: [*c]GQueue, n: guint) [*c]GList;
pub extern fn g_queue_peek_head_link(queue: [*c]GQueue) [*c]GList;
pub extern fn g_queue_peek_tail_link(queue: [*c]GQueue) [*c]GList;
pub extern fn g_queue_peek_nth_link(queue: [*c]GQueue, n: guint) [*c]GList;
pub extern fn g_queue_link_index(queue: [*c]GQueue, link_: [*c]GList) gint;
pub extern fn g_queue_unlink(queue: [*c]GQueue, link_: [*c]GList) void;
pub extern fn g_queue_delete_link(queue: [*c]GQueue, link_: [*c]GList) void;
pub const struct__GRand = opaque {};
pub const GRand = struct__GRand;
pub extern fn g_rand_new_with_seed(seed: guint32) ?*GRand;
pub extern fn g_rand_new_with_seed_array(seed: [*c]const guint32, seed_length: guint) ?*GRand;
pub extern fn g_rand_new() ?*GRand;
pub extern fn g_rand_free(rand_: ?*GRand) void;
pub extern fn g_rand_copy(rand_: ?*GRand) ?*GRand;
pub extern fn g_rand_set_seed(rand_: ?*GRand, seed: guint32) void;
pub extern fn g_rand_set_seed_array(rand_: ?*GRand, seed: [*c]const guint32, seed_length: guint) void;
pub extern fn g_rand_int(rand_: ?*GRand) guint32;
pub extern fn g_rand_int_range(rand_: ?*GRand, begin: gint32, end: gint32) gint32;
pub extern fn g_rand_double(rand_: ?*GRand) gdouble;
pub extern fn g_rand_double_range(rand_: ?*GRand, begin: gdouble, end: gdouble) gdouble;
pub extern fn g_random_set_seed(seed: guint32) void;
pub extern fn g_random_int() guint32;
pub extern fn g_random_int_range(begin: gint32, end: gint32) gint32;
pub extern fn g_random_double() gdouble;
pub extern fn g_random_double_range(begin: gdouble, end: gdouble) gdouble;
pub extern fn g_rc_box_alloc(block_size: gsize) gpointer;
pub extern fn g_rc_box_alloc0(block_size: gsize) gpointer;
pub extern fn g_rc_box_dup(block_size: gsize, mem_block: gconstpointer) gpointer;
pub extern fn g_rc_box_acquire(mem_block: gpointer) gpointer;
pub extern fn g_rc_box_release(mem_block: gpointer) void;
pub extern fn g_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify) void;
pub extern fn g_rc_box_get_size(mem_block: gpointer) gsize;
pub extern fn g_atomic_rc_box_alloc(block_size: gsize) gpointer;
pub extern fn g_atomic_rc_box_alloc0(block_size: gsize) gpointer;
pub extern fn g_atomic_rc_box_dup(block_size: gsize, mem_block: gconstpointer) gpointer;
pub extern fn g_atomic_rc_box_acquire(mem_block: gpointer) gpointer;
pub extern fn g_atomic_rc_box_release(mem_block: gpointer) void;
pub extern fn g_atomic_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify) void;
pub extern fn g_atomic_rc_box_get_size(mem_block: gpointer) gsize;
pub extern fn g_ref_count_init(rc: [*c]grefcount) void;
pub extern fn g_ref_count_inc(rc: [*c]grefcount) void;
pub extern fn g_ref_count_dec(rc: [*c]grefcount) gboolean;
pub extern fn g_ref_count_compare(rc: [*c]grefcount, val: gint) gboolean;
pub extern fn g_atomic_ref_count_init(arc: [*c]gatomicrefcount) void;
pub extern fn g_atomic_ref_count_inc(arc: [*c]gatomicrefcount) void;
pub extern fn g_atomic_ref_count_dec(arc: [*c]gatomicrefcount) gboolean;
pub extern fn g_atomic_ref_count_compare(arc: [*c]gatomicrefcount, val: gint) gboolean;
pub extern fn g_ref_string_new(str: [*c]const u8) [*c]u8;
pub extern fn g_ref_string_new_len(str: [*c]const u8, len: gssize) [*c]u8;
pub extern fn g_ref_string_new_intern(str: [*c]const u8) [*c]u8;
pub extern fn g_ref_string_acquire(str: [*c]u8) [*c]u8;
pub extern fn g_ref_string_release(str: [*c]u8) void;
pub extern fn g_ref_string_length(str: [*c]u8) gsize;
pub const GRefString = u8;
pub const G_REGEX_ERROR_COMPILE: c_int = 0;
pub const G_REGEX_ERROR_OPTIMIZE: c_int = 1;
pub const G_REGEX_ERROR_REPLACE: c_int = 2;
pub const G_REGEX_ERROR_MATCH: c_int = 3;
pub const G_REGEX_ERROR_INTERNAL: c_int = 4;
pub const G_REGEX_ERROR_STRAY_BACKSLASH: c_int = 101;
pub const G_REGEX_ERROR_MISSING_CONTROL_CHAR: c_int = 102;
pub const G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: c_int = 103;
pub const G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: c_int = 104;
pub const G_REGEX_ERROR_QUANTIFIER_TOO_BIG: c_int = 105;
pub const G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: c_int = 106;
pub const G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: c_int = 107;
pub const G_REGEX_ERROR_RANGE_OUT_OF_ORDER: c_int = 108;
pub const G_REGEX_ERROR_NOTHING_TO_REPEAT: c_int = 109;
pub const G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: c_int = 112;
pub const G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: c_int = 113;
pub const G_REGEX_ERROR_UNMATCHED_PARENTHESIS: c_int = 114;
pub const G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: c_int = 115;
pub const G_REGEX_ERROR_UNTERMINATED_COMMENT: c_int = 118;
pub const G_REGEX_ERROR_EXPRESSION_TOO_LARGE: c_int = 120;
pub const G_REGEX_ERROR_MEMORY_ERROR: c_int = 121;
pub const G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: c_int = 125;
pub const G_REGEX_ERROR_MALFORMED_CONDITION: c_int = 126;
pub const G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: c_int = 127;
pub const G_REGEX_ERROR_ASSERTION_EXPECTED: c_int = 128;
pub const G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: c_int = 130;
pub const G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: c_int = 131;
pub const G_REGEX_ERROR_HEX_CODE_TOO_LARGE: c_int = 134;
pub const G_REGEX_ERROR_INVALID_CONDITION: c_int = 135;
pub const G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: c_int = 136;
pub const G_REGEX_ERROR_INFINITE_LOOP: c_int = 140;
pub const G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: c_int = 142;
pub const G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: c_int = 143;
pub const G_REGEX_ERROR_MALFORMED_PROPERTY: c_int = 146;
pub const G_REGEX_ERROR_UNKNOWN_PROPERTY: c_int = 147;
pub const G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: c_int = 148;
pub const G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: c_int = 149;
pub const G_REGEX_ERROR_INVALID_OCTAL_VALUE: c_int = 151;
pub const G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: c_int = 154;
pub const G_REGEX_ERROR_DEFINE_REPETION: c_int = 155;
pub const G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: c_int = 156;
pub const G_REGEX_ERROR_MISSING_BACK_REFERENCE: c_int = 157;
pub const G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: c_int = 158;
pub const G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: c_int = 159;
pub const G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: c_int = 160;
pub const G_REGEX_ERROR_NUMBER_TOO_BIG: c_int = 161;
pub const G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: c_int = 162;
pub const G_REGEX_ERROR_MISSING_DIGIT: c_int = 163;
pub const G_REGEX_ERROR_INVALID_DATA_CHARACTER: c_int = 164;
pub const G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: c_int = 165;
pub const G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: c_int = 166;
pub const G_REGEX_ERROR_INVALID_CONTROL_CHAR: c_int = 168;
pub const G_REGEX_ERROR_MISSING_NAME: c_int = 169;
pub const G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: c_int = 171;
pub const G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: c_int = 172;
pub const G_REGEX_ERROR_NAME_TOO_LONG: c_int = 175;
pub const G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: c_int = 176;
pub const GRegexError = c_uint;
pub extern fn g_regex_error_quark() GQuark;
pub const G_REGEX_CASELESS: c_int = 1;
pub const G_REGEX_MULTILINE: c_int = 2;
pub const G_REGEX_DOTALL: c_int = 4;
pub const G_REGEX_EXTENDED: c_int = 8;
pub const G_REGEX_ANCHORED: c_int = 16;
pub const G_REGEX_DOLLAR_ENDONLY: c_int = 32;
pub const G_REGEX_UNGREEDY: c_int = 512;
pub const G_REGEX_RAW: c_int = 2048;
pub const G_REGEX_NO_AUTO_CAPTURE: c_int = 4096;
pub const G_REGEX_OPTIMIZE: c_int = 8192;
pub const G_REGEX_FIRSTLINE: c_int = 262144;
pub const G_REGEX_DUPNAMES: c_int = 524288;
pub const G_REGEX_NEWLINE_CR: c_int = 1048576;
pub const G_REGEX_NEWLINE_LF: c_int = 2097152;
pub const G_REGEX_NEWLINE_CRLF: c_int = 3145728;
pub const G_REGEX_NEWLINE_ANYCRLF: c_int = 5242880;
pub const G_REGEX_BSR_ANYCRLF: c_int = 8388608;
pub const G_REGEX_JAVASCRIPT_COMPAT: c_int = 33554432;
pub const GRegexCompileFlags = c_uint;
pub const G_REGEX_MATCH_ANCHORED: c_int = 16;
pub const G_REGEX_MATCH_NOTBOL: c_int = 128;
pub const G_REGEX_MATCH_NOTEOL: c_int = 256;
pub const G_REGEX_MATCH_NOTEMPTY: c_int = 1024;
pub const G_REGEX_MATCH_PARTIAL: c_int = 32768;
pub const G_REGEX_MATCH_NEWLINE_CR: c_int = 1048576;
pub const G_REGEX_MATCH_NEWLINE_LF: c_int = 2097152;
pub const G_REGEX_MATCH_NEWLINE_CRLF: c_int = 3145728;
pub const G_REGEX_MATCH_NEWLINE_ANY: c_int = 4194304;
pub const G_REGEX_MATCH_NEWLINE_ANYCRLF: c_int = 5242880;
pub const G_REGEX_MATCH_BSR_ANYCRLF: c_int = 8388608;
pub const G_REGEX_MATCH_BSR_ANY: c_int = 16777216;
pub const G_REGEX_MATCH_PARTIAL_SOFT: c_int = 32768;
pub const G_REGEX_MATCH_PARTIAL_HARD: c_int = 134217728;
pub const G_REGEX_MATCH_NOTEMPTY_ATSTART: c_int = 268435456;
pub const GRegexMatchFlags = c_uint;
pub const struct__GRegex = opaque {};
pub const GRegex = struct__GRegex;
pub const struct__GMatchInfo = opaque {};
pub const GMatchInfo = struct__GMatchInfo;
pub const GRegexEvalCallback = ?fn (?*const GMatchInfo, [*c]GString, gpointer) callconv(.C) gboolean;
pub extern fn g_regex_new(pattern: [*c]const gchar, compile_options: GRegexCompileFlags, match_options: GRegexMatchFlags, @"error": [*c][*c]GError) ?*GRegex;
pub extern fn g_regex_ref(regex: ?*GRegex) ?*GRegex;
pub extern fn g_regex_unref(regex: ?*GRegex) void;
pub extern fn g_regex_get_pattern(regex: ?*const GRegex) [*c]const gchar;
pub extern fn g_regex_get_max_backref(regex: ?*const GRegex) gint;
pub extern fn g_regex_get_capture_count(regex: ?*const GRegex) gint;
pub extern fn g_regex_get_has_cr_or_lf(regex: ?*const GRegex) gboolean;
pub extern fn g_regex_get_max_lookbehind(regex: ?*const GRegex) gint;
pub extern fn g_regex_get_string_number(regex: ?*const GRegex, name: [*c]const gchar) gint;
pub extern fn g_regex_escape_string(string: [*c]const gchar, length: gint) [*c]gchar;
pub extern fn g_regex_escape_nul(string: [*c]const gchar, length: gint) [*c]gchar;
pub extern fn g_regex_get_compile_flags(regex: ?*const GRegex) GRegexCompileFlags;
pub extern fn g_regex_get_match_flags(regex: ?*const GRegex) GRegexMatchFlags;
pub extern fn g_regex_match_simple(pattern: [*c]const gchar, string: [*c]const gchar, compile_options: GRegexCompileFlags, match_options: GRegexMatchFlags) gboolean;
pub extern fn g_regex_match(regex: ?*const GRegex, string: [*c]const gchar, match_options: GRegexMatchFlags, match_info: [*c]?*GMatchInfo) gboolean;
pub extern fn g_regex_match_full(regex: ?*const GRegex, string: [*c]const gchar, string_len: gssize, start_position: gint, match_options: GRegexMatchFlags, match_info: [*c]?*GMatchInfo, @"error": [*c][*c]GError) gboolean;
pub extern fn g_regex_match_all(regex: ?*const GRegex, string: [*c]const gchar, match_options: GRegexMatchFlags, match_info: [*c]?*GMatchInfo) gboolean;
pub extern fn g_regex_match_all_full(regex: ?*const GRegex, string: [*c]const gchar, string_len: gssize, start_position: gint, match_options: GRegexMatchFlags, match_info: [*c]?*GMatchInfo, @"error": [*c][*c]GError) gboolean;
pub extern fn g_regex_split_simple(pattern: [*c]const gchar, string: [*c]const gchar, compile_options: GRegexCompileFlags, match_options: GRegexMatchFlags) [*c][*c]gchar;
pub extern fn g_regex_split(regex: ?*const GRegex, string: [*c]const gchar, match_options: GRegexMatchFlags) [*c][*c]gchar;
pub extern fn g_regex_split_full(regex: ?*const GRegex, string: [*c]const gchar, string_len: gssize, start_position: gint, match_options: GRegexMatchFlags, max_tokens: gint, @"error": [*c][*c]GError) [*c][*c]gchar;
pub extern fn g_regex_replace(regex: ?*const GRegex, string: [*c]const gchar, string_len: gssize, start_position: gint, replacement: [*c]const gchar, match_options: GRegexMatchFlags, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_regex_replace_literal(regex: ?*const GRegex, string: [*c]const gchar, string_len: gssize, start_position: gint, replacement: [*c]const gchar, match_options: GRegexMatchFlags, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_regex_replace_eval(regex: ?*const GRegex, string: [*c]const gchar, string_len: gssize, start_position: gint, match_options: GRegexMatchFlags, eval: GRegexEvalCallback, user_data: gpointer, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_regex_check_replacement(replacement: [*c]const gchar, has_references: [*c]gboolean, @"error": [*c][*c]GError) gboolean;
pub extern fn g_match_info_get_regex(match_info: ?*const GMatchInfo) ?*GRegex;
pub extern fn g_match_info_get_string(match_info: ?*const GMatchInfo) [*c]const gchar;
pub extern fn g_match_info_ref(match_info: ?*GMatchInfo) ?*GMatchInfo;
pub extern fn g_match_info_unref(match_info: ?*GMatchInfo) void;
pub extern fn g_match_info_free(match_info: ?*GMatchInfo) void;
pub extern fn g_match_info_next(match_info: ?*GMatchInfo, @"error": [*c][*c]GError) gboolean;
pub extern fn g_match_info_matches(match_info: ?*const GMatchInfo) gboolean;
pub extern fn g_match_info_get_match_count(match_info: ?*const GMatchInfo) gint;
pub extern fn g_match_info_is_partial_match(match_info: ?*const GMatchInfo) gboolean;
pub extern fn g_match_info_expand_references(match_info: ?*const GMatchInfo, string_to_expand: [*c]const gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_match_info_fetch(match_info: ?*const GMatchInfo, match_num: gint) [*c]gchar;
pub extern fn g_match_info_fetch_pos(match_info: ?*const GMatchInfo, match_num: gint, start_pos: [*c]gint, end_pos: [*c]gint) gboolean;
pub extern fn g_match_info_fetch_named(match_info: ?*const GMatchInfo, name: [*c]const gchar) [*c]gchar;
pub extern fn g_match_info_fetch_named_pos(match_info: ?*const GMatchInfo, name: [*c]const gchar, start_pos: [*c]gint, end_pos: [*c]gint) gboolean;
pub extern fn g_match_info_fetch_all(match_info: ?*const GMatchInfo) [*c][*c]gchar; // /usr/include/glib-2.0/glib/gscanner.h:138:10: warning: struct demoted to opaque type - has bitfield
pub const struct__GScannerConfig = opaque {};
pub const GScannerConfig = struct__GScannerConfig;
pub const union__GTokenValue = extern union {
    v_symbol: gpointer,
    v_identifier: [*c]gchar,
    v_binary: gulong,
    v_octal: gulong,
    v_int: gulong,
    v_int64: guint64,
    v_float: gdouble,
    v_hex: gulong,
    v_string: [*c]gchar,
    v_comment: [*c]gchar,
    v_char: guchar,
    v_error: guint,
};
pub const GTokenValue = union__GTokenValue;
pub const GScanner = struct__GScanner;
pub const GScannerMsgFunc = ?fn ([*c]GScanner, [*c]gchar, gboolean) callconv(.C) void;
pub const struct__GScanner = extern struct {
    user_data: gpointer,
    max_parse_errors: guint,
    parse_errors: guint,
    input_name: [*c]const gchar,
    qdata: ?*GData,
    config: ?*GScannerConfig,
    token: GTokenType,
    value: GTokenValue,
    line: guint,
    position: guint,
    next_token: GTokenType,
    next_value: GTokenValue,
    next_line: guint,
    next_position: guint,
    symbol_table: ?*GHashTable,
    input_fd: gint,
    text: [*c]const gchar,
    text_end: [*c]const gchar,
    buffer: [*c]gchar,
    scope_id: guint,
    msg_handler: GScannerMsgFunc,
};
pub const G_ERR_UNKNOWN: c_int = 0;
pub const G_ERR_UNEXP_EOF: c_int = 1;
pub const G_ERR_UNEXP_EOF_IN_STRING: c_int = 2;
pub const G_ERR_UNEXP_EOF_IN_COMMENT: c_int = 3;
pub const G_ERR_NON_DIGIT_IN_CONST: c_int = 4;
pub const G_ERR_DIGIT_RADIX: c_int = 5;
pub const G_ERR_FLOAT_RADIX: c_int = 6;
pub const G_ERR_FLOAT_MALFORMED: c_int = 7;
pub const GErrorType = c_uint;
pub const G_TOKEN_EOF: c_int = 0;
pub const G_TOKEN_LEFT_PAREN: c_int = 40;
pub const G_TOKEN_RIGHT_PAREN: c_int = 41;
pub const G_TOKEN_LEFT_CURLY: c_int = 123;
pub const G_TOKEN_RIGHT_CURLY: c_int = 125;
pub const G_TOKEN_LEFT_BRACE: c_int = 91;
pub const G_TOKEN_RIGHT_BRACE: c_int = 93;
pub const G_TOKEN_EQUAL_SIGN: c_int = 61;
pub const G_TOKEN_COMMA: c_int = 44;
pub const G_TOKEN_NONE: c_int = 256;
pub const G_TOKEN_ERROR: c_int = 257;
pub const G_TOKEN_CHAR: c_int = 258;
pub const G_TOKEN_BINARY: c_int = 259;
pub const G_TOKEN_OCTAL: c_int = 260;
pub const G_TOKEN_INT: c_int = 261;
pub const G_TOKEN_HEX: c_int = 262;
pub const G_TOKEN_FLOAT: c_int = 263;
pub const G_TOKEN_STRING: c_int = 264;
pub const G_TOKEN_SYMBOL: c_int = 265;
pub const G_TOKEN_IDENTIFIER: c_int = 266;
pub const G_TOKEN_IDENTIFIER_NULL: c_int = 267;
pub const G_TOKEN_COMMENT_SINGLE: c_int = 268;
pub const G_TOKEN_COMMENT_MULTI: c_int = 269;
pub const G_TOKEN_LAST: c_int = 270;
pub const GTokenType = c_uint;
pub extern fn g_scanner_new(config_templ: ?*const GScannerConfig) [*c]GScanner;
pub extern fn g_scanner_destroy(scanner: [*c]GScanner) void;
pub extern fn g_scanner_input_file(scanner: [*c]GScanner, input_fd: gint) void;
pub extern fn g_scanner_sync_file_offset(scanner: [*c]GScanner) void;
pub extern fn g_scanner_input_text(scanner: [*c]GScanner, text: [*c]const gchar, text_len: guint) void;
pub extern fn g_scanner_get_next_token(scanner: [*c]GScanner) GTokenType;
pub extern fn g_scanner_peek_next_token(scanner: [*c]GScanner) GTokenType;
pub extern fn g_scanner_cur_token(scanner: [*c]GScanner) GTokenType;
pub extern fn g_scanner_cur_value(scanner: [*c]GScanner) GTokenValue;
pub extern fn g_scanner_cur_line(scanner: [*c]GScanner) guint;
pub extern fn g_scanner_cur_position(scanner: [*c]GScanner) guint;
pub extern fn g_scanner_eof(scanner: [*c]GScanner) gboolean;
pub extern fn g_scanner_set_scope(scanner: [*c]GScanner, scope_id: guint) guint;
pub extern fn g_scanner_scope_add_symbol(scanner: [*c]GScanner, scope_id: guint, symbol: [*c]const gchar, value: gpointer) void;
pub extern fn g_scanner_scope_remove_symbol(scanner: [*c]GScanner, scope_id: guint, symbol: [*c]const gchar) void;
pub extern fn g_scanner_scope_lookup_symbol(scanner: [*c]GScanner, scope_id: guint, symbol: [*c]const gchar) gpointer;
pub extern fn g_scanner_scope_foreach_symbol(scanner: [*c]GScanner, scope_id: guint, func: GHFunc, user_data: gpointer) void;
pub extern fn g_scanner_lookup_symbol(scanner: [*c]GScanner, symbol: [*c]const gchar) gpointer;
pub extern fn g_scanner_unexp_token(scanner: [*c]GScanner, expected_token: GTokenType, identifier_spec: [*c]const gchar, symbol_spec: [*c]const gchar, symbol_name: [*c]const gchar, message: [*c]const gchar, is_error: gint) void;
pub extern fn g_scanner_error(scanner: [*c]GScanner, format: [*c]const gchar, ...) void;
pub extern fn g_scanner_warn(scanner: [*c]GScanner, format: [*c]const gchar, ...) void;
pub const struct__GSequence = opaque {};
pub const GSequence = struct__GSequence;
pub const struct__GSequenceNode = opaque {};
pub const GSequenceIter = struct__GSequenceNode;
pub const GSequenceIterCompareFunc = ?fn (?*GSequenceIter, ?*GSequenceIter, gpointer) callconv(.C) gint;
pub extern fn g_sequence_new(data_destroy: GDestroyNotify) ?*GSequence;
pub extern fn g_sequence_free(seq: ?*GSequence) void;
pub extern fn g_sequence_get_length(seq: ?*GSequence) gint;
pub extern fn g_sequence_foreach(seq: ?*GSequence, func: GFunc, user_data: gpointer) void;
pub extern fn g_sequence_foreach_range(begin: ?*GSequenceIter, end: ?*GSequenceIter, func: GFunc, user_data: gpointer) void;
pub extern fn g_sequence_sort(seq: ?*GSequence, cmp_func: GCompareDataFunc, cmp_data: gpointer) void;
pub extern fn g_sequence_sort_iter(seq: ?*GSequence, cmp_func: GSequenceIterCompareFunc, cmp_data: gpointer) void;
pub extern fn g_sequence_is_empty(seq: ?*GSequence) gboolean;
pub extern fn g_sequence_get_begin_iter(seq: ?*GSequence) ?*GSequenceIter;
pub extern fn g_sequence_get_end_iter(seq: ?*GSequence) ?*GSequenceIter;
pub extern fn g_sequence_get_iter_at_pos(seq: ?*GSequence, pos: gint) ?*GSequenceIter;
pub extern fn g_sequence_append(seq: ?*GSequence, data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_prepend(seq: ?*GSequence, data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_insert_before(iter: ?*GSequenceIter, data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_move(src: ?*GSequenceIter, dest: ?*GSequenceIter) void;
pub extern fn g_sequence_swap(a: ?*GSequenceIter, b: ?*GSequenceIter) void;
pub extern fn g_sequence_insert_sorted(seq: ?*GSequence, data: gpointer, cmp_func: GCompareDataFunc, cmp_data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_insert_sorted_iter(seq: ?*GSequence, data: gpointer, iter_cmp: GSequenceIterCompareFunc, cmp_data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_sort_changed(iter: ?*GSequenceIter, cmp_func: GCompareDataFunc, cmp_data: gpointer) void;
pub extern fn g_sequence_sort_changed_iter(iter: ?*GSequenceIter, iter_cmp: GSequenceIterCompareFunc, cmp_data: gpointer) void;
pub extern fn g_sequence_remove(iter: ?*GSequenceIter) void;
pub extern fn g_sequence_remove_range(begin: ?*GSequenceIter, end: ?*GSequenceIter) void;
pub extern fn g_sequence_move_range(dest: ?*GSequenceIter, begin: ?*GSequenceIter, end: ?*GSequenceIter) void;
pub extern fn g_sequence_search(seq: ?*GSequence, data: gpointer, cmp_func: GCompareDataFunc, cmp_data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_search_iter(seq: ?*GSequence, data: gpointer, iter_cmp: GSequenceIterCompareFunc, cmp_data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_lookup(seq: ?*GSequence, data: gpointer, cmp_func: GCompareDataFunc, cmp_data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_lookup_iter(seq: ?*GSequence, data: gpointer, iter_cmp: GSequenceIterCompareFunc, cmp_data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_get(iter: ?*GSequenceIter) gpointer;
pub extern fn g_sequence_set(iter: ?*GSequenceIter, data: gpointer) void;
pub extern fn g_sequence_iter_is_begin(iter: ?*GSequenceIter) gboolean;
pub extern fn g_sequence_iter_is_end(iter: ?*GSequenceIter) gboolean;
pub extern fn g_sequence_iter_next(iter: ?*GSequenceIter) ?*GSequenceIter;
pub extern fn g_sequence_iter_prev(iter: ?*GSequenceIter) ?*GSequenceIter;
pub extern fn g_sequence_iter_get_position(iter: ?*GSequenceIter) gint;
pub extern fn g_sequence_iter_move(iter: ?*GSequenceIter, delta: gint) ?*GSequenceIter;
pub extern fn g_sequence_iter_get_sequence(iter: ?*GSequenceIter) ?*GSequence;
pub extern fn g_sequence_iter_compare(a: ?*GSequenceIter, b: ?*GSequenceIter) gint;
pub extern fn g_sequence_range_get_midpoint(begin: ?*GSequenceIter, end: ?*GSequenceIter) ?*GSequenceIter;
pub const G_SHELL_ERROR_BAD_QUOTING: c_int = 0;
pub const G_SHELL_ERROR_EMPTY_STRING: c_int = 1;
pub const G_SHELL_ERROR_FAILED: c_int = 2;
pub const GShellError = c_uint;
pub extern fn g_shell_error_quark() GQuark;
pub extern fn g_shell_quote(unquoted_string: [*c]const gchar) [*c]gchar;
pub extern fn g_shell_unquote(quoted_string: [*c]const gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_shell_parse_argv(command_line: [*c]const gchar, argcp: [*c]gint, argvp: [*c][*c][*c]gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_slice_alloc(block_size: gsize) gpointer;
pub extern fn g_slice_alloc0(block_size: gsize) gpointer;
pub extern fn g_slice_copy(block_size: gsize, mem_block: gconstpointer) gpointer;
pub extern fn g_slice_free1(block_size: gsize, mem_block: gpointer) void;
pub extern fn g_slice_free_chain_with_offset(block_size: gsize, mem_chain: gpointer, next_offset: gsize) void;
pub const G_SLICE_CONFIG_ALWAYS_MALLOC: c_int = 1;
pub const G_SLICE_CONFIG_BYPASS_MAGAZINES: c_int = 2;
pub const G_SLICE_CONFIG_WORKING_SET_MSECS: c_int = 3;
pub const G_SLICE_CONFIG_COLOR_INCREMENT: c_int = 4;
pub const G_SLICE_CONFIG_CHUNK_SIZES: c_int = 5;
pub const G_SLICE_CONFIG_CONTENTION_COUNTER: c_int = 6;
pub const GSliceConfig = c_uint;
pub extern fn g_slice_set_config(ckey: GSliceConfig, value: gint64) void;
pub extern fn g_slice_get_config(ckey: GSliceConfig) gint64;
pub extern fn g_slice_get_config_state(ckey: GSliceConfig, address: gint64, n_values: [*c]guint) [*c]gint64;
pub const G_SPAWN_ERROR_FORK: c_int = 0;
pub const G_SPAWN_ERROR_READ: c_int = 1;
pub const G_SPAWN_ERROR_CHDIR: c_int = 2;
pub const G_SPAWN_ERROR_ACCES: c_int = 3;
pub const G_SPAWN_ERROR_PERM: c_int = 4;
pub const G_SPAWN_ERROR_TOO_BIG: c_int = 5;
pub const G_SPAWN_ERROR_2BIG: c_int = 5;
pub const G_SPAWN_ERROR_NOEXEC: c_int = 6;
pub const G_SPAWN_ERROR_NAMETOOLONG: c_int = 7;
pub const G_SPAWN_ERROR_NOENT: c_int = 8;
pub const G_SPAWN_ERROR_NOMEM: c_int = 9;
pub const G_SPAWN_ERROR_NOTDIR: c_int = 10;
pub const G_SPAWN_ERROR_LOOP: c_int = 11;
pub const G_SPAWN_ERROR_TXTBUSY: c_int = 12;
pub const G_SPAWN_ERROR_IO: c_int = 13;
pub const G_SPAWN_ERROR_NFILE: c_int = 14;
pub const G_SPAWN_ERROR_MFILE: c_int = 15;
pub const G_SPAWN_ERROR_INVAL: c_int = 16;
pub const G_SPAWN_ERROR_ISDIR: c_int = 17;
pub const G_SPAWN_ERROR_LIBBAD: c_int = 18;
pub const G_SPAWN_ERROR_FAILED: c_int = 19;
pub const GSpawnError = c_uint;
pub const GSpawnChildSetupFunc = ?fn (gpointer) callconv(.C) void;
pub const G_SPAWN_DEFAULT: c_int = 0;
pub const G_SPAWN_LEAVE_DESCRIPTORS_OPEN: c_int = 1;
pub const G_SPAWN_DO_NOT_REAP_CHILD: c_int = 2;
pub const G_SPAWN_SEARCH_PATH: c_int = 4;
pub const G_SPAWN_STDOUT_TO_DEV_NULL: c_int = 8;
pub const G_SPAWN_STDERR_TO_DEV_NULL: c_int = 16;
pub const G_SPAWN_CHILD_INHERITS_STDIN: c_int = 32;
pub const G_SPAWN_FILE_AND_ARGV_ZERO: c_int = 64;
pub const G_SPAWN_SEARCH_PATH_FROM_ENVP: c_int = 128;
pub const G_SPAWN_CLOEXEC_PIPES: c_int = 256;
pub const GSpawnFlags = c_uint;
pub extern fn g_spawn_error_quark() GQuark;
pub extern fn g_spawn_exit_error_quark() GQuark;
pub extern fn g_spawn_async(working_directory: [*c]const gchar, argv: [*c][*c]gchar, envp: [*c][*c]gchar, flags: GSpawnFlags, child_setup: GSpawnChildSetupFunc, user_data: gpointer, child_pid: [*c]GPid, @"error": [*c][*c]GError) gboolean;
pub extern fn g_spawn_async_with_pipes(working_directory: [*c]const gchar, argv: [*c][*c]gchar, envp: [*c][*c]gchar, flags: GSpawnFlags, child_setup: GSpawnChildSetupFunc, user_data: gpointer, child_pid: [*c]GPid, standard_input: [*c]gint, standard_output: [*c]gint, standard_error: [*c]gint, @"error": [*c][*c]GError) gboolean;
pub extern fn g_spawn_async_with_pipes_and_fds(working_directory: [*c]const gchar, argv: [*c]const [*c]const gchar, envp: [*c]const [*c]const gchar, flags: GSpawnFlags, child_setup: GSpawnChildSetupFunc, user_data: gpointer, stdin_fd: gint, stdout_fd: gint, stderr_fd: gint, source_fds: [*c]const gint, target_fds: [*c]const gint, n_fds: gsize, child_pid_out: [*c]GPid, stdin_pipe_out: [*c]gint, stdout_pipe_out: [*c]gint, stderr_pipe_out: [*c]gint, @"error": [*c][*c]GError) gboolean;
pub extern fn g_spawn_async_with_fds(working_directory: [*c]const gchar, argv: [*c][*c]gchar, envp: [*c][*c]gchar, flags: GSpawnFlags, child_setup: GSpawnChildSetupFunc, user_data: gpointer, child_pid: [*c]GPid, stdin_fd: gint, stdout_fd: gint, stderr_fd: gint, @"error": [*c][*c]GError) gboolean;
pub extern fn g_spawn_sync(working_directory: [*c]const gchar, argv: [*c][*c]gchar, envp: [*c][*c]gchar, flags: GSpawnFlags, child_setup: GSpawnChildSetupFunc, user_data: gpointer, standard_output: [*c][*c]gchar, standard_error: [*c][*c]gchar, wait_status: [*c]gint, @"error": [*c][*c]GError) gboolean;
pub extern fn g_spawn_command_line_sync(command_line: [*c]const gchar, standard_output: [*c][*c]gchar, standard_error: [*c][*c]gchar, wait_status: [*c]gint, @"error": [*c][*c]GError) gboolean;
pub extern fn g_spawn_command_line_async(command_line: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_spawn_check_wait_status(wait_status: gint, @"error": [*c][*c]GError) gboolean;
pub extern fn g_spawn_check_exit_status(wait_status: gint, @"error": [*c][*c]GError) gboolean;
pub extern fn g_spawn_close_pid(pid: GPid) void;
pub const G_ASCII_ALNUM: c_int = 1;
pub const G_ASCII_ALPHA: c_int = 2;
pub const G_ASCII_CNTRL: c_int = 4;
pub const G_ASCII_DIGIT: c_int = 8;
pub const G_ASCII_GRAPH: c_int = 16;
pub const G_ASCII_LOWER: c_int = 32;
pub const G_ASCII_PRINT: c_int = 64;
pub const G_ASCII_PUNCT: c_int = 128;
pub const G_ASCII_SPACE: c_int = 256;
pub const G_ASCII_UPPER: c_int = 512;
pub const G_ASCII_XDIGIT: c_int = 1024;
pub const GAsciiType = c_uint;
pub extern const g_ascii_table: [*c]const guint16;
pub extern fn g_ascii_tolower(c: gchar) gchar;
pub extern fn g_ascii_toupper(c: gchar) gchar;
pub extern fn g_ascii_digit_value(c: gchar) gint;
pub extern fn g_ascii_xdigit_value(c: gchar) gint;
pub extern fn g_strdelimit(string: [*c]gchar, delimiters: [*c]const gchar, new_delimiter: gchar) [*c]gchar;
pub extern fn g_strcanon(string: [*c]gchar, valid_chars: [*c]const gchar, substitutor: gchar) [*c]gchar;
pub extern fn g_strerror(errnum: gint) [*c]const gchar;
pub extern fn g_strsignal(signum: gint) [*c]const gchar;
pub extern fn g_strreverse(string: [*c]gchar) [*c]gchar;
pub extern fn g_strlcpy(dest: [*c]gchar, src: [*c]const gchar, dest_size: gsize) gsize;
pub extern fn g_strlcat(dest: [*c]gchar, src: [*c]const gchar, dest_size: gsize) gsize;
pub extern fn g_strstr_len(haystack: [*c]const gchar, haystack_len: gssize, needle: [*c]const gchar) [*c]gchar;
pub extern fn g_strrstr(haystack: [*c]const gchar, needle: [*c]const gchar) [*c]gchar;
pub extern fn g_strrstr_len(haystack: [*c]const gchar, haystack_len: gssize, needle: [*c]const gchar) [*c]gchar;
pub extern fn g_str_has_suffix(str: [*c]const gchar, suffix: [*c]const gchar) gboolean;
pub extern fn g_str_has_prefix(str: [*c]const gchar, prefix: [*c]const gchar) gboolean;
pub extern fn g_strtod(nptr: [*c]const gchar, endptr: [*c][*c]gchar) gdouble;
pub extern fn g_ascii_strtod(nptr: [*c]const gchar, endptr: [*c][*c]gchar) gdouble;
pub extern fn g_ascii_strtoull(nptr: [*c]const gchar, endptr: [*c][*c]gchar, base: guint) guint64;
pub extern fn g_ascii_strtoll(nptr: [*c]const gchar, endptr: [*c][*c]gchar, base: guint) gint64;
pub extern fn g_ascii_dtostr(buffer: [*c]gchar, buf_len: gint, d: gdouble) [*c]gchar;
pub extern fn g_ascii_formatd(buffer: [*c]gchar, buf_len: gint, format: [*c]const gchar, d: gdouble) [*c]gchar;
pub extern fn g_strchug(string: [*c]gchar) [*c]gchar;
pub extern fn g_strchomp(string: [*c]gchar) [*c]gchar;
pub extern fn g_ascii_strcasecmp(s1: [*c]const gchar, s2: [*c]const gchar) gint;
pub extern fn g_ascii_strncasecmp(s1: [*c]const gchar, s2: [*c]const gchar, n: gsize) gint;
pub extern fn g_ascii_strdown(str: [*c]const gchar, len: gssize) [*c]gchar;
pub extern fn g_ascii_strup(str: [*c]const gchar, len: gssize) [*c]gchar;
pub extern fn g_str_is_ascii(str: [*c]const gchar) gboolean;
pub extern fn g_strcasecmp(s1: [*c]const gchar, s2: [*c]const gchar) gint;
pub extern fn g_strncasecmp(s1: [*c]const gchar, s2: [*c]const gchar, n: guint) gint;
pub extern fn g_strdown(string: [*c]gchar) [*c]gchar;
pub extern fn g_strup(string: [*c]gchar) [*c]gchar;
pub extern fn g_strdup(str: [*c]const gchar) [*c]gchar;
pub extern fn g_strdup_printf(format: [*c]const gchar, ...) [*c]gchar;
pub extern fn g_strdup_vprintf(format: [*c]const gchar, args: va_list) [*c]gchar;
pub extern fn g_strndup(str: [*c]const gchar, n: gsize) [*c]gchar;
pub extern fn g_strnfill(length: gsize, fill_char: gchar) [*c]gchar;
pub extern fn g_strconcat(string1: [*c]const gchar, ...) [*c]gchar;
pub extern fn g_strjoin(separator: [*c]const gchar, ...) [*c]gchar;
pub extern fn g_strcompress(source: [*c]const gchar) [*c]gchar;
pub extern fn g_strescape(source: [*c]const gchar, exceptions: [*c]const gchar) [*c]gchar;
pub extern fn g_memdup(mem: gconstpointer, byte_size: guint) gpointer;
pub extern fn g_memdup2(mem: gconstpointer, byte_size: gsize) gpointer;
pub const GStrv = [*c][*c]gchar;
pub extern fn g_strsplit(string: [*c]const gchar, delimiter: [*c]const gchar, max_tokens: gint) [*c][*c]gchar;
pub extern fn g_strsplit_set(string: [*c]const gchar, delimiters: [*c]const gchar, max_tokens: gint) [*c][*c]gchar;
pub extern fn g_strjoinv(separator: [*c]const gchar, str_array: [*c][*c]gchar) [*c]gchar;
pub extern fn g_strfreev(str_array: [*c][*c]gchar) void;
pub extern fn g_strdupv(str_array: [*c][*c]gchar) [*c][*c]gchar;
pub extern fn g_strv_length(str_array: [*c][*c]gchar) guint;
pub extern fn g_stpcpy(dest: [*c]gchar, src: [*c]const u8) [*c]gchar;
pub extern fn g_str_to_ascii(str: [*c]const gchar, from_locale: [*c]const gchar) [*c]gchar;
pub extern fn g_str_tokenize_and_fold(string: [*c]const gchar, translit_locale: [*c]const gchar, ascii_alternates: [*c][*c][*c]gchar) [*c][*c]gchar;
pub extern fn g_str_match_string(search_term: [*c]const gchar, potential_hit: [*c]const gchar, accept_alternates: gboolean) gboolean;
pub extern fn g_strv_contains(strv: [*c]const [*c]const gchar, str: [*c]const gchar) gboolean;
pub extern fn g_strv_equal(strv1: [*c]const [*c]const gchar, strv2: [*c]const [*c]const gchar) gboolean;
pub const G_NUMBER_PARSER_ERROR_INVALID: c_int = 0;
pub const G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: c_int = 1;
pub const GNumberParserError = c_uint;
pub extern fn g_number_parser_error_quark() GQuark;
pub extern fn g_ascii_string_to_signed(str: [*c]const gchar, base: guint, min: gint64, max: gint64, out_num: [*c]gint64, @"error": [*c][*c]GError) gboolean;
pub extern fn g_ascii_string_to_unsigned(str: [*c]const gchar, base: guint, min: guint64, max: guint64, out_num: [*c]guint64, @"error": [*c][*c]GError) gboolean;
pub const struct__GStringChunk = opaque {};
pub const GStringChunk = struct__GStringChunk;
pub extern fn g_string_chunk_new(size: gsize) ?*GStringChunk;
pub extern fn g_string_chunk_free(chunk: ?*GStringChunk) void;
pub extern fn g_string_chunk_clear(chunk: ?*GStringChunk) void;
pub extern fn g_string_chunk_insert(chunk: ?*GStringChunk, string: [*c]const gchar) [*c]gchar;
pub extern fn g_string_chunk_insert_len(chunk: ?*GStringChunk, string: [*c]const gchar, len: gssize) [*c]gchar;
pub extern fn g_string_chunk_insert_const(chunk: ?*GStringChunk, string: [*c]const gchar) [*c]gchar;
pub const struct__GStrvBuilder = opaque {};
pub const GStrvBuilder = struct__GStrvBuilder;
pub extern fn g_strv_builder_new() ?*GStrvBuilder;
pub extern fn g_strv_builder_unref(builder: ?*GStrvBuilder) void;
pub extern fn g_strv_builder_ref(builder: ?*GStrvBuilder) ?*GStrvBuilder;
pub extern fn g_strv_builder_add(builder: ?*GStrvBuilder, value: [*c]const u8) void;
pub extern fn g_strv_builder_addv(builder: ?*GStrvBuilder, value: [*c][*c]const u8) void;
pub extern fn g_strv_builder_add_many(builder: ?*GStrvBuilder, ...) void;
pub extern fn g_strv_builder_end(builder: ?*GStrvBuilder) GStrv;
pub extern fn __errno_location() [*c]c_int;
pub const struct_GTestCase = opaque {};
pub const GTestCase = struct_GTestCase;
pub const struct_GTestSuite = opaque {};
pub const GTestSuite = struct_GTestSuite;
pub const GTestFunc = ?fn () callconv(.C) void;
pub const GTestDataFunc = ?fn (gconstpointer) callconv(.C) void;
pub const GTestFixtureFunc = ?fn (gpointer, gconstpointer) callconv(.C) void;
pub extern fn g_strcmp0(str1: [*c]const u8, str2: [*c]const u8) c_int;
pub extern fn g_test_minimized_result(minimized_quantity: f64, format: [*c]const u8, ...) void;
pub extern fn g_test_maximized_result(maximized_quantity: f64, format: [*c]const u8, ...) void;
pub extern fn g_test_init(argc: [*c]c_int, argv: [*c][*c][*c]u8, ...) void;
pub extern fn g_test_subprocess() gboolean;
pub extern fn g_test_run() c_int;
pub extern fn g_test_add_func(testpath: [*c]const u8, test_func: GTestFunc) void;
pub extern fn g_test_add_data_func(testpath: [*c]const u8, test_data: gconstpointer, test_func: GTestDataFunc) void;
pub extern fn g_test_add_data_func_full(testpath: [*c]const u8, test_data: gpointer, test_func: GTestDataFunc, data_free_func: GDestroyNotify) void;
pub extern fn g_test_get_path() [*c]const u8;
pub extern fn g_test_fail() void;
pub extern fn g_test_fail_printf(format: [*c]const u8, ...) void;
pub extern fn g_test_incomplete(msg: [*c]const gchar) void;
pub extern fn g_test_incomplete_printf(format: [*c]const u8, ...) void;
pub extern fn g_test_skip(msg: [*c]const gchar) void;
pub extern fn g_test_skip_printf(format: [*c]const u8, ...) void;
pub extern fn g_test_failed() gboolean;
pub extern fn g_test_set_nonfatal_assertions() void;
pub extern fn g_test_message(format: [*c]const u8, ...) void;
pub extern fn g_test_bug_base(uri_pattern: [*c]const u8) void;
pub extern fn g_test_bug(bug_uri_snippet: [*c]const u8) void;
pub extern fn g_test_summary(summary: [*c]const u8) void;
pub extern fn g_test_timer_start() void;
pub extern fn g_test_timer_elapsed() f64;
pub extern fn g_test_timer_last() f64;
pub extern fn g_test_queue_free(gfree_pointer: gpointer) void;
pub extern fn g_test_queue_destroy(destroy_func: GDestroyNotify, destroy_data: gpointer) void;
pub const G_TEST_TRAP_SILENCE_STDOUT: c_int = 128;
pub const G_TEST_TRAP_SILENCE_STDERR: c_int = 256;
pub const G_TEST_TRAP_INHERIT_STDIN: c_int = 512;
pub const GTestTrapFlags = c_uint;
pub extern fn g_test_trap_fork(usec_timeout: guint64, test_trap_flags: GTestTrapFlags) gboolean;
pub const G_TEST_SUBPROCESS_INHERIT_STDIN: c_int = 1;
pub const G_TEST_SUBPROCESS_INHERIT_STDOUT: c_int = 2;
pub const G_TEST_SUBPROCESS_INHERIT_STDERR: c_int = 4;
pub const GTestSubprocessFlags = c_uint;
pub extern fn g_test_trap_subprocess(test_path: [*c]const u8, usec_timeout: guint64, test_flags: GTestSubprocessFlags) void;
pub extern fn g_test_trap_has_passed() gboolean;
pub extern fn g_test_trap_reached_timeout() gboolean;
pub extern fn g_test_rand_int() gint32;
pub extern fn g_test_rand_int_range(begin: gint32, end: gint32) gint32;
pub extern fn g_test_rand_double() f64;
pub extern fn g_test_rand_double_range(range_start: f64, range_end: f64) f64;
pub extern fn g_test_create_case(test_name: [*c]const u8, data_size: gsize, test_data: gconstpointer, data_setup: GTestFixtureFunc, data_test: GTestFixtureFunc, data_teardown: GTestFixtureFunc) ?*GTestCase;
pub extern fn g_test_create_suite(suite_name: [*c]const u8) ?*GTestSuite;
pub extern fn g_test_get_root() ?*GTestSuite;
pub extern fn g_test_suite_add(suite: ?*GTestSuite, test_case: ?*GTestCase) void;
pub extern fn g_test_suite_add_suite(suite: ?*GTestSuite, nestedsuite: ?*GTestSuite) void;
pub extern fn g_test_run_suite(suite: ?*GTestSuite) c_int;
pub extern fn g_test_case_free(test_case: ?*GTestCase) void;
pub extern fn g_test_suite_free(suite: ?*GTestSuite) void;
pub extern fn g_test_trap_assertions(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8, assertion_flags: guint64, pattern: [*c]const u8) void;
pub extern fn g_assertion_message(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8, message: [*c]const u8) void;
pub extern fn g_assertion_message_expr(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8, expr: [*c]const u8) noreturn;
pub extern fn g_assertion_message_cmpstr(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8, expr: [*c]const u8, arg1: [*c]const u8, cmp: [*c]const u8, arg2: [*c]const u8) void;
pub extern fn g_assertion_message_cmpstrv(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8, expr: [*c]const u8, arg1: [*c]const [*c]const u8, arg2: [*c]const [*c]const u8, first_wrong_idx: gsize) void;
pub extern fn g_assertion_message_cmpnum(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8, expr: [*c]const u8, arg1: c_longdouble, cmp: [*c]const u8, arg2: c_longdouble, numtype: u8) void;
pub extern fn g_assertion_message_error(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8, expr: [*c]const u8, @"error": [*c]const GError, error_domain: GQuark, error_code: c_int) void;
pub extern fn g_test_add_vtable(testpath: [*c]const u8, data_size: gsize, test_data: gconstpointer, data_setup: GTestFixtureFunc, data_test: GTestFixtureFunc, data_teardown: GTestFixtureFunc) void;
pub const GTestConfig = extern struct {
    test_initialized: gboolean,
    test_quick: gboolean,
    test_perf: gboolean,
    test_verbose: gboolean,
    test_quiet: gboolean,
    test_undefined: gboolean,
};
pub extern const g_test_config_vars: [*c]const GTestConfig;
pub const G_TEST_RUN_SUCCESS: c_int = 0;
pub const G_TEST_RUN_SKIPPED: c_int = 1;
pub const G_TEST_RUN_FAILURE: c_int = 2;
pub const G_TEST_RUN_INCOMPLETE: c_int = 3;
pub const GTestResult = c_uint;
pub const G_TEST_LOG_NONE: c_int = 0;
pub const G_TEST_LOG_ERROR: c_int = 1;
pub const G_TEST_LOG_START_BINARY: c_int = 2;
pub const G_TEST_LOG_LIST_CASE: c_int = 3;
pub const G_TEST_LOG_SKIP_CASE: c_int = 4;
pub const G_TEST_LOG_START_CASE: c_int = 5;
pub const G_TEST_LOG_STOP_CASE: c_int = 6;
pub const G_TEST_LOG_MIN_RESULT: c_int = 7;
pub const G_TEST_LOG_MAX_RESULT: c_int = 8;
pub const G_TEST_LOG_MESSAGE: c_int = 9;
pub const G_TEST_LOG_START_SUITE: c_int = 10;
pub const G_TEST_LOG_STOP_SUITE: c_int = 11;
pub const GTestLogType = c_uint;
pub const GTestLogMsg = extern struct {
    log_type: GTestLogType,
    n_strings: guint,
    strings: [*c][*c]gchar,
    n_nums: guint,
    nums: [*c]c_longdouble,
};
pub const GTestLogBuffer = extern struct {
    data: [*c]GString,
    msgs: [*c]GSList,
};
pub extern fn g_test_log_type_name(log_type: GTestLogType) [*c]const u8;
pub extern fn g_test_log_buffer_new() [*c]GTestLogBuffer;
pub extern fn g_test_log_buffer_free(tbuffer: [*c]GTestLogBuffer) void;
pub extern fn g_test_log_buffer_push(tbuffer: [*c]GTestLogBuffer, n_bytes: guint, bytes: [*c]const guint8) void;
pub extern fn g_test_log_buffer_pop(tbuffer: [*c]GTestLogBuffer) [*c]GTestLogMsg;
pub extern fn g_test_log_msg_free(tmsg: [*c]GTestLogMsg) void;
pub const GTestLogFatalFunc = ?fn ([*c]const gchar, GLogLevelFlags, [*c]const gchar, gpointer) callconv(.C) gboolean;
pub extern fn g_test_log_set_fatal_handler(log_func: GTestLogFatalFunc, user_data: gpointer) void;
pub extern fn g_test_expect_message(log_domain: [*c]const gchar, log_level: GLogLevelFlags, pattern: [*c]const gchar) void;
pub extern fn g_test_assert_expected_messages_internal(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8) void;
pub const G_TEST_DIST: c_int = 0;
pub const G_TEST_BUILT: c_int = 1;
pub const GTestFileType = c_uint;
pub extern fn g_test_build_filename(file_type: GTestFileType, first_path: [*c]const gchar, ...) [*c]gchar;
pub extern fn g_test_get_dir(file_type: GTestFileType) [*c]const gchar;
pub extern fn g_test_get_filename(file_type: GTestFileType, first_path: [*c]const gchar, ...) [*c]const gchar;
pub const struct__GThreadPool = extern struct {
    func: GFunc,
    user_data: gpointer,
    exclusive: gboolean,
};
pub const GThreadPool = struct__GThreadPool;
pub extern fn g_thread_pool_new(func: GFunc, user_data: gpointer, max_threads: gint, exclusive: gboolean, @"error": [*c][*c]GError) [*c]GThreadPool;
pub extern fn g_thread_pool_new_full(func: GFunc, user_data: gpointer, item_free_func: GDestroyNotify, max_threads: gint, exclusive: gboolean, @"error": [*c][*c]GError) [*c]GThreadPool;
pub extern fn g_thread_pool_free(pool: [*c]GThreadPool, immediate: gboolean, wait_: gboolean) void;
pub extern fn g_thread_pool_push(pool: [*c]GThreadPool, data: gpointer, @"error": [*c][*c]GError) gboolean;
pub extern fn g_thread_pool_unprocessed(pool: [*c]GThreadPool) guint;
pub extern fn g_thread_pool_set_sort_function(pool: [*c]GThreadPool, func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_thread_pool_move_to_front(pool: [*c]GThreadPool, data: gpointer) gboolean;
pub extern fn g_thread_pool_set_max_threads(pool: [*c]GThreadPool, max_threads: gint, @"error": [*c][*c]GError) gboolean;
pub extern fn g_thread_pool_get_max_threads(pool: [*c]GThreadPool) gint;
pub extern fn g_thread_pool_get_num_threads(pool: [*c]GThreadPool) guint;
pub extern fn g_thread_pool_set_max_unused_threads(max_threads: gint) void;
pub extern fn g_thread_pool_get_max_unused_threads() gint;
pub extern fn g_thread_pool_get_num_unused_threads() guint;
pub extern fn g_thread_pool_stop_unused_threads() void;
pub extern fn g_thread_pool_set_max_idle_time(interval: guint) void;
pub extern fn g_thread_pool_get_max_idle_time() guint;
pub const struct__GTimer = opaque {};
pub const GTimer = struct__GTimer;
pub extern fn g_timer_new() ?*GTimer;
pub extern fn g_timer_destroy(timer: ?*GTimer) void;
pub extern fn g_timer_start(timer: ?*GTimer) void;
pub extern fn g_timer_stop(timer: ?*GTimer) void;
pub extern fn g_timer_reset(timer: ?*GTimer) void;
pub extern fn g_timer_continue(timer: ?*GTimer) void;
pub extern fn g_timer_elapsed(timer: ?*GTimer, microseconds: [*c]gulong) gdouble;
pub extern fn g_timer_is_active(timer: ?*GTimer) gboolean;
pub extern fn g_usleep(microseconds: gulong) void;
pub extern fn g_time_val_add(time_: [*c]GTimeVal, microseconds: glong) void;
pub extern fn g_time_val_from_iso8601(iso_date: [*c]const gchar, time_: [*c]GTimeVal) gboolean;
pub extern fn g_time_val_to_iso8601(time_: [*c]GTimeVal) [*c]gchar;
pub const GTrashStack = struct__GTrashStack;
pub const struct__GTrashStack = extern struct {
    next: [*c]GTrashStack,
};
pub extern fn g_trash_stack_push(stack_p: [*c][*c]GTrashStack, data_p: gpointer) void;
pub extern fn g_trash_stack_pop(stack_p: [*c][*c]GTrashStack) gpointer;
pub extern fn g_trash_stack_peek(stack_p: [*c][*c]GTrashStack) gpointer;
pub extern fn g_trash_stack_height(stack_p: [*c][*c]GTrashStack) guint;
pub const struct__GTree = opaque {};
pub const GTree = struct__GTree;
pub const struct__GTreeNode = opaque {};
pub const GTreeNode = struct__GTreeNode;
pub const GTraverseFunc = ?fn (gpointer, gpointer, gpointer) callconv(.C) gboolean;
pub const GTraverseNodeFunc = ?fn (?*GTreeNode, gpointer) callconv(.C) gboolean;
pub extern fn g_tree_new(key_compare_func: GCompareFunc) ?*GTree;
pub extern fn g_tree_new_with_data(key_compare_func: GCompareDataFunc, key_compare_data: gpointer) ?*GTree;
pub extern fn g_tree_new_full(key_compare_func: GCompareDataFunc, key_compare_data: gpointer, key_destroy_func: GDestroyNotify, value_destroy_func: GDestroyNotify) ?*GTree;
pub extern fn g_tree_node_first(tree: ?*GTree) ?*GTreeNode;
pub extern fn g_tree_node_last(tree: ?*GTree) ?*GTreeNode;
pub extern fn g_tree_node_previous(node: ?*GTreeNode) ?*GTreeNode;
pub extern fn g_tree_node_next(node: ?*GTreeNode) ?*GTreeNode;
pub extern fn g_tree_ref(tree: ?*GTree) ?*GTree;
pub extern fn g_tree_unref(tree: ?*GTree) void;
pub extern fn g_tree_destroy(tree: ?*GTree) void;
pub extern fn g_tree_insert_node(tree: ?*GTree, key: gpointer, value: gpointer) ?*GTreeNode;
pub extern fn g_tree_insert(tree: ?*GTree, key: gpointer, value: gpointer) void;
pub extern fn g_tree_replace_node(tree: ?*GTree, key: gpointer, value: gpointer) ?*GTreeNode;
pub extern fn g_tree_replace(tree: ?*GTree, key: gpointer, value: gpointer) void;
pub extern fn g_tree_remove(tree: ?*GTree, key: gconstpointer) gboolean;
pub extern fn g_tree_remove_all(tree: ?*GTree) void;
pub extern fn g_tree_steal(tree: ?*GTree, key: gconstpointer) gboolean;
pub extern fn g_tree_node_key(node: ?*GTreeNode) gpointer;
pub extern fn g_tree_node_value(node: ?*GTreeNode) gpointer;
pub extern fn g_tree_lookup_node(tree: ?*GTree, key: gconstpointer) ?*GTreeNode;
pub extern fn g_tree_lookup(tree: ?*GTree, key: gconstpointer) gpointer;
pub extern fn g_tree_lookup_extended(tree: ?*GTree, lookup_key: gconstpointer, orig_key: [*c]gpointer, value: [*c]gpointer) gboolean;
pub extern fn g_tree_foreach(tree: ?*GTree, func: GTraverseFunc, user_data: gpointer) void;
pub extern fn g_tree_foreach_node(tree: ?*GTree, func: GTraverseNodeFunc, user_data: gpointer) void;
pub extern fn g_tree_traverse(tree: ?*GTree, traverse_func: GTraverseFunc, traverse_type: GTraverseType, user_data: gpointer) void;
pub extern fn g_tree_search_node(tree: ?*GTree, search_func: GCompareFunc, user_data: gconstpointer) ?*GTreeNode;
pub extern fn g_tree_search(tree: ?*GTree, search_func: GCompareFunc, user_data: gconstpointer) gpointer;
pub extern fn g_tree_lower_bound(tree: ?*GTree, key: gconstpointer) ?*GTreeNode;
pub extern fn g_tree_upper_bound(tree: ?*GTree, key: gconstpointer) ?*GTreeNode;
pub extern fn g_tree_height(tree: ?*GTree) gint;
pub extern fn g_tree_nnodes(tree: ?*GTree) gint;
pub const struct__GUri = opaque {};
pub const GUri = struct__GUri;
pub extern fn g_uri_ref(uri: ?*GUri) ?*GUri;
pub extern fn g_uri_unref(uri: ?*GUri) void;
pub const G_URI_FLAGS_NONE: c_int = 0;
pub const G_URI_FLAGS_PARSE_RELAXED: c_int = 1;
pub const G_URI_FLAGS_HAS_PASSWORD: c_int = 2;
pub const G_URI_FLAGS_HAS_AUTH_PARAMS: c_int = 4;
pub const G_URI_FLAGS_ENCODED: c_int = 8;
pub const G_URI_FLAGS_NON_DNS: c_int = 16;
pub const G_URI_FLAGS_ENCODED_QUERY: c_int = 32;
pub const G_URI_FLAGS_ENCODED_PATH: c_int = 64;
pub const G_URI_FLAGS_ENCODED_FRAGMENT: c_int = 128;
pub const G_URI_FLAGS_SCHEME_NORMALIZE: c_int = 256;
pub const GUriFlags = c_uint;
pub extern fn g_uri_split(uri_ref: [*c]const gchar, flags: GUriFlags, scheme: [*c][*c]gchar, userinfo: [*c][*c]gchar, host: [*c][*c]gchar, port: [*c]gint, path: [*c][*c]gchar, query: [*c][*c]gchar, fragment: [*c][*c]gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_uri_split_with_user(uri_ref: [*c]const gchar, flags: GUriFlags, scheme: [*c][*c]gchar, user: [*c][*c]gchar, password: [*c][*c]gchar, auth_params: [*c][*c]gchar, host: [*c][*c]gchar, port: [*c]gint, path: [*c][*c]gchar, query: [*c][*c]gchar, fragment: [*c][*c]gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_uri_split_network(uri_string: [*c]const gchar, flags: GUriFlags, scheme: [*c][*c]gchar, host: [*c][*c]gchar, port: [*c]gint, @"error": [*c][*c]GError) gboolean;
pub extern fn g_uri_is_valid(uri_string: [*c]const gchar, flags: GUriFlags, @"error": [*c][*c]GError) gboolean;
pub extern fn g_uri_join(flags: GUriFlags, scheme: [*c]const gchar, userinfo: [*c]const gchar, host: [*c]const gchar, port: gint, path: [*c]const gchar, query: [*c]const gchar, fragment: [*c]const gchar) [*c]gchar;
pub extern fn g_uri_join_with_user(flags: GUriFlags, scheme: [*c]const gchar, user: [*c]const gchar, password: [*c]const gchar, auth_params: [*c]const gchar, host: [*c]const gchar, port: gint, path: [*c]const gchar, query: [*c]const gchar, fragment: [*c]const gchar) [*c]gchar;
pub extern fn g_uri_parse(uri_string: [*c]const gchar, flags: GUriFlags, @"error": [*c][*c]GError) ?*GUri;
pub extern fn g_uri_parse_relative(base_uri: ?*GUri, uri_ref: [*c]const gchar, flags: GUriFlags, @"error": [*c][*c]GError) ?*GUri;
pub extern fn g_uri_resolve_relative(base_uri_string: [*c]const gchar, uri_ref: [*c]const gchar, flags: GUriFlags, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_uri_build(flags: GUriFlags, scheme: [*c]const gchar, userinfo: [*c]const gchar, host: [*c]const gchar, port: gint, path: [*c]const gchar, query: [*c]const gchar, fragment: [*c]const gchar) ?*GUri;
pub extern fn g_uri_build_with_user(flags: GUriFlags, scheme: [*c]const gchar, user: [*c]const gchar, password: [*c]const gchar, auth_params: [*c]const gchar, host: [*c]const gchar, port: gint, path: [*c]const gchar, query: [*c]const gchar, fragment: [*c]const gchar) ?*GUri;
pub const G_URI_HIDE_NONE: c_int = 0;
pub const G_URI_HIDE_USERINFO: c_int = 1;
pub const G_URI_HIDE_PASSWORD: c_int = 2;
pub const G_URI_HIDE_AUTH_PARAMS: c_int = 4;
pub const G_URI_HIDE_QUERY: c_int = 8;
pub const G_URI_HIDE_FRAGMENT: c_int = 16;
pub const GUriHideFlags = c_uint;
pub extern fn g_uri_to_string(uri: ?*GUri) [*c]u8;
pub extern fn g_uri_to_string_partial(uri: ?*GUri, flags: GUriHideFlags) [*c]u8;
pub extern fn g_uri_get_scheme(uri: ?*GUri) [*c]const gchar;
pub extern fn g_uri_get_userinfo(uri: ?*GUri) [*c]const gchar;
pub extern fn g_uri_get_user(uri: ?*GUri) [*c]const gchar;
pub extern fn g_uri_get_password(uri: ?*GUri) [*c]const gchar;
pub extern fn g_uri_get_auth_params(uri: ?*GUri) [*c]const gchar;
pub extern fn g_uri_get_host(uri: ?*GUri) [*c]const gchar;
pub extern fn g_uri_get_port(uri: ?*GUri) gint;
pub extern fn g_uri_get_path(uri: ?*GUri) [*c]const gchar;
pub extern fn g_uri_get_query(uri: ?*GUri) [*c]const gchar;
pub extern fn g_uri_get_fragment(uri: ?*GUri) [*c]const gchar;
pub extern fn g_uri_get_flags(uri: ?*GUri) GUriFlags;
pub const G_URI_PARAMS_NONE: c_int = 0;
pub const G_URI_PARAMS_CASE_INSENSITIVE: c_int = 1;
pub const G_URI_PARAMS_WWW_FORM: c_int = 2;
pub const G_URI_PARAMS_PARSE_RELAXED: c_int = 4;
pub const GUriParamsFlags = c_uint;
pub extern fn g_uri_parse_params(params: [*c]const gchar, length: gssize, separators: [*c]const gchar, flags: GUriParamsFlags, @"error": [*c][*c]GError) ?*GHashTable;
pub const struct__GUriParamsIter = extern struct {
    dummy0: gint,
    dummy1: gpointer,
    dummy2: gpointer,
    dummy3: [256]guint8,
};
pub const GUriParamsIter = struct__GUriParamsIter;
pub extern fn g_uri_params_iter_init(iter: [*c]GUriParamsIter, params: [*c]const gchar, length: gssize, separators: [*c]const gchar, flags: GUriParamsFlags) void;
pub extern fn g_uri_params_iter_next(iter: [*c]GUriParamsIter, attribute: [*c][*c]gchar, value: [*c][*c]gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_uri_error_quark() GQuark;
pub const G_URI_ERROR_FAILED: c_int = 0;
pub const G_URI_ERROR_BAD_SCHEME: c_int = 1;
pub const G_URI_ERROR_BAD_USER: c_int = 2;
pub const G_URI_ERROR_BAD_PASSWORD: c_int = 3;
pub const G_URI_ERROR_BAD_AUTH_PARAMS: c_int = 4;
pub const G_URI_ERROR_BAD_HOST: c_int = 5;
pub const G_URI_ERROR_BAD_PORT: c_int = 6;
pub const G_URI_ERROR_BAD_PATH: c_int = 7;
pub const G_URI_ERROR_BAD_QUERY: c_int = 8;
pub const G_URI_ERROR_BAD_FRAGMENT: c_int = 9;
pub const GUriError = c_uint;
pub extern fn g_uri_unescape_string(escaped_string: [*c]const u8, illegal_characters: [*c]const u8) [*c]u8;
pub extern fn g_uri_unescape_segment(escaped_string: [*c]const u8, escaped_string_end: [*c]const u8, illegal_characters: [*c]const u8) [*c]u8;
pub extern fn g_uri_parse_scheme(uri: [*c]const u8) [*c]u8;
pub extern fn g_uri_peek_scheme(uri: [*c]const u8) [*c]const u8;
pub extern fn g_uri_escape_string(unescaped: [*c]const u8, reserved_chars_allowed: [*c]const u8, allow_utf8: gboolean) [*c]u8;
pub extern fn g_uri_unescape_bytes(escaped_string: [*c]const u8, length: gssize, illegal_characters: [*c]const u8, @"error": [*c][*c]GError) ?*GBytes;
pub extern fn g_uri_escape_bytes(unescaped: [*c]const guint8, length: gsize, reserved_chars_allowed: [*c]const u8) [*c]u8;
pub extern fn g_uuid_string_is_valid(str: [*c]const gchar) gboolean;
pub extern fn g_uuid_string_random() [*c]gchar;
pub extern const glib_major_version: guint;
pub extern const glib_minor_version: guint;
pub extern const glib_micro_version: guint;
pub extern const glib_interface_age: guint;
pub extern const glib_binary_age: guint;
pub extern fn glib_check_version(required_major: guint, required_minor: guint, required_micro: guint) [*c]const gchar;
pub const struct__GAllocator = opaque {};
pub const GAllocator = struct__GAllocator;
pub const struct__GMemChunk = opaque {};
pub const GMemChunk = struct__GMemChunk;
pub extern fn g_mem_chunk_new(name: [*c]const gchar, atom_size: gint, area_size: gsize, @"type": gint) ?*GMemChunk;
pub extern fn g_mem_chunk_destroy(mem_chunk: ?*GMemChunk) void;
pub extern fn g_mem_chunk_alloc(mem_chunk: ?*GMemChunk) gpointer;
pub extern fn g_mem_chunk_alloc0(mem_chunk: ?*GMemChunk) gpointer;
pub extern fn g_mem_chunk_free(mem_chunk: ?*GMemChunk, mem: gpointer) void;
pub extern fn g_mem_chunk_clean(mem_chunk: ?*GMemChunk) void;
pub extern fn g_mem_chunk_reset(mem_chunk: ?*GMemChunk) void;
pub extern fn g_mem_chunk_print(mem_chunk: ?*GMemChunk) void;
pub extern fn g_mem_chunk_info() void;
pub extern fn g_blow_chunks() void;
pub extern fn g_allocator_new(name: [*c]const gchar, n_preallocs: guint) ?*GAllocator;
pub extern fn g_allocator_free(allocator: ?*GAllocator) void;
pub extern fn g_list_push_allocator(allocator: ?*GAllocator) void;
pub extern fn g_list_pop_allocator() void;
pub extern fn g_slist_push_allocator(allocator: ?*GAllocator) void;
pub extern fn g_slist_pop_allocator() void;
pub extern fn g_node_push_allocator(allocator: ?*GAllocator) void;
pub extern fn g_node_pop_allocator() void;
pub const struct__GCache = opaque {};
pub const GCache = struct__GCache;
pub const GCacheNewFunc = ?fn (gpointer) callconv(.C) gpointer;
pub const GCacheDupFunc = ?fn (gpointer) callconv(.C) gpointer;
pub const GCacheDestroyFunc = ?fn (gpointer) callconv(.C) void;
pub extern fn g_cache_new(value_new_func: GCacheNewFunc, value_destroy_func: GCacheDestroyFunc, key_dup_func: GCacheDupFunc, key_destroy_func: GCacheDestroyFunc, hash_key_func: GHashFunc, hash_value_func: GHashFunc, key_equal_func: GEqualFunc) ?*GCache;
pub extern fn g_cache_destroy(cache: ?*GCache) void;
pub extern fn g_cache_insert(cache: ?*GCache, key: gpointer) gpointer;
pub extern fn g_cache_remove(cache: ?*GCache, value: gconstpointer) void;
pub extern fn g_cache_key_foreach(cache: ?*GCache, func: GHFunc, user_data: gpointer) void;
pub extern fn g_cache_value_foreach(cache: ?*GCache, func: GHFunc, user_data: gpointer) void;
pub const GCompletionFunc = ?fn (gpointer) callconv(.C) [*c]gchar;
pub const GCompletionStrncmpFunc = ?fn ([*c]const gchar, [*c]const gchar, gsize) callconv(.C) gint;
pub const struct__GCompletion = extern struct {
    items: [*c]GList,
    func: GCompletionFunc,
    prefix: [*c]gchar,
    cache: [*c]GList,
    strncmp_func: GCompletionStrncmpFunc,
};
pub const GCompletion = struct__GCompletion;
pub extern fn g_completion_new(func: GCompletionFunc) [*c]GCompletion;
pub extern fn g_completion_add_items(cmp: [*c]GCompletion, items: [*c]GList) void;
pub extern fn g_completion_remove_items(cmp: [*c]GCompletion, items: [*c]GList) void;
pub extern fn g_completion_clear_items(cmp: [*c]GCompletion) void;
pub extern fn g_completion_complete(cmp: [*c]GCompletion, prefix: [*c]const gchar, new_prefix: [*c][*c]gchar) [*c]GList;
pub extern fn g_completion_complete_utf8(cmp: [*c]GCompletion, prefix: [*c]const gchar, new_prefix: [*c][*c]gchar) [*c]GList;
pub extern fn g_completion_set_compare(cmp: [*c]GCompletion, strncmp_func: GCompletionStrncmpFunc) void;
pub extern fn g_completion_free(cmp: [*c]GCompletion) void;
pub const struct__GRelation = opaque {};
pub const GRelation = struct__GRelation;
pub const struct__GTuples = extern struct {
    len: guint,
};
pub const GTuples = struct__GTuples;
pub extern fn g_relation_new(fields: gint) ?*GRelation;
pub extern fn g_relation_destroy(relation: ?*GRelation) void;
pub extern fn g_relation_index(relation: ?*GRelation, field: gint, hash_func: GHashFunc, key_equal_func: GEqualFunc) void;
pub extern fn g_relation_insert(relation: ?*GRelation, ...) void;
pub extern fn g_relation_delete(relation: ?*GRelation, key: gconstpointer, field: gint) gint;
pub extern fn g_relation_select(relation: ?*GRelation, key: gconstpointer, field: gint) [*c]GTuples;
pub extern fn g_relation_count(relation: ?*GRelation, key: gconstpointer, field: gint) gint;
pub extern fn g_relation_exists(relation: ?*GRelation, ...) gboolean;
pub extern fn g_relation_print(relation: ?*GRelation) void;
pub extern fn g_tuples_destroy(tuples: [*c]GTuples) void;
pub extern fn g_tuples_index(tuples: [*c]GTuples, index_: gint, field: gint) gpointer;
pub const G_THREAD_PRIORITY_LOW: c_int = 0;
pub const G_THREAD_PRIORITY_NORMAL: c_int = 1;
pub const G_THREAD_PRIORITY_HIGH: c_int = 2;
pub const G_THREAD_PRIORITY_URGENT: c_int = 3;
pub const GThreadPriority = c_uint;
pub const struct__GThreadFunctions = extern struct {
    mutex_new: ?fn () callconv(.C) [*c]GMutex,
    mutex_lock: ?fn ([*c]GMutex) callconv(.C) void,
    mutex_trylock: ?fn ([*c]GMutex) callconv(.C) gboolean,
    mutex_unlock: ?fn ([*c]GMutex) callconv(.C) void,
    mutex_free: ?fn ([*c]GMutex) callconv(.C) void,
    cond_new: ?fn () callconv(.C) [*c]GCond,
    cond_signal: ?fn ([*c]GCond) callconv(.C) void,
    cond_broadcast: ?fn ([*c]GCond) callconv(.C) void,
    cond_wait: ?fn ([*c]GCond, [*c]GMutex) callconv(.C) void,
    cond_timed_wait: ?fn ([*c]GCond, [*c]GMutex, [*c]GTimeVal) callconv(.C) gboolean,
    cond_free: ?fn ([*c]GCond) callconv(.C) void,
    private_new: ?fn (GDestroyNotify) callconv(.C) [*c]GPrivate,
    private_get: ?fn ([*c]GPrivate) callconv(.C) gpointer,
    private_set: ?fn ([*c]GPrivate, gpointer) callconv(.C) void,
    thread_create: ?fn (GThreadFunc, gpointer, gulong, gboolean, gboolean, GThreadPriority, gpointer, [*c][*c]GError) callconv(.C) void,
    thread_yield: ?fn () callconv(.C) void,
    thread_join: ?fn (gpointer) callconv(.C) void,
    thread_exit: ?fn () callconv(.C) void,
    thread_set_priority: ?fn (gpointer, GThreadPriority) callconv(.C) void,
    thread_self: ?fn (gpointer) callconv(.C) void,
    thread_equal: ?fn (gpointer, gpointer) callconv(.C) gboolean,
};
pub const GThreadFunctions = struct__GThreadFunctions;
pub extern var g_thread_functions_for_glib_use: GThreadFunctions;
pub extern var g_thread_use_default_impl: gboolean;
pub extern var g_thread_gettime: ?fn () callconv(.C) guint64;
pub extern fn g_thread_create(func: GThreadFunc, data: gpointer, joinable: gboolean, @"error": [*c][*c]GError) [*c]GThread;
pub extern fn g_thread_create_full(func: GThreadFunc, data: gpointer, stack_size: gulong, joinable: gboolean, bound: gboolean, priority: GThreadPriority, @"error": [*c][*c]GError) [*c]GThread;
pub extern fn g_thread_set_priority(thread: [*c]GThread, priority: GThreadPriority) void;
pub extern fn g_thread_foreach(thread_func: GFunc, user_data: gpointer) void;
pub const struct_sched_param = extern struct {
    sched_priority: c_int,
};
pub const __cpu_mask = c_ulong;
pub const cpu_set_t = extern struct {
    __bits: [16]__cpu_mask,
};
pub extern fn __sched_cpucount(__setsize: usize, __setp: [*c]const cpu_set_t) c_int;
pub extern fn __sched_cpualloc(__count: usize) [*c]cpu_set_t;
pub extern fn __sched_cpufree(__set: [*c]cpu_set_t) void;
pub extern fn sched_setparam(__pid: __pid_t, __param: [*c]const struct_sched_param) c_int;
pub extern fn sched_getparam(__pid: __pid_t, __param: [*c]struct_sched_param) c_int;
pub extern fn sched_setscheduler(__pid: __pid_t, __policy: c_int, __param: [*c]const struct_sched_param) c_int;
pub extern fn sched_getscheduler(__pid: __pid_t) c_int;
pub extern fn sched_yield() c_int;
pub extern fn sched_get_priority_max(__algorithm: c_int) c_int;
pub extern fn sched_get_priority_min(__algorithm: c_int) c_int;
pub extern fn sched_rr_get_interval(__pid: __pid_t, __t: [*c]struct_timespec) c_int;
pub const __jmp_buf = [22]c_ulonglong;
pub const struct___jmp_buf_tag = extern struct {
    __jmpbuf: __jmp_buf,
    __mask_was_saved: c_int,
    __saved_mask: __sigset_t,
};
pub const PTHREAD_CREATE_JOINABLE: c_int = 0;
pub const PTHREAD_CREATE_DETACHED: c_int = 1;
const enum_unnamed_34 = c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: c_int = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: c_int = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: c_int = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: c_int = 3;
pub const PTHREAD_MUTEX_NORMAL: c_int = 0;
pub const PTHREAD_MUTEX_RECURSIVE: c_int = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: c_int = 2;
pub const PTHREAD_MUTEX_DEFAULT: c_int = 0;
const enum_unnamed_35 = c_uint;
pub const PTHREAD_MUTEX_STALLED: c_int = 0;
pub const PTHREAD_MUTEX_STALLED_NP: c_int = 0;
pub const PTHREAD_MUTEX_ROBUST: c_int = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: c_int = 1;
const enum_unnamed_36 = c_uint;
pub const PTHREAD_PRIO_NONE: c_int = 0;
pub const PTHREAD_PRIO_INHERIT: c_int = 1;
pub const PTHREAD_PRIO_PROTECT: c_int = 2;
const enum_unnamed_37 = c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: c_int = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: c_int = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: c_int = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: c_int = 0;
const enum_unnamed_38 = c_uint;
pub const PTHREAD_INHERIT_SCHED: c_int = 0;
pub const PTHREAD_EXPLICIT_SCHED: c_int = 1;
const enum_unnamed_39 = c_uint;
pub const PTHREAD_SCOPE_SYSTEM: c_int = 0;
pub const PTHREAD_SCOPE_PROCESS: c_int = 1;
const enum_unnamed_40 = c_uint;
pub const PTHREAD_PROCESS_PRIVATE: c_int = 0;
pub const PTHREAD_PROCESS_SHARED: c_int = 1;
const enum_unnamed_41 = c_uint;
pub const struct__pthread_cleanup_buffer = extern struct {
    __routine: ?fn (?*anyopaque) callconv(.C) void,
    __arg: ?*anyopaque,
    __canceltype: c_int,
    __prev: [*c]struct__pthread_cleanup_buffer,
};
pub const PTHREAD_CANCEL_ENABLE: c_int = 0;
pub const PTHREAD_CANCEL_DISABLE: c_int = 1;
const enum_unnamed_42 = c_uint;
pub const PTHREAD_CANCEL_DEFERRED: c_int = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: c_int = 1;
const enum_unnamed_43 = c_uint;
pub extern fn pthread_create(noalias __newthread: [*c]pthread_t, noalias __attr: [*c]const pthread_attr_t, __start_routine: ?fn (?*anyopaque) callconv(.C) ?*anyopaque, noalias __arg: ?*anyopaque) c_int;
pub extern fn pthread_exit(__retval: ?*anyopaque) noreturn;
pub extern fn pthread_join(__th: pthread_t, __thread_return: [*c]?*anyopaque) c_int;
pub extern fn pthread_detach(__th: pthread_t) c_int;
pub extern fn pthread_self() pthread_t;
pub extern fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) c_int;
pub extern fn pthread_attr_init(__attr: [*c]pthread_attr_t) c_int;
pub extern fn pthread_attr_destroy(__attr: [*c]pthread_attr_t) c_int;
pub extern fn pthread_attr_getdetachstate(__attr: [*c]const pthread_attr_t, __detachstate: [*c]c_int) c_int;
pub extern fn pthread_attr_setdetachstate(__attr: [*c]pthread_attr_t, __detachstate: c_int) c_int;
pub extern fn pthread_attr_getguardsize(__attr: [*c]const pthread_attr_t, __guardsize: [*c]usize) c_int;
pub extern fn pthread_attr_setguardsize(__attr: [*c]pthread_attr_t, __guardsize: usize) c_int;
pub extern fn pthread_attr_getschedparam(noalias __attr: [*c]const pthread_attr_t, noalias __param: [*c]struct_sched_param) c_int;
pub extern fn pthread_attr_setschedparam(noalias __attr: [*c]pthread_attr_t, noalias __param: [*c]const struct_sched_param) c_int;
pub extern fn pthread_attr_getschedpolicy(noalias __attr: [*c]const pthread_attr_t, noalias __policy: [*c]c_int) c_int;
pub extern fn pthread_attr_setschedpolicy(__attr: [*c]pthread_attr_t, __policy: c_int) c_int;
pub extern fn pthread_attr_getinheritsched(noalias __attr: [*c]const pthread_attr_t, noalias __inherit: [*c]c_int) c_int;
pub extern fn pthread_attr_setinheritsched(__attr: [*c]pthread_attr_t, __inherit: c_int) c_int;
pub extern fn pthread_attr_getscope(noalias __attr: [*c]const pthread_attr_t, noalias __scope: [*c]c_int) c_int;
pub extern fn pthread_attr_setscope(__attr: [*c]pthread_attr_t, __scope: c_int) c_int;
pub extern fn pthread_attr_getstackaddr(noalias __attr: [*c]const pthread_attr_t, noalias __stackaddr: [*c]?*anyopaque) c_int;
pub extern fn pthread_attr_setstackaddr(__attr: [*c]pthread_attr_t, __stackaddr: ?*anyopaque) c_int;
pub extern fn pthread_attr_getstacksize(noalias __attr: [*c]const pthread_attr_t, noalias __stacksize: [*c]usize) c_int;
pub extern fn pthread_attr_setstacksize(__attr: [*c]pthread_attr_t, __stacksize: usize) c_int;
pub extern fn pthread_attr_getstack(noalias __attr: [*c]const pthread_attr_t, noalias __stackaddr: [*c]?*anyopaque, noalias __stacksize: [*c]usize) c_int;
pub extern fn pthread_attr_setstack(__attr: [*c]pthread_attr_t, __stackaddr: ?*anyopaque, __stacksize: usize) c_int;
pub extern fn pthread_setschedparam(__target_thread: pthread_t, __policy: c_int, __param: [*c]const struct_sched_param) c_int;
pub extern fn pthread_getschedparam(__target_thread: pthread_t, noalias __policy: [*c]c_int, noalias __param: [*c]struct_sched_param) c_int;
pub extern fn pthread_setschedprio(__target_thread: pthread_t, __prio: c_int) c_int;
pub extern fn pthread_once(__once_control: [*c]pthread_once_t, __init_routine: ?fn () callconv(.C) void) c_int;
pub extern fn pthread_setcancelstate(__state: c_int, __oldstate: [*c]c_int) c_int;
pub extern fn pthread_setcanceltype(__type: c_int, __oldtype: [*c]c_int) c_int;
pub extern fn pthread_cancel(__th: pthread_t) c_int;
pub extern fn pthread_testcancel() void;
pub const struct___cancel_jmp_buf_tag = extern struct {
    __cancel_jmp_buf: __jmp_buf,
    __mask_was_saved: c_int,
};
pub const __pthread_unwind_buf_t = extern struct {
    __cancel_jmp_buf: [1]struct___cancel_jmp_buf_tag,
    __pad: [4]?*anyopaque,
};
pub const struct___pthread_cleanup_frame = extern struct {
    __cancel_routine: ?fn (?*anyopaque) callconv(.C) void,
    __cancel_arg: ?*anyopaque,
    __do_it: c_int,
    __cancel_type: c_int,
};
pub extern fn __pthread_register_cancel(__buf: [*c]__pthread_unwind_buf_t) void;
pub extern fn __pthread_unregister_cancel(__buf: [*c]__pthread_unwind_buf_t) void;
pub extern fn __pthread_unwind_next(__buf: [*c]__pthread_unwind_buf_t) noreturn;
pub extern fn __sigsetjmp(__env: [*c]struct___jmp_buf_tag, __savemask: c_int) c_int;
pub extern fn pthread_mutex_init(__mutex: [*c]pthread_mutex_t, __mutexattr: [*c]const pthread_mutexattr_t) c_int;
pub extern fn pthread_mutex_destroy(__mutex: [*c]pthread_mutex_t) c_int;
pub extern fn pthread_mutex_trylock(__mutex: [*c]pthread_mutex_t) c_int;
pub extern fn pthread_mutex_lock(__mutex: [*c]pthread_mutex_t) c_int;
pub extern fn pthread_mutex_timedlock(noalias __mutex: [*c]pthread_mutex_t, noalias __abstime: [*c]const struct_timespec) c_int;
pub extern fn pthread_mutex_unlock(__mutex: [*c]pthread_mutex_t) c_int;
pub extern fn pthread_mutex_getprioceiling(noalias __mutex: [*c]const pthread_mutex_t, noalias __prioceiling: [*c]c_int) c_int;
pub extern fn pthread_mutex_setprioceiling(noalias __mutex: [*c]pthread_mutex_t, __prioceiling: c_int, noalias __old_ceiling: [*c]c_int) c_int;
pub extern fn pthread_mutex_consistent(__mutex: [*c]pthread_mutex_t) c_int;
pub extern fn pthread_mutexattr_init(__attr: [*c]pthread_mutexattr_t) c_int;
pub extern fn pthread_mutexattr_destroy(__attr: [*c]pthread_mutexattr_t) c_int;
pub extern fn pthread_mutexattr_getpshared(noalias __attr: [*c]const pthread_mutexattr_t, noalias __pshared: [*c]c_int) c_int;
pub extern fn pthread_mutexattr_setpshared(__attr: [*c]pthread_mutexattr_t, __pshared: c_int) c_int;
pub extern fn pthread_mutexattr_gettype(noalias __attr: [*c]const pthread_mutexattr_t, noalias __kind: [*c]c_int) c_int;
pub extern fn pthread_mutexattr_settype(__attr: [*c]pthread_mutexattr_t, __kind: c_int) c_int;
pub extern fn pthread_mutexattr_getprotocol(noalias __attr: [*c]const pthread_mutexattr_t, noalias __protocol: [*c]c_int) c_int;
pub extern fn pthread_mutexattr_setprotocol(__attr: [*c]pthread_mutexattr_t, __protocol: c_int) c_int;
pub extern fn pthread_mutexattr_getprioceiling(noalias __attr: [*c]const pthread_mutexattr_t, noalias __prioceiling: [*c]c_int) c_int;
pub extern fn pthread_mutexattr_setprioceiling(__attr: [*c]pthread_mutexattr_t, __prioceiling: c_int) c_int;
pub extern fn pthread_mutexattr_getrobust(__attr: [*c]const pthread_mutexattr_t, __robustness: [*c]c_int) c_int;
pub extern fn pthread_mutexattr_setrobust(__attr: [*c]pthread_mutexattr_t, __robustness: c_int) c_int;
pub extern fn pthread_rwlock_init(noalias __rwlock: [*c]pthread_rwlock_t, noalias __attr: [*c]const pthread_rwlockattr_t) c_int;
pub extern fn pthread_rwlock_destroy(__rwlock: [*c]pthread_rwlock_t) c_int;
pub extern fn pthread_rwlock_rdlock(__rwlock: [*c]pthread_rwlock_t) c_int;
pub extern fn pthread_rwlock_tryrdlock(__rwlock: [*c]pthread_rwlock_t) c_int;
pub extern fn pthread_rwlock_timedrdlock(noalias __rwlock: [*c]pthread_rwlock_t, noalias __abstime: [*c]const struct_timespec) c_int;
pub extern fn pthread_rwlock_wrlock(__rwlock: [*c]pthread_rwlock_t) c_int;
pub extern fn pthread_rwlock_trywrlock(__rwlock: [*c]pthread_rwlock_t) c_int;
pub extern fn pthread_rwlock_timedwrlock(noalias __rwlock: [*c]pthread_rwlock_t, noalias __abstime: [*c]const struct_timespec) c_int;
pub extern fn pthread_rwlock_unlock(__rwlock: [*c]pthread_rwlock_t) c_int;
pub extern fn pthread_rwlockattr_init(__attr: [*c]pthread_rwlockattr_t) c_int;
pub extern fn pthread_rwlockattr_destroy(__attr: [*c]pthread_rwlockattr_t) c_int;
pub extern fn pthread_rwlockattr_getpshared(noalias __attr: [*c]const pthread_rwlockattr_t, noalias __pshared: [*c]c_int) c_int;
pub extern fn pthread_rwlockattr_setpshared(__attr: [*c]pthread_rwlockattr_t, __pshared: c_int) c_int;
pub extern fn pthread_rwlockattr_getkind_np(noalias __attr: [*c]const pthread_rwlockattr_t, noalias __pref: [*c]c_int) c_int;
pub extern fn pthread_rwlockattr_setkind_np(__attr: [*c]pthread_rwlockattr_t, __pref: c_int) c_int;
pub extern fn pthread_cond_init(noalias __cond: [*c]pthread_cond_t, noalias __cond_attr: [*c]const pthread_condattr_t) c_int;
pub extern fn pthread_cond_destroy(__cond: [*c]pthread_cond_t) c_int;
pub extern fn pthread_cond_signal(__cond: [*c]pthread_cond_t) c_int;
pub extern fn pthread_cond_broadcast(__cond: [*c]pthread_cond_t) c_int;
pub extern fn pthread_cond_wait(noalias __cond: [*c]pthread_cond_t, noalias __mutex: [*c]pthread_mutex_t) c_int;
pub extern fn pthread_cond_timedwait(noalias __cond: [*c]pthread_cond_t, noalias __mutex: [*c]pthread_mutex_t, noalias __abstime: [*c]const struct_timespec) c_int;
pub extern fn pthread_condattr_init(__attr: [*c]pthread_condattr_t) c_int;
pub extern fn pthread_condattr_destroy(__attr: [*c]pthread_condattr_t) c_int;
pub extern fn pthread_condattr_getpshared(noalias __attr: [*c]const pthread_condattr_t, noalias __pshared: [*c]c_int) c_int;
pub extern fn pthread_condattr_setpshared(__attr: [*c]pthread_condattr_t, __pshared: c_int) c_int;
pub extern fn pthread_condattr_getclock(noalias __attr: [*c]const pthread_condattr_t, noalias __clock_id: [*c]__clockid_t) c_int;
pub extern fn pthread_condattr_setclock(__attr: [*c]pthread_condattr_t, __clock_id: __clockid_t) c_int;
pub extern fn pthread_spin_init(__lock: [*c]volatile pthread_spinlock_t, __pshared: c_int) c_int;
pub extern fn pthread_spin_destroy(__lock: [*c]volatile pthread_spinlock_t) c_int;
pub extern fn pthread_spin_lock(__lock: [*c]volatile pthread_spinlock_t) c_int;
pub extern fn pthread_spin_trylock(__lock: [*c]volatile pthread_spinlock_t) c_int;
pub extern fn pthread_spin_unlock(__lock: [*c]volatile pthread_spinlock_t) c_int;
pub extern fn pthread_barrier_init(noalias __barrier: [*c]pthread_barrier_t, noalias __attr: [*c]const pthread_barrierattr_t, __count: c_uint) c_int;
pub extern fn pthread_barrier_destroy(__barrier: [*c]pthread_barrier_t) c_int;
pub extern fn pthread_barrier_wait(__barrier: [*c]pthread_barrier_t) c_int;
pub extern fn pthread_barrierattr_init(__attr: [*c]pthread_barrierattr_t) c_int;
pub extern fn pthread_barrierattr_destroy(__attr: [*c]pthread_barrierattr_t) c_int;
pub extern fn pthread_barrierattr_getpshared(noalias __attr: [*c]const pthread_barrierattr_t, noalias __pshared: [*c]c_int) c_int;
pub extern fn pthread_barrierattr_setpshared(__attr: [*c]pthread_barrierattr_t, __pshared: c_int) c_int;
pub extern fn pthread_key_create(__key: [*c]pthread_key_t, __destr_function: ?fn (?*anyopaque) callconv(.C) void) c_int;
pub extern fn pthread_key_delete(__key: pthread_key_t) c_int;
pub extern fn pthread_getspecific(__key: pthread_key_t) ?*anyopaque;
pub extern fn pthread_setspecific(__key: pthread_key_t, __pointer: ?*const anyopaque) c_int;
pub extern fn pthread_getcpuclockid(__thread_id: pthread_t, __clock_id: [*c]__clockid_t) c_int;
pub extern fn pthread_atfork(__prepare: ?fn () callconv(.C) void, __parent: ?fn () callconv(.C) void, __child: ?fn () callconv(.C) void) c_int;
pub const GStaticMutex = extern struct {
    mutex: [*c]GMutex,
    unused: pthread_mutex_t,
};
pub extern fn g_static_mutex_init(mutex: [*c]GStaticMutex) void;
pub extern fn g_static_mutex_free(mutex: [*c]GStaticMutex) void;
pub extern fn g_static_mutex_get_mutex_impl(mutex: [*c]GStaticMutex) [*c]GMutex;
const union_unnamed_44 = extern union {
    owner: pthread_t,
    dummy: gdouble,
};
pub const struct__GStaticRecMutex = extern struct {
    mutex: GStaticMutex,
    depth: guint,
    unused: union_unnamed_44,
};
pub const GStaticRecMutex = struct__GStaticRecMutex;
pub extern fn g_static_rec_mutex_init(mutex: [*c]GStaticRecMutex) void;
pub extern fn g_static_rec_mutex_lock(mutex: [*c]GStaticRecMutex) void;
pub extern fn g_static_rec_mutex_trylock(mutex: [*c]GStaticRecMutex) gboolean;
pub extern fn g_static_rec_mutex_unlock(mutex: [*c]GStaticRecMutex) void;
pub extern fn g_static_rec_mutex_lock_full(mutex: [*c]GStaticRecMutex, depth: guint) void;
pub extern fn g_static_rec_mutex_unlock_full(mutex: [*c]GStaticRecMutex) guint;
pub extern fn g_static_rec_mutex_free(mutex: [*c]GStaticRecMutex) void;
pub const struct__GStaticRWLock = extern struct {
    mutex: GStaticMutex,
    read_cond: [*c]GCond,
    write_cond: [*c]GCond,
    read_counter: guint,
    have_writer: gboolean,
    want_to_read: guint,
    want_to_write: guint,
};
pub const GStaticRWLock = struct__GStaticRWLock;
pub extern fn g_static_rw_lock_init(lock: [*c]GStaticRWLock) void;
pub extern fn g_static_rw_lock_reader_lock(lock: [*c]GStaticRWLock) void;
pub extern fn g_static_rw_lock_reader_trylock(lock: [*c]GStaticRWLock) gboolean;
pub extern fn g_static_rw_lock_reader_unlock(lock: [*c]GStaticRWLock) void;
pub extern fn g_static_rw_lock_writer_lock(lock: [*c]GStaticRWLock) void;
pub extern fn g_static_rw_lock_writer_trylock(lock: [*c]GStaticRWLock) gboolean;
pub extern fn g_static_rw_lock_writer_unlock(lock: [*c]GStaticRWLock) void;
pub extern fn g_static_rw_lock_free(lock: [*c]GStaticRWLock) void;
pub extern fn g_private_new(notify: GDestroyNotify) [*c]GPrivate;
pub const struct__GStaticPrivate = extern struct {
    index: guint,
};
pub const GStaticPrivate = struct__GStaticPrivate;
pub extern fn g_static_private_init(private_key: [*c]GStaticPrivate) void;
pub extern fn g_static_private_get(private_key: [*c]GStaticPrivate) gpointer;
pub extern fn g_static_private_set(private_key: [*c]GStaticPrivate, data: gpointer, notify: GDestroyNotify) void;
pub extern fn g_static_private_free(private_key: [*c]GStaticPrivate) void;
pub extern fn g_once_init_enter_impl(location: [*c]volatile gsize) gboolean;
pub extern fn g_thread_init(vtable: gpointer) void;
pub extern fn g_thread_init_with_errorcheck_mutexes(vtable: gpointer) void;
pub extern fn g_thread_get_initialized() gboolean;
pub extern var g_threads_got_initialized: gboolean;
pub extern fn g_mutex_new() [*c]GMutex;
pub extern fn g_mutex_free(mutex: [*c]GMutex) void;
pub extern fn g_cond_new() [*c]GCond;
pub extern fn g_cond_free(cond: [*c]GCond) void;
pub extern fn g_cond_timed_wait(cond: [*c]GCond, mutex: [*c]GMutex, timeval: [*c]GTimeVal) gboolean;
pub fn g_autoptr_cleanup_generic_gfree(arg_p: ?*anyopaque) callconv(.C) void {
    var p = arg_p;
    var pp: [*c]?*anyopaque = @ptrCast([*c]?*anyopaque, @alignCast(@import("std").meta.alignment([*c]?*anyopaque), p));
    g_free(pp.*);
}
pub fn g_autoptr_cleanup_gstring_free(arg_string: [*c]GString) callconv(.C) void {
    var string = arg_string;
    if (string != null) {
        _ = g_string_free(string, @boolToInt(!(@as(c_int, 0) != 0)));
    }
}
pub const GAsyncQueue_autoptr = ?*GAsyncQueue;
pub const GAsyncQueue_listautoptr = [*c]GList;
pub const GAsyncQueue_slistautoptr = [*c]GSList;
pub const GAsyncQueue_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GAsyncQueue(arg__ptr: ?*GAsyncQueue) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_async_queue_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GAsyncQueue(arg__ptr: [*c]?*GAsyncQueue) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GAsyncQueue(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GAsyncQueue(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_async_queue_unref)))));
}
pub fn glib_slistautoptr_cleanup_GAsyncQueue(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_async_queue_unref)))));
}
pub fn glib_queueautoptr_cleanup_GAsyncQueue(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_async_queue_unref)))));
    }
}
pub const GBookmarkFile_autoptr = ?*GBookmarkFile;
pub const GBookmarkFile_listautoptr = [*c]GList;
pub const GBookmarkFile_slistautoptr = [*c]GSList;
pub const GBookmarkFile_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GBookmarkFile(arg__ptr: ?*GBookmarkFile) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_bookmark_file_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GBookmarkFile(arg__ptr: [*c]?*GBookmarkFile) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GBookmarkFile(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GBookmarkFile(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_bookmark_file_free)))));
}
pub fn glib_slistautoptr_cleanup_GBookmarkFile(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_bookmark_file_free)))));
}
pub fn glib_queueautoptr_cleanup_GBookmarkFile(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_bookmark_file_free)))));
    }
}
pub const GBytes_autoptr = ?*GBytes;
pub const GBytes_listautoptr = [*c]GList;
pub const GBytes_slistautoptr = [*c]GSList;
pub const GBytes_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GBytes(arg__ptr: ?*GBytes) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_bytes_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GBytes(arg__ptr: [*c]?*GBytes) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GBytes(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GBytes(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_bytes_unref)))));
}
pub fn glib_slistautoptr_cleanup_GBytes(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_bytes_unref)))));
}
pub fn glib_queueautoptr_cleanup_GBytes(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_bytes_unref)))));
    }
}
pub const GChecksum_autoptr = ?*GChecksum;
pub const GChecksum_listautoptr = [*c]GList;
pub const GChecksum_slistautoptr = [*c]GSList;
pub const GChecksum_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GChecksum(arg__ptr: ?*GChecksum) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_checksum_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GChecksum(arg__ptr: [*c]?*GChecksum) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GChecksum(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GChecksum(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_checksum_free)))));
}
pub fn glib_slistautoptr_cleanup_GChecksum(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_checksum_free)))));
}
pub fn glib_queueautoptr_cleanup_GChecksum(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_checksum_free)))));
    }
}
pub const GDateTime_autoptr = ?*GDateTime;
pub const GDateTime_listautoptr = [*c]GList;
pub const GDateTime_slistautoptr = [*c]GSList;
pub const GDateTime_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDateTime(arg__ptr: ?*GDateTime) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_date_time_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GDateTime(arg__ptr: [*c]?*GDateTime) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDateTime(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDateTime(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_date_time_unref)))));
}
pub fn glib_slistautoptr_cleanup_GDateTime(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_date_time_unref)))));
}
pub fn glib_queueautoptr_cleanup_GDateTime(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_date_time_unref)))));
    }
}
pub const GDate_autoptr = ?*GDate;
pub const GDate_listautoptr = [*c]GList;
pub const GDate_slistautoptr = [*c]GSList;
pub const GDate_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDate(arg__ptr: ?*GDate) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_date_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GDate(arg__ptr: [*c]?*GDate) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDate(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDate(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_date_free)))));
}
pub fn glib_slistautoptr_cleanup_GDate(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_date_free)))));
}
pub fn glib_queueautoptr_cleanup_GDate(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_date_free)))));
    }
}
pub const GDir_autoptr = ?*GDir;
pub const GDir_listautoptr = [*c]GList;
pub const GDir_slistautoptr = [*c]GSList;
pub const GDir_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDir(arg__ptr: ?*GDir) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_dir_close(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GDir(arg__ptr: [*c]?*GDir) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDir(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDir(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_dir_close)))));
}
pub fn glib_slistautoptr_cleanup_GDir(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_dir_close)))));
}
pub fn glib_queueautoptr_cleanup_GDir(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_dir_close)))));
    }
}
pub const GError_autoptr = [*c]GError;
pub const GError_listautoptr = [*c]GList;
pub const GError_slistautoptr = [*c]GSList;
pub const GError_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GError(arg__ptr: [*c]GError) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_error_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GError(arg__ptr: [*c][*c]GError) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GError(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GError(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_error_free)))));
}
pub fn glib_slistautoptr_cleanup_GError(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_error_free)))));
}
pub fn glib_queueautoptr_cleanup_GError(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_error_free)))));
    }
}
pub const GHashTable_autoptr = ?*GHashTable;
pub const GHashTable_listautoptr = [*c]GList;
pub const GHashTable_slistautoptr = [*c]GSList;
pub const GHashTable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GHashTable(arg__ptr: ?*GHashTable) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_hash_table_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GHashTable(arg__ptr: [*c]?*GHashTable) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GHashTable(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GHashTable(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_hash_table_unref)))));
}
pub fn glib_slistautoptr_cleanup_GHashTable(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_hash_table_unref)))));
}
pub fn glib_queueautoptr_cleanup_GHashTable(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_hash_table_unref)))));
    }
}
pub const GHmac_autoptr = ?*GHmac;
pub const GHmac_listautoptr = [*c]GList;
pub const GHmac_slistautoptr = [*c]GSList;
pub const GHmac_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GHmac(arg__ptr: ?*GHmac) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_hmac_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GHmac(arg__ptr: [*c]?*GHmac) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GHmac(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GHmac(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_hmac_unref)))));
}
pub fn glib_slistautoptr_cleanup_GHmac(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_hmac_unref)))));
}
pub fn glib_queueautoptr_cleanup_GHmac(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_hmac_unref)))));
    }
}
pub const GIOChannel_autoptr = ?*GIOChannel;
pub const GIOChannel_listautoptr = [*c]GList;
pub const GIOChannel_slistautoptr = [*c]GSList;
pub const GIOChannel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GIOChannel(arg__ptr: ?*GIOChannel) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_io_channel_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GIOChannel(arg__ptr: [*c]?*GIOChannel) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GIOChannel(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GIOChannel(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_io_channel_unref)))));
}
pub fn glib_slistautoptr_cleanup_GIOChannel(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_io_channel_unref)))));
}
pub fn glib_queueautoptr_cleanup_GIOChannel(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_io_channel_unref)))));
    }
}
pub const GKeyFile_autoptr = ?*GKeyFile;
pub const GKeyFile_listautoptr = [*c]GList;
pub const GKeyFile_slistautoptr = [*c]GSList;
pub const GKeyFile_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GKeyFile(arg__ptr: ?*GKeyFile) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_key_file_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GKeyFile(arg__ptr: [*c]?*GKeyFile) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GKeyFile(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GKeyFile(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_key_file_unref)))));
}
pub fn glib_slistautoptr_cleanup_GKeyFile(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_key_file_unref)))));
}
pub fn glib_queueautoptr_cleanup_GKeyFile(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_key_file_unref)))));
    }
}
pub const GList_autoptr = [*c]GList;
pub const GList_listautoptr = [*c]GList;
pub const GList_slistautoptr = [*c]GSList;
pub const GList_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GList(arg__ptr: [*c]GList) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_list_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GList(arg__ptr: [*c][*c]GList) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GList(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GList(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_list_free)))));
}
pub fn glib_slistautoptr_cleanup_GList(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_list_free)))));
}
pub fn glib_queueautoptr_cleanup_GList(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_list_free)))));
    }
}
pub const GArray_autoptr = [*c]GArray;
pub const GArray_listautoptr = [*c]GList;
pub const GArray_slistautoptr = [*c]GSList;
pub const GArray_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GArray(arg__ptr: [*c]GArray) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_array_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GArray(arg__ptr: [*c][*c]GArray) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GArray(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GArray(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_array_unref)))));
}
pub fn glib_slistautoptr_cleanup_GArray(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_array_unref)))));
}
pub fn glib_queueautoptr_cleanup_GArray(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_array_unref)))));
    }
}
pub const GPtrArray_autoptr = [*c]GPtrArray;
pub const GPtrArray_listautoptr = [*c]GList;
pub const GPtrArray_slistautoptr = [*c]GSList;
pub const GPtrArray_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GPtrArray(arg__ptr: [*c]GPtrArray) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_ptr_array_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GPtrArray(arg__ptr: [*c][*c]GPtrArray) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GPtrArray(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GPtrArray(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_ptr_array_unref)))));
}
pub fn glib_slistautoptr_cleanup_GPtrArray(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_ptr_array_unref)))));
}
pub fn glib_queueautoptr_cleanup_GPtrArray(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_ptr_array_unref)))));
    }
}
pub const GByteArray_autoptr = [*c]GByteArray;
pub const GByteArray_listautoptr = [*c]GList;
pub const GByteArray_slistautoptr = [*c]GSList;
pub const GByteArray_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GByteArray(arg__ptr: [*c]GByteArray) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_byte_array_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GByteArray(arg__ptr: [*c][*c]GByteArray) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GByteArray(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GByteArray(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_byte_array_unref)))));
}
pub fn glib_slistautoptr_cleanup_GByteArray(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_byte_array_unref)))));
}
pub fn glib_queueautoptr_cleanup_GByteArray(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_byte_array_unref)))));
    }
}
pub const GMainContext_autoptr = ?*GMainContext;
pub const GMainContext_listautoptr = [*c]GList;
pub const GMainContext_slistautoptr = [*c]GSList;
pub const GMainContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMainContext(arg__ptr: ?*GMainContext) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_main_context_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GMainContext(arg__ptr: [*c]?*GMainContext) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GMainContext(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GMainContext(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_main_context_unref)))));
}
pub fn glib_slistautoptr_cleanup_GMainContext(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_main_context_unref)))));
}
pub fn glib_queueautoptr_cleanup_GMainContext(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_main_context_unref)))));
    }
}
pub const GMainContextPusher_autoptr = ?*GMainContextPusher;
pub const GMainContextPusher_listautoptr = [*c]GList;
pub const GMainContextPusher_slistautoptr = [*c]GSList;
pub const GMainContextPusher_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMainContextPusher(arg__ptr: ?*GMainContextPusher) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_main_context_pusher_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GMainContextPusher(arg__ptr: [*c]?*GMainContextPusher) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GMainContextPusher(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GMainContextPusher(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_main_context_pusher_free)))));
}
pub fn glib_slistautoptr_cleanup_GMainContextPusher(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_main_context_pusher_free)))));
}
pub fn glib_queueautoptr_cleanup_GMainContextPusher(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_main_context_pusher_free)))));
    }
}
pub const GMainLoop_autoptr = ?*GMainLoop;
pub const GMainLoop_listautoptr = [*c]GList;
pub const GMainLoop_slistautoptr = [*c]GSList;
pub const GMainLoop_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMainLoop(arg__ptr: ?*GMainLoop) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_main_loop_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GMainLoop(arg__ptr: [*c]?*GMainLoop) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GMainLoop(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GMainLoop(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_main_loop_unref)))));
}
pub fn glib_slistautoptr_cleanup_GMainLoop(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_main_loop_unref)))));
}
pub fn glib_queueautoptr_cleanup_GMainLoop(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_main_loop_unref)))));
    }
}
pub const GSource_autoptr = [*c]GSource;
pub const GSource_listautoptr = [*c]GList;
pub const GSource_slistautoptr = [*c]GSList;
pub const GSource_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSource(arg__ptr: [*c]GSource) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_source_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GSource(arg__ptr: [*c][*c]GSource) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSource(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSource(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_source_unref)))));
}
pub fn glib_slistautoptr_cleanup_GSource(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_source_unref)))));
}
pub fn glib_queueautoptr_cleanup_GSource(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_source_unref)))));
    }
}
pub const GMappedFile_autoptr = ?*GMappedFile;
pub const GMappedFile_listautoptr = [*c]GList;
pub const GMappedFile_slistautoptr = [*c]GSList;
pub const GMappedFile_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMappedFile(arg__ptr: ?*GMappedFile) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_mapped_file_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GMappedFile(arg__ptr: [*c]?*GMappedFile) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GMappedFile(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GMappedFile(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_mapped_file_unref)))));
}
pub fn glib_slistautoptr_cleanup_GMappedFile(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_mapped_file_unref)))));
}
pub fn glib_queueautoptr_cleanup_GMappedFile(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_mapped_file_unref)))));
    }
}
pub const GMarkupParseContext_autoptr = ?*GMarkupParseContext;
pub const GMarkupParseContext_listautoptr = [*c]GList;
pub const GMarkupParseContext_slistautoptr = [*c]GSList;
pub const GMarkupParseContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMarkupParseContext(arg__ptr: ?*GMarkupParseContext) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_markup_parse_context_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GMarkupParseContext(arg__ptr: [*c]?*GMarkupParseContext) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GMarkupParseContext(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GMarkupParseContext(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_markup_parse_context_unref)))));
}
pub fn glib_slistautoptr_cleanup_GMarkupParseContext(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_markup_parse_context_unref)))));
}
pub fn glib_queueautoptr_cleanup_GMarkupParseContext(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_markup_parse_context_unref)))));
    }
}
pub const GNode_autoptr = [*c]GNode;
pub const GNode_listautoptr = [*c]GList;
pub const GNode_slistautoptr = [*c]GSList;
pub const GNode_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GNode(arg__ptr: [*c]GNode) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_node_destroy(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GNode(arg__ptr: [*c][*c]GNode) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GNode(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GNode(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_node_destroy)))));
}
pub fn glib_slistautoptr_cleanup_GNode(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_node_destroy)))));
}
pub fn glib_queueautoptr_cleanup_GNode(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_node_destroy)))));
    }
}
pub const GOptionContext_autoptr = ?*GOptionContext;
pub const GOptionContext_listautoptr = [*c]GList;
pub const GOptionContext_slistautoptr = [*c]GSList;
pub const GOptionContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GOptionContext(arg__ptr: ?*GOptionContext) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_option_context_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GOptionContext(arg__ptr: [*c]?*GOptionContext) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GOptionContext(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GOptionContext(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_option_context_free)))));
}
pub fn glib_slistautoptr_cleanup_GOptionContext(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_option_context_free)))));
}
pub fn glib_queueautoptr_cleanup_GOptionContext(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_option_context_free)))));
    }
}
pub const GOptionGroup_autoptr = ?*GOptionGroup;
pub const GOptionGroup_listautoptr = [*c]GList;
pub const GOptionGroup_slistautoptr = [*c]GSList;
pub const GOptionGroup_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GOptionGroup(arg__ptr: ?*GOptionGroup) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_option_group_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GOptionGroup(arg__ptr: [*c]?*GOptionGroup) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GOptionGroup(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GOptionGroup(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_option_group_unref)))));
}
pub fn glib_slistautoptr_cleanup_GOptionGroup(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_option_group_unref)))));
}
pub fn glib_queueautoptr_cleanup_GOptionGroup(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_option_group_unref)))));
    }
}
pub const GPatternSpec_autoptr = ?*GPatternSpec;
pub const GPatternSpec_listautoptr = [*c]GList;
pub const GPatternSpec_slistautoptr = [*c]GSList;
pub const GPatternSpec_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GPatternSpec(arg__ptr: ?*GPatternSpec) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_pattern_spec_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GPatternSpec(arg__ptr: [*c]?*GPatternSpec) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GPatternSpec(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GPatternSpec(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_pattern_spec_free)))));
}
pub fn glib_slistautoptr_cleanup_GPatternSpec(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_pattern_spec_free)))));
}
pub fn glib_queueautoptr_cleanup_GPatternSpec(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_pattern_spec_free)))));
    }
}
pub const GQueue_autoptr = [*c]GQueue;
pub const GQueue_listautoptr = [*c]GList;
pub const GQueue_slistautoptr = [*c]GSList;
pub const GQueue_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GQueue(arg__ptr: [*c]GQueue) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_queue_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GQueue(arg__ptr: [*c][*c]GQueue) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GQueue(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GQueue(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_queue_free)))));
}
pub fn glib_slistautoptr_cleanup_GQueue(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_queue_free)))));
}
pub fn glib_queueautoptr_cleanup_GQueue(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_queue_free)))));
    }
}
pub fn glib_auto_cleanup_GQueue(arg__ptr: [*c]GQueue) callconv(.C) void {
    var _ptr = arg__ptr;
    g_queue_clear(_ptr);
}
pub const GRand_autoptr = ?*GRand;
pub const GRand_listautoptr = [*c]GList;
pub const GRand_slistautoptr = [*c]GSList;
pub const GRand_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GRand(arg__ptr: ?*GRand) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_rand_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GRand(arg__ptr: [*c]?*GRand) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GRand(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GRand(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_rand_free)))));
}
pub fn glib_slistautoptr_cleanup_GRand(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_rand_free)))));
}
pub fn glib_queueautoptr_cleanup_GRand(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_rand_free)))));
    }
}
pub const GRegex_autoptr = ?*GRegex;
pub const GRegex_listautoptr = [*c]GList;
pub const GRegex_slistautoptr = [*c]GSList;
pub const GRegex_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GRegex(arg__ptr: ?*GRegex) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_regex_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GRegex(arg__ptr: [*c]?*GRegex) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GRegex(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GRegex(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_regex_unref)))));
}
pub fn glib_slistautoptr_cleanup_GRegex(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_regex_unref)))));
}
pub fn glib_queueautoptr_cleanup_GRegex(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_regex_unref)))));
    }
}
pub const GMatchInfo_autoptr = ?*GMatchInfo;
pub const GMatchInfo_listautoptr = [*c]GList;
pub const GMatchInfo_slistautoptr = [*c]GSList;
pub const GMatchInfo_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMatchInfo(arg__ptr: ?*GMatchInfo) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_match_info_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GMatchInfo(arg__ptr: [*c]?*GMatchInfo) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GMatchInfo(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GMatchInfo(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_match_info_unref)))));
}
pub fn glib_slistautoptr_cleanup_GMatchInfo(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_match_info_unref)))));
}
pub fn glib_queueautoptr_cleanup_GMatchInfo(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_match_info_unref)))));
    }
}
pub const GScanner_autoptr = [*c]GScanner;
pub const GScanner_listautoptr = [*c]GList;
pub const GScanner_slistautoptr = [*c]GSList;
pub const GScanner_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GScanner(arg__ptr: [*c]GScanner) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_scanner_destroy(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GScanner(arg__ptr: [*c][*c]GScanner) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GScanner(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GScanner(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_scanner_destroy)))));
}
pub fn glib_slistautoptr_cleanup_GScanner(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_scanner_destroy)))));
}
pub fn glib_queueautoptr_cleanup_GScanner(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_scanner_destroy)))));
    }
}
pub const GSequence_autoptr = ?*GSequence;
pub const GSequence_listautoptr = [*c]GList;
pub const GSequence_slistautoptr = [*c]GSList;
pub const GSequence_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSequence(arg__ptr: ?*GSequence) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_sequence_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GSequence(arg__ptr: [*c]?*GSequence) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSequence(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSequence(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_sequence_free)))));
}
pub fn glib_slistautoptr_cleanup_GSequence(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_sequence_free)))));
}
pub fn glib_queueautoptr_cleanup_GSequence(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_sequence_free)))));
    }
}
pub const GSList_autoptr = [*c]GSList;
pub const GSList_listautoptr = [*c]GList;
pub const GSList_slistautoptr = [*c]GSList;
pub const GSList_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSList(arg__ptr: [*c]GSList) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_slist_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GSList(arg__ptr: [*c][*c]GSList) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSList(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSList(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_slist_free)))));
}
pub fn glib_slistautoptr_cleanup_GSList(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_slist_free)))));
}
pub fn glib_queueautoptr_cleanup_GSList(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_slist_free)))));
    }
}
pub const GString_autoptr = [*c]GString;
pub const GString_listautoptr = [*c]GList;
pub const GString_slistautoptr = [*c]GSList;
pub const GString_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GString(arg__ptr: [*c]GString) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_autoptr_cleanup_gstring_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GString(arg__ptr: [*c][*c]GString) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GString(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GString(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_autoptr_cleanup_gstring_free)))));
}
pub fn glib_slistautoptr_cleanup_GString(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_autoptr_cleanup_gstring_free)))));
}
pub fn glib_queueautoptr_cleanup_GString(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_autoptr_cleanup_gstring_free)))));
    }
}
pub const GStringChunk_autoptr = ?*GStringChunk;
pub const GStringChunk_listautoptr = [*c]GList;
pub const GStringChunk_slistautoptr = [*c]GSList;
pub const GStringChunk_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GStringChunk(arg__ptr: ?*GStringChunk) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_string_chunk_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GStringChunk(arg__ptr: [*c]?*GStringChunk) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GStringChunk(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GStringChunk(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_string_chunk_free)))));
}
pub fn glib_slistautoptr_cleanup_GStringChunk(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_string_chunk_free)))));
}
pub fn glib_queueautoptr_cleanup_GStringChunk(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_string_chunk_free)))));
    }
}
pub const GStrvBuilder_autoptr = ?*GStrvBuilder;
pub const GStrvBuilder_listautoptr = [*c]GList;
pub const GStrvBuilder_slistautoptr = [*c]GSList;
pub const GStrvBuilder_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GStrvBuilder(arg__ptr: ?*GStrvBuilder) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_strv_builder_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GStrvBuilder(arg__ptr: [*c]?*GStrvBuilder) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GStrvBuilder(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GStrvBuilder(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_strv_builder_unref)))));
}
pub fn glib_slistautoptr_cleanup_GStrvBuilder(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_strv_builder_unref)))));
}
pub fn glib_queueautoptr_cleanup_GStrvBuilder(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_strv_builder_unref)))));
    }
}
pub const GThread_autoptr = [*c]GThread;
pub const GThread_listautoptr = [*c]GList;
pub const GThread_slistautoptr = [*c]GSList;
pub const GThread_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GThread(arg__ptr: [*c]GThread) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_thread_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GThread(arg__ptr: [*c][*c]GThread) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GThread(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GThread(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_thread_unref)))));
}
pub fn glib_slistautoptr_cleanup_GThread(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_thread_unref)))));
}
pub fn glib_queueautoptr_cleanup_GThread(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_thread_unref)))));
    }
}
pub fn glib_auto_cleanup_GMutex(arg__ptr: [*c]GMutex) callconv(.C) void {
    var _ptr = arg__ptr;
    g_mutex_clear(_ptr);
}
pub const GMutexLocker_autoptr = ?*GMutexLocker;
pub const GMutexLocker_listautoptr = [*c]GList;
pub const GMutexLocker_slistautoptr = [*c]GSList;
pub const GMutexLocker_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMutexLocker(arg__ptr: ?*GMutexLocker) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_mutex_locker_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GMutexLocker(arg__ptr: [*c]?*GMutexLocker) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GMutexLocker(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GMutexLocker(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_mutex_locker_free)))));
}
pub fn glib_slistautoptr_cleanup_GMutexLocker(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_mutex_locker_free)))));
}
pub fn glib_queueautoptr_cleanup_GMutexLocker(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_mutex_locker_free)))));
    }
}
pub const GRecMutexLocker_autoptr = ?*GRecMutexLocker;
pub const GRecMutexLocker_listautoptr = [*c]GList;
pub const GRecMutexLocker_slistautoptr = [*c]GSList;
pub const GRecMutexLocker_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GRecMutexLocker(arg__ptr: ?*GRecMutexLocker) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_rec_mutex_locker_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GRecMutexLocker(arg__ptr: [*c]?*GRecMutexLocker) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GRecMutexLocker(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GRecMutexLocker(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_rec_mutex_locker_free)))));
}
pub fn glib_slistautoptr_cleanup_GRecMutexLocker(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_rec_mutex_locker_free)))));
}
pub fn glib_queueautoptr_cleanup_GRecMutexLocker(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_rec_mutex_locker_free)))));
    }
}
pub const GRWLockWriterLocker_autoptr = ?*GRWLockWriterLocker;
pub const GRWLockWriterLocker_listautoptr = [*c]GList;
pub const GRWLockWriterLocker_slistautoptr = [*c]GSList;
pub const GRWLockWriterLocker_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GRWLockWriterLocker(arg__ptr: ?*GRWLockWriterLocker) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_rw_lock_writer_locker_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GRWLockWriterLocker(arg__ptr: [*c]?*GRWLockWriterLocker) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GRWLockWriterLocker(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GRWLockWriterLocker(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_rw_lock_writer_locker_free)))));
}
pub fn glib_slistautoptr_cleanup_GRWLockWriterLocker(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_rw_lock_writer_locker_free)))));
}
pub fn glib_queueautoptr_cleanup_GRWLockWriterLocker(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_rw_lock_writer_locker_free)))));
    }
}
pub const GRWLockReaderLocker_autoptr = ?*GRWLockReaderLocker;
pub const GRWLockReaderLocker_listautoptr = [*c]GList;
pub const GRWLockReaderLocker_slistautoptr = [*c]GSList;
pub const GRWLockReaderLocker_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GRWLockReaderLocker(arg__ptr: ?*GRWLockReaderLocker) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_rw_lock_reader_locker_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GRWLockReaderLocker(arg__ptr: [*c]?*GRWLockReaderLocker) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GRWLockReaderLocker(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GRWLockReaderLocker(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_rw_lock_reader_locker_free)))));
}
pub fn glib_slistautoptr_cleanup_GRWLockReaderLocker(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_rw_lock_reader_locker_free)))));
}
pub fn glib_queueautoptr_cleanup_GRWLockReaderLocker(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_rw_lock_reader_locker_free)))));
    }
}
pub fn glib_auto_cleanup_GCond(arg__ptr: [*c]GCond) callconv(.C) void {
    var _ptr = arg__ptr;
    g_cond_clear(_ptr);
}
pub const GTimer_autoptr = ?*GTimer;
pub const GTimer_listautoptr = [*c]GList;
pub const GTimer_slistautoptr = [*c]GSList;
pub const GTimer_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTimer(arg__ptr: ?*GTimer) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_timer_destroy(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GTimer(arg__ptr: [*c]?*GTimer) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GTimer(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GTimer(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_timer_destroy)))));
}
pub fn glib_slistautoptr_cleanup_GTimer(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_timer_destroy)))));
}
pub fn glib_queueautoptr_cleanup_GTimer(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_timer_destroy)))));
    }
}
pub const GTimeZone_autoptr = ?*GTimeZone;
pub const GTimeZone_listautoptr = [*c]GList;
pub const GTimeZone_slistautoptr = [*c]GSList;
pub const GTimeZone_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTimeZone(arg__ptr: ?*GTimeZone) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_time_zone_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GTimeZone(arg__ptr: [*c]?*GTimeZone) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GTimeZone(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GTimeZone(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_time_zone_unref)))));
}
pub fn glib_slistautoptr_cleanup_GTimeZone(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_time_zone_unref)))));
}
pub fn glib_queueautoptr_cleanup_GTimeZone(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_time_zone_unref)))));
    }
}
pub const GTree_autoptr = ?*GTree;
pub const GTree_listautoptr = [*c]GList;
pub const GTree_slistautoptr = [*c]GSList;
pub const GTree_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTree(arg__ptr: ?*GTree) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_tree_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GTree(arg__ptr: [*c]?*GTree) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GTree(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GTree(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_tree_unref)))));
}
pub fn glib_slistautoptr_cleanup_GTree(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_tree_unref)))));
}
pub fn glib_queueautoptr_cleanup_GTree(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_tree_unref)))));
    }
}
pub const GVariant_autoptr = ?*GVariant;
pub const GVariant_listautoptr = [*c]GList;
pub const GVariant_slistautoptr = [*c]GSList;
pub const GVariant_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GVariant(arg__ptr: ?*GVariant) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_variant_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GVariant(arg__ptr: [*c]?*GVariant) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GVariant(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GVariant(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_variant_unref)))));
}
pub fn glib_slistautoptr_cleanup_GVariant(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_variant_unref)))));
}
pub fn glib_queueautoptr_cleanup_GVariant(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_variant_unref)))));
    }
}
pub const GVariantBuilder_autoptr = [*c]GVariantBuilder;
pub const GVariantBuilder_listautoptr = [*c]GList;
pub const GVariantBuilder_slistautoptr = [*c]GSList;
pub const GVariantBuilder_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GVariantBuilder(arg__ptr: [*c]GVariantBuilder) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_variant_builder_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GVariantBuilder(arg__ptr: [*c][*c]GVariantBuilder) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GVariantBuilder(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GVariantBuilder(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_variant_builder_unref)))));
}
pub fn glib_slistautoptr_cleanup_GVariantBuilder(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_variant_builder_unref)))));
}
pub fn glib_queueautoptr_cleanup_GVariantBuilder(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_variant_builder_unref)))));
    }
}
pub fn glib_auto_cleanup_GVariantBuilder(arg__ptr: [*c]GVariantBuilder) callconv(.C) void {
    var _ptr = arg__ptr;
    g_variant_builder_clear(_ptr);
}
pub const GVariantIter_autoptr = [*c]GVariantIter;
pub const GVariantIter_listautoptr = [*c]GList;
pub const GVariantIter_slistautoptr = [*c]GSList;
pub const GVariantIter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GVariantIter(arg__ptr: [*c]GVariantIter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_variant_iter_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GVariantIter(arg__ptr: [*c][*c]GVariantIter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GVariantIter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GVariantIter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_variant_iter_free)))));
}
pub fn glib_slistautoptr_cleanup_GVariantIter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_variant_iter_free)))));
}
pub fn glib_queueautoptr_cleanup_GVariantIter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_variant_iter_free)))));
    }
}
pub const GVariantDict_autoptr = [*c]GVariantDict;
pub const GVariantDict_listautoptr = [*c]GList;
pub const GVariantDict_slistautoptr = [*c]GSList;
pub const GVariantDict_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GVariantDict(arg__ptr: [*c]GVariantDict) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_variant_dict_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GVariantDict(arg__ptr: [*c][*c]GVariantDict) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GVariantDict(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GVariantDict(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_variant_dict_unref)))));
}
pub fn glib_slistautoptr_cleanup_GVariantDict(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_variant_dict_unref)))));
}
pub fn glib_queueautoptr_cleanup_GVariantDict(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_variant_dict_unref)))));
    }
}
pub fn glib_auto_cleanup_GVariantDict(arg__ptr: [*c]GVariantDict) callconv(.C) void {
    var _ptr = arg__ptr;
    g_variant_dict_clear(_ptr);
}
pub const GVariantType_autoptr = ?*GVariantType;
pub const GVariantType_listautoptr = [*c]GList;
pub const GVariantType_slistautoptr = [*c]GSList;
pub const GVariantType_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GVariantType(arg__ptr: ?*GVariantType) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_variant_type_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GVariantType(arg__ptr: [*c]?*GVariantType) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GVariantType(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GVariantType(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_variant_type_free)))));
}
pub fn glib_slistautoptr_cleanup_GVariantType(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_variant_type_free)))));
}
pub fn glib_queueautoptr_cleanup_GVariantType(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_variant_type_free)))));
    }
}
pub fn glib_auto_cleanup_GStrv(arg__ptr: [*c]GStrv) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr.* != @ptrCast(GStrv, @alignCast(@import("std").meta.alignment(GStrv), @intToPtr(?*anyopaque, @as(c_int, 0))))) {
        g_strfreev(_ptr.*);
    }
}
pub const GRefString_autoptr = [*c]GRefString;
pub const GRefString_listautoptr = [*c]GList;
pub const GRefString_slistautoptr = [*c]GSList;
pub const GRefString_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GRefString(arg__ptr: [*c]GRefString) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_ref_string_release(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GRefString(arg__ptr: [*c][*c]GRefString) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GRefString(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GRefString(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_ref_string_release)))));
}
pub fn glib_slistautoptr_cleanup_GRefString(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_ref_string_release)))));
}
pub fn glib_queueautoptr_cleanup_GRefString(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_ref_string_release)))));
    }
}
pub const GUri_autoptr = ?*GUri;
pub const GUri_listautoptr = [*c]GList;
pub const GUri_slistautoptr = [*c]GSList;
pub const GUri_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GUri(arg__ptr: ?*GUri) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_uri_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GUri(arg__ptr: [*c]?*GUri) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GUri(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GUri(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_uri_unref)))));
}
pub fn glib_slistautoptr_cleanup_GUri(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_uri_unref)))));
}
pub fn glib_queueautoptr_cleanup_GUri(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_uri_unref)))));
    }
}
pub const GType = gsize;
const union_unnamed_45 = extern union {
    v_int: gint,
    v_uint: guint,
    v_long: glong,
    v_ulong: gulong,
    v_int64: gint64,
    v_uint64: guint64,
    v_float: gfloat,
    v_double: gdouble,
    v_pointer: gpointer,
};
pub const struct__GValue = extern struct {
    g_type: GType,
    data: [2]union_unnamed_45,
};
pub const GValue = struct__GValue;
pub const union__GTypeCValue = opaque {};
pub const GTypeCValue = union__GTypeCValue;
pub const struct__GTypePlugin = opaque {};
pub const GTypePlugin = struct__GTypePlugin;
pub const struct__GTypeClass = extern struct {
    g_type: GType,
};
pub const GTypeClass = struct__GTypeClass;
pub const struct__GTypeInterface = extern struct {
    g_type: GType,
    g_instance_type: GType,
};
pub const GTypeInterface = struct__GTypeInterface;
pub const struct__GTypeInstance = extern struct {
    g_class: [*c]GTypeClass,
};
pub const GTypeInstance = struct__GTypeInstance;
pub const GBaseInitFunc = ?fn (gpointer) callconv(.C) void;
pub const GBaseFinalizeFunc = ?fn (gpointer) callconv(.C) void;
pub const GClassInitFunc = ?fn (gpointer, gpointer) callconv(.C) void;
pub const GClassFinalizeFunc = ?fn (gpointer, gpointer) callconv(.C) void;
pub const GInstanceInitFunc = ?fn ([*c]GTypeInstance, gpointer) callconv(.C) void;
pub const struct__GTypeValueTable = extern struct {
    value_init: ?fn ([*c]GValue) callconv(.C) void,
    value_free: ?fn ([*c]GValue) callconv(.C) void,
    value_copy: ?fn ([*c]const GValue, [*c]GValue) callconv(.C) void,
    value_peek_pointer: ?fn ([*c]const GValue) callconv(.C) gpointer,
    collect_format: [*c]const gchar,
    collect_value: ?fn ([*c]GValue, guint, ?*GTypeCValue, guint) callconv(.C) [*c]gchar,
    lcopy_format: [*c]const gchar,
    lcopy_value: ?fn ([*c]const GValue, guint, ?*GTypeCValue, guint) callconv(.C) [*c]gchar,
};
pub const GTypeValueTable = struct__GTypeValueTable;
pub const struct__GTypeInfo = extern struct {
    class_size: guint16,
    base_init: GBaseInitFunc,
    base_finalize: GBaseFinalizeFunc,
    class_init: GClassInitFunc,
    class_finalize: GClassFinalizeFunc,
    class_data: gconstpointer,
    instance_size: guint16,
    n_preallocs: guint16,
    instance_init: GInstanceInitFunc,
    value_table: [*c]const GTypeValueTable,
};
pub const GTypeInfo = struct__GTypeInfo;
pub const struct__GTypeFundamentalInfo = extern struct {
    type_flags: GTypeFundamentalFlags,
};
pub const GTypeFundamentalInfo = struct__GTypeFundamentalInfo;
pub const GInterfaceInitFunc = ?fn (gpointer, gpointer) callconv(.C) void;
pub const GInterfaceFinalizeFunc = ?fn (gpointer, gpointer) callconv(.C) void;
pub const struct__GInterfaceInfo = extern struct {
    interface_init: GInterfaceInitFunc,
    interface_finalize: GInterfaceFinalizeFunc,
    interface_data: gpointer,
};
pub const GInterfaceInfo = struct__GInterfaceInfo;
pub const struct__GTypeQuery = extern struct {
    type: GType,
    type_name: [*c]const gchar,
    class_size: guint,
    instance_size: guint,
};
pub const GTypeQuery = struct__GTypeQuery;
pub const G_TYPE_DEBUG_NONE: c_int = 0;
pub const G_TYPE_DEBUG_OBJECTS: c_int = 1;
pub const G_TYPE_DEBUG_SIGNALS: c_int = 2;
pub const G_TYPE_DEBUG_INSTANCE_COUNT: c_int = 4;
pub const G_TYPE_DEBUG_MASK: c_int = 7;
pub const GTypeDebugFlags = c_uint;
pub extern fn g_type_init() void;
pub extern fn g_type_init_with_debug_flags(debug_flags: GTypeDebugFlags) void;
pub extern fn g_type_name(@"type": GType) [*c]const gchar;
pub extern fn g_type_qname(@"type": GType) GQuark;
pub extern fn g_type_from_name(name: [*c]const gchar) GType;
pub extern fn g_type_parent(@"type": GType) GType;
pub extern fn g_type_depth(@"type": GType) guint;
pub extern fn g_type_next_base(leaf_type: GType, root_type: GType) GType;
pub extern fn g_type_is_a(@"type": GType, is_a_type: GType) gboolean;
pub extern fn g_type_class_ref(@"type": GType) gpointer;
pub extern fn g_type_class_peek(@"type": GType) gpointer;
pub extern fn g_type_class_peek_static(@"type": GType) gpointer;
pub extern fn g_type_class_unref(g_class: gpointer) void;
pub extern fn g_type_class_peek_parent(g_class: gpointer) gpointer;
pub extern fn g_type_interface_peek(instance_class: gpointer, iface_type: GType) gpointer;
pub extern fn g_type_interface_peek_parent(g_iface: gpointer) gpointer;
pub extern fn g_type_default_interface_ref(g_type: GType) gpointer;
pub extern fn g_type_default_interface_peek(g_type: GType) gpointer;
pub extern fn g_type_default_interface_unref(g_iface: gpointer) void;
pub extern fn g_type_children(@"type": GType, n_children: [*c]guint) [*c]GType;
pub extern fn g_type_interfaces(@"type": GType, n_interfaces: [*c]guint) [*c]GType;
pub extern fn g_type_set_qdata(@"type": GType, quark: GQuark, data: gpointer) void;
pub extern fn g_type_get_qdata(@"type": GType, quark: GQuark) gpointer;
pub extern fn g_type_query(@"type": GType, query: [*c]GTypeQuery) void;
pub extern fn g_type_get_instance_count(@"type": GType) c_int;
pub const GTypeClassCacheFunc = ?fn (gpointer, [*c]GTypeClass) callconv(.C) gboolean;
pub const GTypeInterfaceCheckFunc = ?fn (gpointer, gpointer) callconv(.C) void;
pub const G_TYPE_FLAG_CLASSED: c_int = 1;
pub const G_TYPE_FLAG_INSTANTIATABLE: c_int = 2;
pub const G_TYPE_FLAG_DERIVABLE: c_int = 4;
pub const G_TYPE_FLAG_DEEP_DERIVABLE: c_int = 8;
pub const GTypeFundamentalFlags = c_uint;
pub const G_TYPE_FLAG_ABSTRACT: c_int = 16;
pub const G_TYPE_FLAG_VALUE_ABSTRACT: c_int = 32;
pub const G_TYPE_FLAG_FINAL: c_int = 64;
pub const GTypeFlags = c_uint;
pub extern fn g_type_register_static(parent_type: GType, type_name: [*c]const gchar, info: [*c]const GTypeInfo, flags: GTypeFlags) GType;
pub extern fn g_type_register_static_simple(parent_type: GType, type_name: [*c]const gchar, class_size: guint, class_init: GClassInitFunc, instance_size: guint, instance_init: GInstanceInitFunc, flags: GTypeFlags) GType;
pub extern fn g_type_register_dynamic(parent_type: GType, type_name: [*c]const gchar, plugin: ?*GTypePlugin, flags: GTypeFlags) GType;
pub extern fn g_type_register_fundamental(type_id: GType, type_name: [*c]const gchar, info: [*c]const GTypeInfo, finfo: [*c]const GTypeFundamentalInfo, flags: GTypeFlags) GType;
pub extern fn g_type_add_interface_static(instance_type: GType, interface_type: GType, info: [*c]const GInterfaceInfo) void;
pub extern fn g_type_add_interface_dynamic(instance_type: GType, interface_type: GType, plugin: ?*GTypePlugin) void;
pub extern fn g_type_interface_add_prerequisite(interface_type: GType, prerequisite_type: GType) void;
pub extern fn g_type_interface_prerequisites(interface_type: GType, n_prerequisites: [*c]guint) [*c]GType;
pub extern fn g_type_interface_instantiatable_prerequisite(interface_type: GType) GType;
pub extern fn g_type_class_add_private(g_class: gpointer, private_size: gsize) void;
pub extern fn g_type_add_instance_private(class_type: GType, private_size: gsize) gint;
pub extern fn g_type_instance_get_private(instance: [*c]GTypeInstance, private_type: GType) gpointer;
pub extern fn g_type_class_adjust_private_offset(g_class: gpointer, private_size_or_offset: [*c]gint) void;
pub extern fn g_type_add_class_private(class_type: GType, private_size: gsize) void;
pub extern fn g_type_class_get_private(klass: [*c]GTypeClass, private_type: GType) gpointer;
pub extern fn g_type_class_get_instance_private_offset(g_class: gpointer) gint;
pub extern fn g_type_ensure(@"type": GType) void;
pub extern fn g_type_get_type_registration_serial() guint;
pub extern fn g_type_get_plugin(@"type": GType) ?*GTypePlugin;
pub extern fn g_type_interface_get_plugin(instance_type: GType, interface_type: GType) ?*GTypePlugin;
pub extern fn g_type_fundamental_next() GType;
pub extern fn g_type_fundamental(type_id: GType) GType;
pub extern fn g_type_create_instance(@"type": GType) [*c]GTypeInstance;
pub extern fn g_type_free_instance(instance: [*c]GTypeInstance) void;
pub extern fn g_type_add_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc) void;
pub extern fn g_type_remove_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc) void;
pub extern fn g_type_class_unref_uncached(g_class: gpointer) void;
pub extern fn g_type_add_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc) void;
pub extern fn g_type_remove_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc) void;
pub extern fn g_type_value_table_peek(@"type": GType) [*c]GTypeValueTable;
pub extern fn g_type_check_instance(instance: [*c]GTypeInstance) gboolean;
pub extern fn g_type_check_instance_cast(instance: [*c]GTypeInstance, iface_type: GType) [*c]GTypeInstance;
pub extern fn g_type_check_instance_is_a(instance: [*c]GTypeInstance, iface_type: GType) gboolean;
pub extern fn g_type_check_instance_is_fundamentally_a(instance: [*c]GTypeInstance, fundamental_type: GType) gboolean;
pub extern fn g_type_check_class_cast(g_class: [*c]GTypeClass, is_a_type: GType) [*c]GTypeClass;
pub extern fn g_type_check_class_is_a(g_class: [*c]GTypeClass, is_a_type: GType) gboolean;
pub extern fn g_type_check_is_value_type(@"type": GType) gboolean;
pub extern fn g_type_check_value(value: [*c]const GValue) gboolean;
pub extern fn g_type_check_value_holds(value: [*c]const GValue, @"type": GType) gboolean;
pub extern fn g_type_test_flags(@"type": GType, flags: guint) gboolean;
pub extern fn g_type_name_from_instance(instance: [*c]GTypeInstance) [*c]const gchar;
pub extern fn g_type_name_from_class(g_class: [*c]GTypeClass) [*c]const gchar;
pub const GValueTransform = ?fn ([*c]const GValue, [*c]GValue) callconv(.C) void;
pub extern fn g_value_init(value: [*c]GValue, g_type: GType) [*c]GValue;
pub extern fn g_value_copy(src_value: [*c]const GValue, dest_value: [*c]GValue) void;
pub extern fn g_value_reset(value: [*c]GValue) [*c]GValue;
pub extern fn g_value_unset(value: [*c]GValue) void;
pub extern fn g_value_set_instance(value: [*c]GValue, instance: gpointer) void;
pub extern fn g_value_init_from_instance(value: [*c]GValue, instance: gpointer) void;
pub extern fn g_value_fits_pointer(value: [*c]const GValue) gboolean;
pub extern fn g_value_peek_pointer(value: [*c]const GValue) gpointer;
pub extern fn g_value_type_compatible(src_type: GType, dest_type: GType) gboolean;
pub extern fn g_value_type_transformable(src_type: GType, dest_type: GType) gboolean;
pub extern fn g_value_transform(src_value: [*c]const GValue, dest_value: [*c]GValue) gboolean;
pub extern fn g_value_register_transform_func(src_type: GType, dest_type: GType, transform_func: GValueTransform) void;
pub const G_PARAM_READABLE: c_int = 1;
pub const G_PARAM_WRITABLE: c_int = 2;
pub const G_PARAM_READWRITE: c_int = 3;
pub const G_PARAM_CONSTRUCT: c_int = 4;
pub const G_PARAM_CONSTRUCT_ONLY: c_int = 8;
pub const G_PARAM_LAX_VALIDATION: c_int = 16;
pub const G_PARAM_STATIC_NAME: c_int = 32;
pub const G_PARAM_PRIVATE: c_int = 32;
pub const G_PARAM_STATIC_NICK: c_int = 64;
pub const G_PARAM_STATIC_BLURB: c_int = 128;
pub const G_PARAM_EXPLICIT_NOTIFY: c_int = 1073741824;
pub const G_PARAM_DEPRECATED: c_int = -2147483648;
pub const GParamFlags = c_int;
pub const struct__GParamSpec = extern struct {
    g_type_instance: GTypeInstance,
    name: [*c]const gchar,
    flags: GParamFlags,
    value_type: GType,
    owner_type: GType,
    _nick: [*c]gchar,
    _blurb: [*c]gchar,
    qdata: ?*GData,
    ref_count: guint,
    param_id: guint,
};
pub const GParamSpec = struct__GParamSpec;
pub const struct__GParamSpecClass = extern struct {
    g_type_class: GTypeClass,
    value_type: GType,
    finalize: ?fn ([*c]GParamSpec) callconv(.C) void,
    value_set_default: ?fn ([*c]GParamSpec, [*c]GValue) callconv(.C) void,
    value_validate: ?fn ([*c]GParamSpec, [*c]GValue) callconv(.C) gboolean,
    values_cmp: ?fn ([*c]GParamSpec, [*c]const GValue, [*c]const GValue) callconv(.C) gint,
    dummy: [4]gpointer,
};
pub const GParamSpecClass = struct__GParamSpecClass;
pub const struct__GParameter = extern struct {
    name: [*c]const gchar,
    value: GValue,
};
pub const GParameter = struct__GParameter;
pub const struct__GParamSpecPool = opaque {};
pub const GParamSpecPool = struct__GParamSpecPool;
pub extern fn g_param_spec_ref(pspec: [*c]GParamSpec) [*c]GParamSpec;
pub extern fn g_param_spec_unref(pspec: [*c]GParamSpec) void;
pub extern fn g_param_spec_sink(pspec: [*c]GParamSpec) void;
pub extern fn g_param_spec_ref_sink(pspec: [*c]GParamSpec) [*c]GParamSpec;
pub extern fn g_param_spec_get_qdata(pspec: [*c]GParamSpec, quark: GQuark) gpointer;
pub extern fn g_param_spec_set_qdata(pspec: [*c]GParamSpec, quark: GQuark, data: gpointer) void;
pub extern fn g_param_spec_set_qdata_full(pspec: [*c]GParamSpec, quark: GQuark, data: gpointer, destroy: GDestroyNotify) void;
pub extern fn g_param_spec_steal_qdata(pspec: [*c]GParamSpec, quark: GQuark) gpointer;
pub extern fn g_param_spec_get_redirect_target(pspec: [*c]GParamSpec) [*c]GParamSpec;
pub extern fn g_param_value_set_default(pspec: [*c]GParamSpec, value: [*c]GValue) void;
pub extern fn g_param_value_defaults(pspec: [*c]GParamSpec, value: [*c]const GValue) gboolean;
pub extern fn g_param_value_validate(pspec: [*c]GParamSpec, value: [*c]GValue) gboolean;
pub extern fn g_param_value_convert(pspec: [*c]GParamSpec, src_value: [*c]const GValue, dest_value: [*c]GValue, strict_validation: gboolean) gboolean;
pub extern fn g_param_values_cmp(pspec: [*c]GParamSpec, value1: [*c]const GValue, value2: [*c]const GValue) gint;
pub extern fn g_param_spec_get_name(pspec: [*c]GParamSpec) [*c]const gchar;
pub extern fn g_param_spec_get_nick(pspec: [*c]GParamSpec) [*c]const gchar;
pub extern fn g_param_spec_get_blurb(pspec: [*c]GParamSpec) [*c]const gchar;
pub extern fn g_value_set_param(value: [*c]GValue, param: [*c]GParamSpec) void;
pub extern fn g_value_get_param(value: [*c]const GValue) [*c]GParamSpec;
pub extern fn g_value_dup_param(value: [*c]const GValue) [*c]GParamSpec;
pub extern fn g_value_take_param(value: [*c]GValue, param: [*c]GParamSpec) void;
pub extern fn g_value_set_param_take_ownership(value: [*c]GValue, param: [*c]GParamSpec) void;
pub extern fn g_param_spec_get_default_value(pspec: [*c]GParamSpec) [*c]const GValue;
pub extern fn g_param_spec_get_name_quark(pspec: [*c]GParamSpec) GQuark;
pub const struct__GParamSpecTypeInfo = extern struct {
    instance_size: guint16,
    n_preallocs: guint16,
    instance_init: ?fn ([*c]GParamSpec) callconv(.C) void,
    value_type: GType,
    finalize: ?fn ([*c]GParamSpec) callconv(.C) void,
    value_set_default: ?fn ([*c]GParamSpec, [*c]GValue) callconv(.C) void,
    value_validate: ?fn ([*c]GParamSpec, [*c]GValue) callconv(.C) gboolean,
    values_cmp: ?fn ([*c]GParamSpec, [*c]const GValue, [*c]const GValue) callconv(.C) gint,
};
pub const GParamSpecTypeInfo = struct__GParamSpecTypeInfo;
pub extern fn g_param_type_register_static(name: [*c]const gchar, pspec_info: [*c]const GParamSpecTypeInfo) GType;
pub extern fn g_param_spec_is_valid_name(name: [*c]const gchar) gboolean;
pub extern fn _g_param_type_register_static_constant(name: [*c]const gchar, pspec_info: [*c]const GParamSpecTypeInfo, opt_type: GType) GType;
pub extern fn g_param_spec_internal(param_type: GType, name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, flags: GParamFlags) gpointer;
pub extern fn g_param_spec_pool_new(type_prefixing: gboolean) ?*GParamSpecPool;
pub extern fn g_param_spec_pool_insert(pool: ?*GParamSpecPool, pspec: [*c]GParamSpec, owner_type: GType) void;
pub extern fn g_param_spec_pool_remove(pool: ?*GParamSpecPool, pspec: [*c]GParamSpec) void;
pub extern fn g_param_spec_pool_lookup(pool: ?*GParamSpecPool, param_name: [*c]const gchar, owner_type: GType, walk_ancestors: gboolean) [*c]GParamSpec;
pub extern fn g_param_spec_pool_list_owned(pool: ?*GParamSpecPool, owner_type: GType) [*c]GList;
pub extern fn g_param_spec_pool_list(pool: ?*GParamSpecPool, owner_type: GType, n_pspecs_p: [*c]guint) [*c][*c]GParamSpec; // /usr/include/glib-2.0/gobject/gclosure.h:182:9: warning: struct demoted to opaque type - has bitfield
pub const struct__GClosure = opaque {};
pub const GClosure = struct__GClosure;
pub const GClosureNotify = ?fn (gpointer, ?*GClosure) callconv(.C) void;
pub const struct__GClosureNotifyData = extern struct {
    data: gpointer,
    notify: GClosureNotify,
};
pub const GClosureNotifyData = struct__GClosureNotifyData;
pub const GCallback = ?fn () callconv(.C) void;
pub const GClosureMarshal = ?fn (?*GClosure, [*c]GValue, guint, [*c]const GValue, gpointer, gpointer) callconv(.C) void;
pub const GVaClosureMarshal = ?fn (?*GClosure, [*c]GValue, gpointer, va_list, gpointer, c_int, [*c]GType) callconv(.C) void;
pub const struct__GCClosure = extern struct {
    closure: GClosure,
    callback: gpointer,
};
pub const GCClosure = struct__GCClosure;
pub extern fn g_cclosure_new(callback_func: GCallback, user_data: gpointer, destroy_data: GClosureNotify) ?*GClosure;
pub extern fn g_cclosure_new_swap(callback_func: GCallback, user_data: gpointer, destroy_data: GClosureNotify) ?*GClosure;
pub extern fn g_signal_type_cclosure_new(itype: GType, struct_offset: guint) ?*GClosure;
pub extern fn g_closure_ref(closure: ?*GClosure) ?*GClosure;
pub extern fn g_closure_sink(closure: ?*GClosure) void;
pub extern fn g_closure_unref(closure: ?*GClosure) void;
pub extern fn g_closure_new_simple(sizeof_closure: guint, data: gpointer) ?*GClosure;
pub extern fn g_closure_add_finalize_notifier(closure: ?*GClosure, notify_data: gpointer, notify_func: GClosureNotify) void;
pub extern fn g_closure_remove_finalize_notifier(closure: ?*GClosure, notify_data: gpointer, notify_func: GClosureNotify) void;
pub extern fn g_closure_add_invalidate_notifier(closure: ?*GClosure, notify_data: gpointer, notify_func: GClosureNotify) void;
pub extern fn g_closure_remove_invalidate_notifier(closure: ?*GClosure, notify_data: gpointer, notify_func: GClosureNotify) void;
pub extern fn g_closure_add_marshal_guards(closure: ?*GClosure, pre_marshal_data: gpointer, pre_marshal_notify: GClosureNotify, post_marshal_data: gpointer, post_marshal_notify: GClosureNotify) void;
pub extern fn g_closure_set_marshal(closure: ?*GClosure, marshal: GClosureMarshal) void;
pub extern fn g_closure_set_meta_marshal(closure: ?*GClosure, marshal_data: gpointer, meta_marshal: GClosureMarshal) void;
pub extern fn g_closure_invalidate(closure: ?*GClosure) void;
pub extern fn g_closure_invoke(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer) void;
pub extern fn g_cclosure_marshal_generic(closure: ?*GClosure, return_gvalue: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_generic_va(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args_list: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__VOID(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__VOIDv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__BOOLEAN(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__BOOLEANv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__CHAR(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__CHARv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__UCHAR(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__UCHARv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__INT(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__INTv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__UINT(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__UINTv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__LONG(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__LONGv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__ULONG(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__ULONGv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__ENUM(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__ENUMv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__FLAGS(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__FLAGSv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__FLOAT(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__FLOATv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__DOUBLE(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__DOUBLEv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__STRING(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__STRINGv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__PARAM(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__PARAMv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__BOXED(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__BOXEDv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__POINTER(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__POINTERv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__OBJECT(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__OBJECTv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__VARIANT(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__VARIANTv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__UINT_POINTER(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__UINT_POINTERv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_BOOLEAN__FLAGS(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_BOOLEAN__FLAGSv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_STRING__OBJECT_POINTER(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_STRING__OBJECT_POINTERv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_BOOLEAN__BOXED_BOXED(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub const struct__GSignalQuery = extern struct {
    signal_id: guint,
    signal_name: [*c]const gchar,
    itype: GType,
    signal_flags: GSignalFlags,
    return_type: GType,
    n_params: guint,
    param_types: [*c]const GType,
};
pub const GSignalQuery = struct__GSignalQuery;
pub const struct__GSignalInvocationHint = extern struct {
    signal_id: guint,
    detail: GQuark,
    run_type: GSignalFlags,
};
pub const GSignalInvocationHint = struct__GSignalInvocationHint;
pub const GSignalCMarshaller = GClosureMarshal;
pub const GSignalCVaMarshaller = GVaClosureMarshal;
pub const GSignalEmissionHook = ?fn ([*c]GSignalInvocationHint, guint, [*c]const GValue, gpointer) callconv(.C) gboolean;
pub const GSignalAccumulator = ?fn ([*c]GSignalInvocationHint, [*c]GValue, [*c]const GValue, gpointer) callconv(.C) gboolean;
pub const G_SIGNAL_RUN_FIRST: c_int = 1;
pub const G_SIGNAL_RUN_LAST: c_int = 2;
pub const G_SIGNAL_RUN_CLEANUP: c_int = 4;
pub const G_SIGNAL_NO_RECURSE: c_int = 8;
pub const G_SIGNAL_DETAILED: c_int = 16;
pub const G_SIGNAL_ACTION: c_int = 32;
pub const G_SIGNAL_NO_HOOKS: c_int = 64;
pub const G_SIGNAL_MUST_COLLECT: c_int = 128;
pub const G_SIGNAL_DEPRECATED: c_int = 256;
pub const G_SIGNAL_ACCUMULATOR_FIRST_RUN: c_int = 131072;
pub const GSignalFlags = c_uint;
pub const G_CONNECT_AFTER: c_int = 1;
pub const G_CONNECT_SWAPPED: c_int = 2;
pub const GConnectFlags = c_uint;
pub const G_SIGNAL_MATCH_ID: c_int = 1;
pub const G_SIGNAL_MATCH_DETAIL: c_int = 2;
pub const G_SIGNAL_MATCH_CLOSURE: c_int = 4;
pub const G_SIGNAL_MATCH_FUNC: c_int = 8;
pub const G_SIGNAL_MATCH_DATA: c_int = 16;
pub const G_SIGNAL_MATCH_UNBLOCKED: c_int = 32;
pub const GSignalMatchType = c_uint;
pub extern fn g_signal_newv(signal_name: [*c]const gchar, itype: GType, signal_flags: GSignalFlags, class_closure: ?*GClosure, accumulator: GSignalAccumulator, accu_data: gpointer, c_marshaller: GSignalCMarshaller, return_type: GType, n_params: guint, param_types: [*c]GType) guint;
pub extern fn g_signal_new_valist(signal_name: [*c]const gchar, itype: GType, signal_flags: GSignalFlags, class_closure: ?*GClosure, accumulator: GSignalAccumulator, accu_data: gpointer, c_marshaller: GSignalCMarshaller, return_type: GType, n_params: guint, args: va_list) guint;
pub extern fn g_signal_new(signal_name: [*c]const gchar, itype: GType, signal_flags: GSignalFlags, class_offset: guint, accumulator: GSignalAccumulator, accu_data: gpointer, c_marshaller: GSignalCMarshaller, return_type: GType, n_params: guint, ...) guint;
pub extern fn g_signal_new_class_handler(signal_name: [*c]const gchar, itype: GType, signal_flags: GSignalFlags, class_handler: GCallback, accumulator: GSignalAccumulator, accu_data: gpointer, c_marshaller: GSignalCMarshaller, return_type: GType, n_params: guint, ...) guint;
pub extern fn g_signal_set_va_marshaller(signal_id: guint, instance_type: GType, va_marshaller: GSignalCVaMarshaller) void;
pub extern fn g_signal_emitv(instance_and_params: [*c]const GValue, signal_id: guint, detail: GQuark, return_value: [*c]GValue) void;
pub extern fn g_signal_emit_valist(instance: gpointer, signal_id: guint, detail: GQuark, var_args: va_list) void;
pub extern fn g_signal_emit(instance: gpointer, signal_id: guint, detail: GQuark, ...) void;
pub extern fn g_signal_emit_by_name(instance: gpointer, detailed_signal: [*c]const gchar, ...) void;
pub extern fn g_signal_lookup(name: [*c]const gchar, itype: GType) guint;
pub extern fn g_signal_name(signal_id: guint) [*c]const gchar;
pub extern fn g_signal_query(signal_id: guint, query: [*c]GSignalQuery) void;
pub extern fn g_signal_list_ids(itype: GType, n_ids: [*c]guint) [*c]guint;
pub extern fn g_signal_is_valid_name(name: [*c]const gchar) gboolean;
pub extern fn g_signal_parse_name(detailed_signal: [*c]const gchar, itype: GType, signal_id_p: [*c]guint, detail_p: [*c]GQuark, force_detail_quark: gboolean) gboolean;
pub extern fn g_signal_get_invocation_hint(instance: gpointer) [*c]GSignalInvocationHint;
pub extern fn g_signal_stop_emission(instance: gpointer, signal_id: guint, detail: GQuark) void;
pub extern fn g_signal_stop_emission_by_name(instance: gpointer, detailed_signal: [*c]const gchar) void;
pub extern fn g_signal_add_emission_hook(signal_id: guint, detail: GQuark, hook_func: GSignalEmissionHook, hook_data: gpointer, data_destroy: GDestroyNotify) gulong;
pub extern fn g_signal_remove_emission_hook(signal_id: guint, hook_id: gulong) void;
pub extern fn g_signal_has_handler_pending(instance: gpointer, signal_id: guint, detail: GQuark, may_be_blocked: gboolean) gboolean;
pub extern fn g_signal_connect_closure_by_id(instance: gpointer, signal_id: guint, detail: GQuark, closure: ?*GClosure, after: gboolean) gulong;
pub extern fn g_signal_connect_closure(instance: gpointer, detailed_signal: [*c]const gchar, closure: ?*GClosure, after: gboolean) gulong;
pub extern fn g_signal_connect_data(instance: gpointer, detailed_signal: [*c]const gchar, c_handler: GCallback, data: gpointer, destroy_data: GClosureNotify, connect_flags: GConnectFlags) gulong;
pub extern fn g_signal_handler_block(instance: gpointer, handler_id: gulong) void;
pub extern fn g_signal_handler_unblock(instance: gpointer, handler_id: gulong) void;
pub extern fn g_signal_handler_disconnect(instance: gpointer, handler_id: gulong) void;
pub extern fn g_signal_handler_is_connected(instance: gpointer, handler_id: gulong) gboolean;
pub extern fn g_signal_handler_find(instance: gpointer, mask: GSignalMatchType, signal_id: guint, detail: GQuark, closure: ?*GClosure, func: gpointer, data: gpointer) gulong;
pub extern fn g_signal_handlers_block_matched(instance: gpointer, mask: GSignalMatchType, signal_id: guint, detail: GQuark, closure: ?*GClosure, func: gpointer, data: gpointer) guint;
pub extern fn g_signal_handlers_unblock_matched(instance: gpointer, mask: GSignalMatchType, signal_id: guint, detail: GQuark, closure: ?*GClosure, func: gpointer, data: gpointer) guint;
pub extern fn g_signal_handlers_disconnect_matched(instance: gpointer, mask: GSignalMatchType, signal_id: guint, detail: GQuark, closure: ?*GClosure, func: gpointer, data: gpointer) guint;
pub extern fn g_clear_signal_handler(handler_id_ptr: [*c]gulong, instance: gpointer) void;
pub extern fn g_signal_override_class_closure(signal_id: guint, instance_type: GType, class_closure: ?*GClosure) void;
pub extern fn g_signal_override_class_handler(signal_name: [*c]const gchar, instance_type: GType, class_handler: GCallback) void;
pub extern fn g_signal_chain_from_overridden(instance_and_params: [*c]const GValue, return_value: [*c]GValue) void;
pub extern fn g_signal_chain_from_overridden_handler(instance: gpointer, ...) void;
pub extern fn g_signal_accumulator_true_handled(ihint: [*c]GSignalInvocationHint, return_accu: [*c]GValue, handler_return: [*c]const GValue, dummy: gpointer) gboolean;
pub extern fn g_signal_accumulator_first_wins(ihint: [*c]GSignalInvocationHint, return_accu: [*c]GValue, handler_return: [*c]const GValue, dummy: gpointer) gboolean;
pub extern fn g_signal_handlers_destroy(instance: gpointer) void;
pub extern fn _g_signals_destroy(itype: GType) void;
pub extern fn g_date_get_type() GType;
pub extern fn g_strv_get_type() GType;
pub extern fn g_gstring_get_type() GType;
pub extern fn g_hash_table_get_type() GType;
pub extern fn g_array_get_type() GType;
pub extern fn g_byte_array_get_type() GType;
pub extern fn g_ptr_array_get_type() GType;
pub extern fn g_bytes_get_type() GType;
pub extern fn g_variant_type_get_gtype() GType;
pub extern fn g_regex_get_type() GType;
pub extern fn g_match_info_get_type() GType;
pub extern fn g_error_get_type() GType;
pub extern fn g_date_time_get_type() GType;
pub extern fn g_time_zone_get_type() GType;
pub extern fn g_io_channel_get_type() GType;
pub extern fn g_io_condition_get_type() GType;
pub extern fn g_variant_builder_get_type() GType;
pub extern fn g_variant_dict_get_type() GType;
pub extern fn g_key_file_get_type() GType;
pub extern fn g_main_loop_get_type() GType;
pub extern fn g_main_context_get_type() GType;
pub extern fn g_source_get_type() GType;
pub extern fn g_pollfd_get_type() GType;
pub extern fn g_thread_get_type() GType;
pub extern fn g_checksum_get_type() GType;
pub extern fn g_markup_parse_context_get_type() GType;
pub extern fn g_mapped_file_get_type() GType;
pub extern fn g_option_group_get_type() GType;
pub extern fn g_uri_get_type() GType;
pub extern fn g_tree_get_type() GType;
pub extern fn g_pattern_spec_get_type() GType;
pub extern fn g_variant_get_gtype() GType;
pub const GBoxedCopyFunc = ?fn (gpointer) callconv(.C) gpointer;
pub const GBoxedFreeFunc = ?fn (gpointer) callconv(.C) void;
pub extern fn g_boxed_copy(boxed_type: GType, src_boxed: gconstpointer) gpointer;
pub extern fn g_boxed_free(boxed_type: GType, boxed: gpointer) void;
pub extern fn g_value_set_boxed(value: [*c]GValue, v_boxed: gconstpointer) void;
pub extern fn g_value_set_static_boxed(value: [*c]GValue, v_boxed: gconstpointer) void;
pub extern fn g_value_take_boxed(value: [*c]GValue, v_boxed: gconstpointer) void;
pub extern fn g_value_set_boxed_take_ownership(value: [*c]GValue, v_boxed: gconstpointer) void;
pub extern fn g_value_get_boxed(value: [*c]const GValue) gpointer;
pub extern fn g_value_dup_boxed(value: [*c]const GValue) gpointer;
pub extern fn g_boxed_type_register_static(name: [*c]const gchar, boxed_copy: GBoxedCopyFunc, boxed_free: GBoxedFreeFunc) GType;
pub extern fn g_closure_get_type() GType;
pub extern fn g_value_get_type() GType;
pub const struct__GObject = extern struct {
    g_type_instance: GTypeInstance,
    ref_count: guint,
    qdata: ?*GData,
};
pub const GObject = struct__GObject;
pub const struct__GObjectConstructParam = extern struct {
    pspec: [*c]GParamSpec,
    value: [*c]GValue,
};
pub const GObjectConstructParam = struct__GObjectConstructParam;
pub const struct__GObjectClass = extern struct {
    g_type_class: GTypeClass,
    construct_properties: [*c]GSList,
    constructor: ?fn (GType, guint, [*c]GObjectConstructParam) callconv(.C) [*c]GObject,
    set_property: ?fn ([*c]GObject, guint, [*c]const GValue, [*c]GParamSpec) callconv(.C) void,
    get_property: ?fn ([*c]GObject, guint, [*c]GValue, [*c]GParamSpec) callconv(.C) void,
    dispose: ?fn ([*c]GObject) callconv(.C) void,
    finalize: ?fn ([*c]GObject) callconv(.C) void,
    dispatch_properties_changed: ?fn ([*c]GObject, guint, [*c][*c]GParamSpec) callconv(.C) void,
    notify: ?fn ([*c]GObject, [*c]GParamSpec) callconv(.C) void,
    constructed: ?fn ([*c]GObject) callconv(.C) void,
    flags: gsize,
    pdummy: [6]gpointer,
};
pub const GObjectClass = struct__GObjectClass;
pub const GInitiallyUnowned = struct__GObject;
pub const GInitiallyUnownedClass = struct__GObjectClass;
pub const GObjectGetPropertyFunc = ?fn ([*c]GObject, guint, [*c]GValue, [*c]GParamSpec) callconv(.C) void;
pub const GObjectSetPropertyFunc = ?fn ([*c]GObject, guint, [*c]const GValue, [*c]GParamSpec) callconv(.C) void;
pub const GObjectFinalizeFunc = ?fn ([*c]GObject) callconv(.C) void;
pub const GWeakNotify = ?fn (gpointer, [*c]GObject) callconv(.C) void;
pub extern fn g_initially_unowned_get_type() GType;
pub extern fn g_object_class_install_property(oclass: [*c]GObjectClass, property_id: guint, pspec: [*c]GParamSpec) void;
pub extern fn g_object_class_find_property(oclass: [*c]GObjectClass, property_name: [*c]const gchar) [*c]GParamSpec;
pub extern fn g_object_class_list_properties(oclass: [*c]GObjectClass, n_properties: [*c]guint) [*c][*c]GParamSpec;
pub extern fn g_object_class_override_property(oclass: [*c]GObjectClass, property_id: guint, name: [*c]const gchar) void;
pub extern fn g_object_class_install_properties(oclass: [*c]GObjectClass, n_pspecs: guint, pspecs: [*c][*c]GParamSpec) void;
pub extern fn g_object_interface_install_property(g_iface: gpointer, pspec: [*c]GParamSpec) void;
pub extern fn g_object_interface_find_property(g_iface: gpointer, property_name: [*c]const gchar) [*c]GParamSpec;
pub extern fn g_object_interface_list_properties(g_iface: gpointer, n_properties_p: [*c]guint) [*c][*c]GParamSpec;
pub extern fn g_object_get_type() GType;
pub extern fn g_object_new(object_type: GType, first_property_name: [*c]const gchar, ...) gpointer;
pub extern fn g_object_new_with_properties(object_type: GType, n_properties: guint, names: [*c][*c]const u8, values: [*c]const GValue) [*c]GObject;
pub extern fn g_object_newv(object_type: GType, n_parameters: guint, parameters: [*c]GParameter) gpointer;
pub extern fn g_object_new_valist(object_type: GType, first_property_name: [*c]const gchar, var_args: va_list) [*c]GObject;
pub extern fn g_object_set(object: gpointer, first_property_name: [*c]const gchar, ...) void;
pub extern fn g_object_get(object: gpointer, first_property_name: [*c]const gchar, ...) void;
pub extern fn g_object_connect(object: gpointer, signal_spec: [*c]const gchar, ...) gpointer;
pub extern fn g_object_disconnect(object: gpointer, signal_spec: [*c]const gchar, ...) void;
pub extern fn g_object_setv(object: [*c]GObject, n_properties: guint, names: [*c][*c]const gchar, values: [*c]const GValue) void;
pub extern fn g_object_set_valist(object: [*c]GObject, first_property_name: [*c]const gchar, var_args: va_list) void;
pub extern fn g_object_getv(object: [*c]GObject, n_properties: guint, names: [*c][*c]const gchar, values: [*c]GValue) void;
pub extern fn g_object_get_valist(object: [*c]GObject, first_property_name: [*c]const gchar, var_args: va_list) void;
pub extern fn g_object_set_property(object: [*c]GObject, property_name: [*c]const gchar, value: [*c]const GValue) void;
pub extern fn g_object_get_property(object: [*c]GObject, property_name: [*c]const gchar, value: [*c]GValue) void;
pub extern fn g_object_freeze_notify(object: [*c]GObject) void;
pub extern fn g_object_notify(object: [*c]GObject, property_name: [*c]const gchar) void;
pub extern fn g_object_notify_by_pspec(object: [*c]GObject, pspec: [*c]GParamSpec) void;
pub extern fn g_object_thaw_notify(object: [*c]GObject) void;
pub extern fn g_object_is_floating(object: gpointer) gboolean;
pub extern fn g_object_ref_sink(object: gpointer) gpointer;
pub extern fn g_object_take_ref(object: gpointer) gpointer;
pub extern fn g_object_ref(object: gpointer) gpointer;
pub extern fn g_object_unref(object: gpointer) void;
pub extern fn g_object_weak_ref(object: [*c]GObject, notify: GWeakNotify, data: gpointer) void;
pub extern fn g_object_weak_unref(object: [*c]GObject, notify: GWeakNotify, data: gpointer) void;
pub extern fn g_object_add_weak_pointer(object: [*c]GObject, weak_pointer_location: [*c]gpointer) void;
pub extern fn g_object_remove_weak_pointer(object: [*c]GObject, weak_pointer_location: [*c]gpointer) void;
pub const GToggleNotify = ?fn (gpointer, [*c]GObject, gboolean) callconv(.C) void;
pub extern fn g_object_add_toggle_ref(object: [*c]GObject, notify: GToggleNotify, data: gpointer) void;
pub extern fn g_object_remove_toggle_ref(object: [*c]GObject, notify: GToggleNotify, data: gpointer) void;
pub extern fn g_object_get_qdata(object: [*c]GObject, quark: GQuark) gpointer;
pub extern fn g_object_set_qdata(object: [*c]GObject, quark: GQuark, data: gpointer) void;
pub extern fn g_object_set_qdata_full(object: [*c]GObject, quark: GQuark, data: gpointer, destroy: GDestroyNotify) void;
pub extern fn g_object_steal_qdata(object: [*c]GObject, quark: GQuark) gpointer;
pub extern fn g_object_dup_qdata(object: [*c]GObject, quark: GQuark, dup_func: GDuplicateFunc, user_data: gpointer) gpointer;
pub extern fn g_object_replace_qdata(object: [*c]GObject, quark: GQuark, oldval: gpointer, newval: gpointer, destroy: GDestroyNotify, old_destroy: [*c]GDestroyNotify) gboolean;
pub extern fn g_object_get_data(object: [*c]GObject, key: [*c]const gchar) gpointer;
pub extern fn g_object_set_data(object: [*c]GObject, key: [*c]const gchar, data: gpointer) void;
pub extern fn g_object_set_data_full(object: [*c]GObject, key: [*c]const gchar, data: gpointer, destroy: GDestroyNotify) void;
pub extern fn g_object_steal_data(object: [*c]GObject, key: [*c]const gchar) gpointer;
pub extern fn g_object_dup_data(object: [*c]GObject, key: [*c]const gchar, dup_func: GDuplicateFunc, user_data: gpointer) gpointer;
pub extern fn g_object_replace_data(object: [*c]GObject, key: [*c]const gchar, oldval: gpointer, newval: gpointer, destroy: GDestroyNotify, old_destroy: [*c]GDestroyNotify) gboolean;
pub extern fn g_object_watch_closure(object: [*c]GObject, closure: ?*GClosure) void;
pub extern fn g_cclosure_new_object(callback_func: GCallback, object: [*c]GObject) ?*GClosure;
pub extern fn g_cclosure_new_object_swap(callback_func: GCallback, object: [*c]GObject) ?*GClosure;
pub extern fn g_closure_new_object(sizeof_closure: guint, object: [*c]GObject) ?*GClosure;
pub extern fn g_value_set_object(value: [*c]GValue, v_object: gpointer) void;
pub extern fn g_value_get_object(value: [*c]const GValue) gpointer;
pub extern fn g_value_dup_object(value: [*c]const GValue) gpointer;
pub extern fn g_signal_connect_object(instance: gpointer, detailed_signal: [*c]const gchar, c_handler: GCallback, gobject: gpointer, connect_flags: GConnectFlags) gulong;
pub extern fn g_object_force_floating(object: [*c]GObject) void;
pub extern fn g_object_run_dispose(object: [*c]GObject) void;
pub extern fn g_value_take_object(value: [*c]GValue, v_object: gpointer) void;
pub extern fn g_value_set_object_take_ownership(value: [*c]GValue, v_object: gpointer) void;
pub extern fn g_object_compat_control(what: gsize, data: gpointer) gsize;
pub extern fn g_clear_object(object_ptr: [*c][*c]GObject) void;
pub fn g_set_object(arg_object_ptr: [*c][*c]GObject, arg_new_object: [*c]GObject) callconv(.C) gboolean {
    var object_ptr = arg_object_ptr;
    var new_object = arg_new_object;
    var old_object: [*c]GObject = object_ptr.*;
    if (old_object == new_object) return @as(c_int, 0);
    if (new_object != @ptrCast([*c]GObject, @alignCast(@import("std").meta.alignment([*c]GObject), @intToPtr(?*anyopaque, @as(c_int, 0))))) {
        _ = @ptrCast(@TypeOf(new_object), @alignCast(@import("std").meta.alignment(@TypeOf(new_object)), g_object_ref(@ptrCast(gpointer, new_object))));
    }
    object_ptr.* = new_object;
    if (old_object != @ptrCast([*c]GObject, @alignCast(@import("std").meta.alignment([*c]GObject), @intToPtr(?*anyopaque, @as(c_int, 0))))) {
        g_object_unref(@ptrCast(gpointer, old_object));
    }
    return @boolToInt(!(@as(c_int, 0) != 0));
}
pub fn g_assert_finalize_object(arg_object: [*c]GObject) callconv(.C) void {
    var object = arg_object;
    var weak_pointer: gpointer = @ptrCast(gpointer, object);
    while (true) {
        if (g_type_check_instance_is_fundamentally_a(@ptrCast([*c]GTypeInstance, @alignCast(@import("std").meta.alignment([*c]GTypeInstance), weak_pointer)), @bitCast(GType, @as(c_long, @as(c_int, 20) << @intCast(@import("std").math.Log2Int(c_int), @as(c_int, 2))))) != 0) {} else {
            g_assertion_message(@intToPtr([*c]gchar, @as(c_int, 0)), "/usr/include/glib-2.0/gobject/gobject.h", @as(c_int, 812), "g_assert_finalize_object", "'G_IS_OBJECT (weak_pointer)' should be TRUE");
        }
        if (!false) break;
    }
    g_object_add_weak_pointer(object, &weak_pointer);
    g_object_unref(weak_pointer);
    while (true) {
        if (weak_pointer == @intToPtr(?*anyopaque, @as(c_int, 0))) {} else {
            g_assertion_message(@intToPtr([*c]gchar, @as(c_int, 0)), "/usr/include/glib-2.0/gobject/gobject.h", @as(c_int, 815), "g_assert_finalize_object", "'weak_pointer' should be NULL");
        }
        if (!false) break;
    }
}
pub fn g_clear_weak_pointer(arg_weak_pointer_location: [*c]gpointer) callconv(.C) void {
    var weak_pointer_location = arg_weak_pointer_location;
    var object: [*c]GObject = @ptrCast([*c]GObject, @alignCast(@import("std").meta.alignment([*c]GObject), weak_pointer_location.*));
    if (object != @ptrCast([*c]GObject, @alignCast(@import("std").meta.alignment([*c]GObject), @intToPtr(?*anyopaque, @as(c_int, 0))))) {
        g_object_remove_weak_pointer(object, weak_pointer_location);
        weak_pointer_location.* = @intToPtr(?*anyopaque, @as(c_int, 0));
    }
}
pub fn g_set_weak_pointer(arg_weak_pointer_location: [*c]gpointer, arg_new_object: [*c]GObject) callconv(.C) gboolean {
    var weak_pointer_location = arg_weak_pointer_location;
    var new_object = arg_new_object;
    var old_object: [*c]GObject = @ptrCast([*c]GObject, @alignCast(@import("std").meta.alignment([*c]GObject), weak_pointer_location.*));
    if (old_object == new_object) return @as(c_int, 0);
    if (old_object != @ptrCast([*c]GObject, @alignCast(@import("std").meta.alignment([*c]GObject), @intToPtr(?*anyopaque, @as(c_int, 0))))) {
        g_object_remove_weak_pointer(old_object, weak_pointer_location);
    }
    weak_pointer_location.* = @ptrCast(gpointer, new_object);
    if (new_object != @ptrCast([*c]GObject, @alignCast(@import("std").meta.alignment([*c]GObject), @intToPtr(?*anyopaque, @as(c_int, 0))))) {
        g_object_add_weak_pointer(new_object, weak_pointer_location);
    }
    return @boolToInt(!(@as(c_int, 0) != 0));
}
const union_unnamed_46 = extern union {
    p: gpointer,
};
pub const GWeakRef = extern struct {
    priv: union_unnamed_46,
};
pub extern fn g_weak_ref_init(weak_ref: [*c]GWeakRef, object: gpointer) void;
pub extern fn g_weak_ref_clear(weak_ref: [*c]GWeakRef) void;
pub extern fn g_weak_ref_get(weak_ref: [*c]GWeakRef) gpointer;
pub extern fn g_weak_ref_set(weak_ref: [*c]GWeakRef, object: gpointer) void;
pub const struct__GBinding = opaque {};
pub const GBinding = struct__GBinding;
pub const GBindingTransformFunc = ?fn (?*GBinding, [*c]const GValue, [*c]GValue, gpointer) callconv(.C) gboolean;
pub const G_BINDING_DEFAULT: c_int = 0;
pub const G_BINDING_BIDIRECTIONAL: c_int = 1;
pub const G_BINDING_SYNC_CREATE: c_int = 2;
pub const G_BINDING_INVERT_BOOLEAN: c_int = 4;
pub const GBindingFlags = c_uint;
pub extern fn g_binding_flags_get_type() GType;
pub extern fn g_binding_get_type() GType;
pub extern fn g_binding_get_flags(binding: ?*GBinding) GBindingFlags;
pub extern fn g_binding_get_source(binding: ?*GBinding) [*c]GObject;
pub extern fn g_binding_dup_source(binding: ?*GBinding) [*c]GObject;
pub extern fn g_binding_get_target(binding: ?*GBinding) [*c]GObject;
pub extern fn g_binding_dup_target(binding: ?*GBinding) [*c]GObject;
pub extern fn g_binding_get_source_property(binding: ?*GBinding) [*c]const gchar;
pub extern fn g_binding_get_target_property(binding: ?*GBinding) [*c]const gchar;
pub extern fn g_binding_unbind(binding: ?*GBinding) void;
pub extern fn g_object_bind_property(source: gpointer, source_property: [*c]const gchar, target: gpointer, target_property: [*c]const gchar, flags: GBindingFlags) ?*GBinding;
pub extern fn g_object_bind_property_full(source: gpointer, source_property: [*c]const gchar, target: gpointer, target_property: [*c]const gchar, flags: GBindingFlags, transform_to: GBindingTransformFunc, transform_from: GBindingTransformFunc, user_data: gpointer, notify: GDestroyNotify) ?*GBinding;
pub extern fn g_object_bind_property_with_closures(source: gpointer, source_property: [*c]const gchar, target: gpointer, target_property: [*c]const gchar, flags: GBindingFlags, transform_to: ?*GClosure, transform_from: ?*GClosure) ?*GBinding;
pub const struct__GBindingGroup = opaque {};
pub const GBindingGroup = struct__GBindingGroup;
pub extern fn g_binding_group_get_type() GType;
pub extern fn g_binding_group_new() ?*GBindingGroup;
pub extern fn g_binding_group_dup_source(self: ?*GBindingGroup) gpointer;
pub extern fn g_binding_group_set_source(self: ?*GBindingGroup, source: gpointer) void;
pub extern fn g_binding_group_bind(self: ?*GBindingGroup, source_property: [*c]const gchar, target: gpointer, target_property: [*c]const gchar, flags: GBindingFlags) void;
pub extern fn g_binding_group_bind_full(self: ?*GBindingGroup, source_property: [*c]const gchar, target: gpointer, target_property: [*c]const gchar, flags: GBindingFlags, transform_to: GBindingTransformFunc, transform_from: GBindingTransformFunc, user_data: gpointer, user_data_destroy: GDestroyNotify) void;
pub extern fn g_binding_group_bind_with_closures(self: ?*GBindingGroup, source_property: [*c]const gchar, target: gpointer, target_property: [*c]const gchar, flags: GBindingFlags, transform_to: ?*GClosure, transform_from: ?*GClosure) void;
pub const struct__GEnumValue = extern struct {
    value: gint,
    value_name: [*c]const gchar,
    value_nick: [*c]const gchar,
};
pub const GEnumValue = struct__GEnumValue;
pub const struct__GEnumClass = extern struct {
    g_type_class: GTypeClass,
    minimum: gint,
    maximum: gint,
    n_values: guint,
    values: [*c]GEnumValue,
};
pub const GEnumClass = struct__GEnumClass;
pub const struct__GFlagsValue = extern struct {
    value: guint,
    value_name: [*c]const gchar,
    value_nick: [*c]const gchar,
};
pub const GFlagsValue = struct__GFlagsValue;
pub const struct__GFlagsClass = extern struct {
    g_type_class: GTypeClass,
    mask: guint,
    n_values: guint,
    values: [*c]GFlagsValue,
};
pub const GFlagsClass = struct__GFlagsClass;
pub extern fn g_enum_get_value(enum_class: [*c]GEnumClass, value: gint) [*c]GEnumValue;
pub extern fn g_enum_get_value_by_name(enum_class: [*c]GEnumClass, name: [*c]const gchar) [*c]GEnumValue;
pub extern fn g_enum_get_value_by_nick(enum_class: [*c]GEnumClass, nick: [*c]const gchar) [*c]GEnumValue;
pub extern fn g_flags_get_first_value(flags_class: [*c]GFlagsClass, value: guint) [*c]GFlagsValue;
pub extern fn g_flags_get_value_by_name(flags_class: [*c]GFlagsClass, name: [*c]const gchar) [*c]GFlagsValue;
pub extern fn g_flags_get_value_by_nick(flags_class: [*c]GFlagsClass, nick: [*c]const gchar) [*c]GFlagsValue;
pub extern fn g_enum_to_string(g_enum_type: GType, value: gint) [*c]gchar;
pub extern fn g_flags_to_string(flags_type: GType, value: guint) [*c]gchar;
pub extern fn g_value_set_enum(value: [*c]GValue, v_enum: gint) void;
pub extern fn g_value_get_enum(value: [*c]const GValue) gint;
pub extern fn g_value_set_flags(value: [*c]GValue, v_flags: guint) void;
pub extern fn g_value_get_flags(value: [*c]const GValue) guint;
pub extern fn g_enum_register_static(name: [*c]const gchar, const_static_values: [*c]const GEnumValue) GType;
pub extern fn g_flags_register_static(name: [*c]const gchar, const_static_values: [*c]const GFlagsValue) GType;
pub extern fn g_enum_complete_type_info(g_enum_type: GType, info: [*c]GTypeInfo, const_values: [*c]const GEnumValue) void;
pub extern fn g_flags_complete_type_info(g_flags_type: GType, info: [*c]GTypeInfo, const_values: [*c]const GFlagsValue) void;
pub extern fn g_unicode_type_get_type() GType;
pub extern fn g_unicode_break_type_get_type() GType;
pub extern fn g_unicode_script_get_type() GType;
pub extern fn g_normalize_mode_get_type() GType;
pub const struct__GParamSpecChar = extern struct {
    parent_instance: GParamSpec,
    minimum: gint8,
    maximum: gint8,
    default_value: gint8,
};
pub const GParamSpecChar = struct__GParamSpecChar;
pub const struct__GParamSpecUChar = extern struct {
    parent_instance: GParamSpec,
    minimum: guint8,
    maximum: guint8,
    default_value: guint8,
};
pub const GParamSpecUChar = struct__GParamSpecUChar;
pub const struct__GParamSpecBoolean = extern struct {
    parent_instance: GParamSpec,
    default_value: gboolean,
};
pub const GParamSpecBoolean = struct__GParamSpecBoolean;
pub const struct__GParamSpecInt = extern struct {
    parent_instance: GParamSpec,
    minimum: gint,
    maximum: gint,
    default_value: gint,
};
pub const GParamSpecInt = struct__GParamSpecInt;
pub const struct__GParamSpecUInt = extern struct {
    parent_instance: GParamSpec,
    minimum: guint,
    maximum: guint,
    default_value: guint,
};
pub const GParamSpecUInt = struct__GParamSpecUInt;
pub const struct__GParamSpecLong = extern struct {
    parent_instance: GParamSpec,
    minimum: glong,
    maximum: glong,
    default_value: glong,
};
pub const GParamSpecLong = struct__GParamSpecLong;
pub const struct__GParamSpecULong = extern struct {
    parent_instance: GParamSpec,
    minimum: gulong,
    maximum: gulong,
    default_value: gulong,
};
pub const GParamSpecULong = struct__GParamSpecULong;
pub const struct__GParamSpecInt64 = extern struct {
    parent_instance: GParamSpec,
    minimum: gint64,
    maximum: gint64,
    default_value: gint64,
};
pub const GParamSpecInt64 = struct__GParamSpecInt64;
pub const struct__GParamSpecUInt64 = extern struct {
    parent_instance: GParamSpec,
    minimum: guint64,
    maximum: guint64,
    default_value: guint64,
};
pub const GParamSpecUInt64 = struct__GParamSpecUInt64;
pub const struct__GParamSpecUnichar = extern struct {
    parent_instance: GParamSpec,
    default_value: gunichar,
};
pub const GParamSpecUnichar = struct__GParamSpecUnichar;
pub const struct__GParamSpecEnum = extern struct {
    parent_instance: GParamSpec,
    enum_class: [*c]GEnumClass,
    default_value: gint,
};
pub const GParamSpecEnum = struct__GParamSpecEnum;
pub const struct__GParamSpecFlags = extern struct {
    parent_instance: GParamSpec,
    flags_class: [*c]GFlagsClass,
    default_value: guint,
};
pub const GParamSpecFlags = struct__GParamSpecFlags;
pub const struct__GParamSpecFloat = extern struct {
    parent_instance: GParamSpec,
    minimum: gfloat,
    maximum: gfloat,
    default_value: gfloat,
    epsilon: gfloat,
};
pub const GParamSpecFloat = struct__GParamSpecFloat;
pub const struct__GParamSpecDouble = extern struct {
    parent_instance: GParamSpec,
    minimum: gdouble,
    maximum: gdouble,
    default_value: gdouble,
    epsilon: gdouble,
};
pub const GParamSpecDouble = struct__GParamSpecDouble; // /usr/include/glib-2.0/gobject/gparamspecs.h:865:17: warning: struct demoted to opaque type - has bitfield
pub const struct__GParamSpecString = opaque {};
pub const GParamSpecString = struct__GParamSpecString;
pub const struct__GParamSpecParam = extern struct {
    parent_instance: GParamSpec,
};
pub const GParamSpecParam = struct__GParamSpecParam;
pub const struct__GParamSpecBoxed = extern struct {
    parent_instance: GParamSpec,
};
pub const GParamSpecBoxed = struct__GParamSpecBoxed;
pub const struct__GParamSpecPointer = extern struct {
    parent_instance: GParamSpec,
};
pub const GParamSpecPointer = struct__GParamSpecPointer;
pub const struct__GParamSpecValueArray = extern struct {
    parent_instance: GParamSpec,
    element_spec: [*c]GParamSpec,
    fixed_n_elements: guint,
};
pub const GParamSpecValueArray = struct__GParamSpecValueArray;
pub const struct__GParamSpecObject = extern struct {
    parent_instance: GParamSpec,
};
pub const GParamSpecObject = struct__GParamSpecObject;
pub const struct__GParamSpecOverride = extern struct {
    parent_instance: GParamSpec,
    overridden: [*c]GParamSpec,
};
pub const GParamSpecOverride = struct__GParamSpecOverride;
pub const struct__GParamSpecGType = extern struct {
    parent_instance: GParamSpec,
    is_a_type: GType,
};
pub const GParamSpecGType = struct__GParamSpecGType;
pub const struct__GParamSpecVariant = extern struct {
    parent_instance: GParamSpec,
    type: ?*GVariantType,
    default_value: ?*GVariant,
    padding: [4]gpointer,
};
pub const GParamSpecVariant = struct__GParamSpecVariant;
pub extern fn g_param_spec_char(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: gint8, maximum: gint8, default_value: gint8, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_uchar(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: guint8, maximum: guint8, default_value: guint8, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_boolean(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, default_value: gboolean, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_int(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: gint, maximum: gint, default_value: gint, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_uint(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: guint, maximum: guint, default_value: guint, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_long(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: glong, maximum: glong, default_value: glong, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_ulong(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: gulong, maximum: gulong, default_value: gulong, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_int64(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: gint64, maximum: gint64, default_value: gint64, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_uint64(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: guint64, maximum: guint64, default_value: guint64, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_unichar(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, default_value: gunichar, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_enum(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, enum_type: GType, default_value: gint, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_flags(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, flags_type: GType, default_value: guint, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_float(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: gfloat, maximum: gfloat, default_value: gfloat, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_double(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: gdouble, maximum: gdouble, default_value: gdouble, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_string(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, default_value: [*c]const gchar, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_param(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, param_type: GType, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_boxed(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, boxed_type: GType, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_pointer(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_value_array(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, element_spec: [*c]GParamSpec, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_object(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, object_type: GType, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_override(name: [*c]const gchar, overridden: [*c]GParamSpec) [*c]GParamSpec;
pub extern fn g_param_spec_gtype(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, is_a_type: GType, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_variant(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, @"type": ?*const GVariantType, default_value: ?*GVariant, flags: GParamFlags) [*c]GParamSpec;
pub extern var g_param_spec_types: [*c]GType;
pub const struct__GSignalGroup = opaque {};
pub const GSignalGroup = struct__GSignalGroup;
pub extern fn g_signal_group_get_type() GType;
pub extern fn g_signal_group_new(target_type: GType) ?*GSignalGroup;
pub extern fn g_signal_group_set_target(self: ?*GSignalGroup, target: gpointer) void;
pub extern fn g_signal_group_dup_target(self: ?*GSignalGroup) gpointer;
pub extern fn g_signal_group_block(self: ?*GSignalGroup) void;
pub extern fn g_signal_group_unblock(self: ?*GSignalGroup) void;
pub extern fn g_signal_group_connect_object(self: ?*GSignalGroup, detailed_signal: [*c]const gchar, c_handler: GCallback, object: gpointer, flags: GConnectFlags) void;
pub extern fn g_signal_group_connect_data(self: ?*GSignalGroup, detailed_signal: [*c]const gchar, c_handler: GCallback, data: gpointer, notify: GClosureNotify, flags: GConnectFlags) void;
pub extern fn g_signal_group_connect(self: ?*GSignalGroup, detailed_signal: [*c]const gchar, c_handler: GCallback, data: gpointer) void;
pub extern fn g_signal_group_connect_after(self: ?*GSignalGroup, detailed_signal: [*c]const gchar, c_handler: GCallback, data: gpointer) void;
pub extern fn g_signal_group_connect_swapped(self: ?*GSignalGroup, detailed_signal: [*c]const gchar, c_handler: GCallback, data: gpointer) void;
pub extern fn g_source_set_closure(source: [*c]GSource, closure: ?*GClosure) void;
pub extern fn g_source_set_dummy_callback(source: [*c]GSource) void;
pub const struct__GTypeModule = extern struct {
    parent_instance: GObject,
    use_count: guint,
    type_infos: [*c]GSList,
    interface_infos: [*c]GSList,
    name: [*c]gchar,
};
pub const GTypeModule = struct__GTypeModule;
pub const struct__GTypeModuleClass = extern struct {
    parent_class: GObjectClass,
    load: ?fn ([*c]GTypeModule) callconv(.C) gboolean,
    unload: ?fn ([*c]GTypeModule) callconv(.C) void,
    reserved1: ?fn () callconv(.C) void,
    reserved2: ?fn () callconv(.C) void,
    reserved3: ?fn () callconv(.C) void,
    reserved4: ?fn () callconv(.C) void,
};
pub const GTypeModuleClass = struct__GTypeModuleClass;
pub const GTypeModule_autoptr = [*c]GTypeModule;
pub const GTypeModule_listautoptr = [*c]GList;
pub const GTypeModule_slistautoptr = [*c]GSList;
pub const GTypeModule_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTypeModule(arg__ptr: [*c]GTypeModule) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GTypeModule(arg__ptr: [*c][*c]GTypeModule) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GTypeModule(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GTypeModule(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GTypeModule(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GTypeModule(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_object_unref)))));
    }
}
pub extern fn g_type_module_get_type() GType;
pub extern fn g_type_module_use(module: [*c]GTypeModule) gboolean;
pub extern fn g_type_module_unuse(module: [*c]GTypeModule) void;
pub extern fn g_type_module_set_name(module: [*c]GTypeModule, name: [*c]const gchar) void;
pub extern fn g_type_module_register_type(module: [*c]GTypeModule, parent_type: GType, type_name: [*c]const gchar, type_info: [*c]const GTypeInfo, flags: GTypeFlags) GType;
pub extern fn g_type_module_add_interface(module: [*c]GTypeModule, instance_type: GType, interface_type: GType, interface_info: [*c]const GInterfaceInfo) void;
pub extern fn g_type_module_register_enum(module: [*c]GTypeModule, name: [*c]const gchar, const_static_values: [*c]const GEnumValue) GType;
pub extern fn g_type_module_register_flags(module: [*c]GTypeModule, name: [*c]const gchar, const_static_values: [*c]const GFlagsValue) GType;
pub const GTypePluginUse = ?fn (?*GTypePlugin) callconv(.C) void;
pub const GTypePluginUnuse = ?fn (?*GTypePlugin) callconv(.C) void;
pub const GTypePluginCompleteTypeInfo = ?fn (?*GTypePlugin, GType, [*c]GTypeInfo, [*c]GTypeValueTable) callconv(.C) void;
pub const GTypePluginCompleteInterfaceInfo = ?fn (?*GTypePlugin, GType, GType, [*c]GInterfaceInfo) callconv(.C) void;
pub const struct__GTypePluginClass = extern struct {
    base_iface: GTypeInterface,
    use_plugin: GTypePluginUse,
    unuse_plugin: GTypePluginUnuse,
    complete_type_info: GTypePluginCompleteTypeInfo,
    complete_interface_info: GTypePluginCompleteInterfaceInfo,
};
pub const GTypePluginClass = struct__GTypePluginClass;
pub extern fn g_type_plugin_get_type() GType;
pub extern fn g_type_plugin_use(plugin: ?*GTypePlugin) void;
pub extern fn g_type_plugin_unuse(plugin: ?*GTypePlugin) void;
pub extern fn g_type_plugin_complete_type_info(plugin: ?*GTypePlugin, g_type: GType, info: [*c]GTypeInfo, value_table: [*c]GTypeValueTable) void;
pub extern fn g_type_plugin_complete_interface_info(plugin: ?*GTypePlugin, instance_type: GType, interface_type: GType, info: [*c]GInterfaceInfo) void;
pub const struct__GValueArray = extern struct {
    n_values: guint,
    values: [*c]GValue,
    n_prealloced: guint,
};
pub const GValueArray = struct__GValueArray;
pub extern fn g_value_array_get_type() GType;
pub extern fn g_value_array_get_nth(value_array: [*c]GValueArray, index_: guint) [*c]GValue;
pub extern fn g_value_array_new(n_prealloced: guint) [*c]GValueArray;
pub extern fn g_value_array_free(value_array: [*c]GValueArray) void;
pub extern fn g_value_array_copy(value_array: [*c]const GValueArray) [*c]GValueArray;
pub extern fn g_value_array_prepend(value_array: [*c]GValueArray, value: [*c]const GValue) [*c]GValueArray;
pub extern fn g_value_array_append(value_array: [*c]GValueArray, value: [*c]const GValue) [*c]GValueArray;
pub extern fn g_value_array_insert(value_array: [*c]GValueArray, index_: guint, value: [*c]const GValue) [*c]GValueArray;
pub extern fn g_value_array_remove(value_array: [*c]GValueArray, index_: guint) [*c]GValueArray;
pub extern fn g_value_array_sort(value_array: [*c]GValueArray, compare_func: GCompareFunc) [*c]GValueArray;
pub extern fn g_value_array_sort_with_data(value_array: [*c]GValueArray, compare_func: GCompareDataFunc, user_data: gpointer) [*c]GValueArray;
pub extern fn g_value_set_char(value: [*c]GValue, v_char: gchar) void;
pub extern fn g_value_get_char(value: [*c]const GValue) gchar;
pub extern fn g_value_set_schar(value: [*c]GValue, v_char: gint8) void;
pub extern fn g_value_get_schar(value: [*c]const GValue) gint8;
pub extern fn g_value_set_uchar(value: [*c]GValue, v_uchar: guchar) void;
pub extern fn g_value_get_uchar(value: [*c]const GValue) guchar;
pub extern fn g_value_set_boolean(value: [*c]GValue, v_boolean: gboolean) void;
pub extern fn g_value_get_boolean(value: [*c]const GValue) gboolean;
pub extern fn g_value_set_int(value: [*c]GValue, v_int: gint) void;
pub extern fn g_value_get_int(value: [*c]const GValue) gint;
pub extern fn g_value_set_uint(value: [*c]GValue, v_uint: guint) void;
pub extern fn g_value_get_uint(value: [*c]const GValue) guint;
pub extern fn g_value_set_long(value: [*c]GValue, v_long: glong) void;
pub extern fn g_value_get_long(value: [*c]const GValue) glong;
pub extern fn g_value_set_ulong(value: [*c]GValue, v_ulong: gulong) void;
pub extern fn g_value_get_ulong(value: [*c]const GValue) gulong;
pub extern fn g_value_set_int64(value: [*c]GValue, v_int64: gint64) void;
pub extern fn g_value_get_int64(value: [*c]const GValue) gint64;
pub extern fn g_value_set_uint64(value: [*c]GValue, v_uint64: guint64) void;
pub extern fn g_value_get_uint64(value: [*c]const GValue) guint64;
pub extern fn g_value_set_float(value: [*c]GValue, v_float: gfloat) void;
pub extern fn g_value_get_float(value: [*c]const GValue) gfloat;
pub extern fn g_value_set_double(value: [*c]GValue, v_double: gdouble) void;
pub extern fn g_value_get_double(value: [*c]const GValue) gdouble;
pub extern fn g_value_set_string(value: [*c]GValue, v_string: [*c]const gchar) void;
pub extern fn g_value_set_static_string(value: [*c]GValue, v_string: [*c]const gchar) void;
pub extern fn g_value_set_interned_string(value: [*c]GValue, v_string: [*c]const gchar) void;
pub extern fn g_value_get_string(value: [*c]const GValue) [*c]const gchar;
pub extern fn g_value_dup_string(value: [*c]const GValue) [*c]gchar;
pub extern fn g_value_set_pointer(value: [*c]GValue, v_pointer: gpointer) void;
pub extern fn g_value_get_pointer(value: [*c]const GValue) gpointer;
pub extern fn g_gtype_get_type() GType;
pub extern fn g_value_set_gtype(value: [*c]GValue, v_gtype: GType) void;
pub extern fn g_value_get_gtype(value: [*c]const GValue) GType;
pub extern fn g_value_set_variant(value: [*c]GValue, variant: ?*GVariant) void;
pub extern fn g_value_take_variant(value: [*c]GValue, variant: ?*GVariant) void;
pub extern fn g_value_get_variant(value: [*c]const GValue) ?*GVariant;
pub extern fn g_value_dup_variant(value: [*c]const GValue) ?*GVariant;
pub extern fn g_pointer_type_register_static(name: [*c]const gchar) GType;
pub extern fn g_strdup_value_contents(value: [*c]const GValue) [*c]gchar;
pub extern fn g_value_take_string(value: [*c]GValue, v_string: [*c]gchar) void;
pub extern fn g_value_set_string_take_ownership(value: [*c]GValue, v_string: [*c]gchar) void;
pub const gchararray = [*c]gchar;
pub const GClosure_autoptr = ?*GClosure;
pub const GClosure_listautoptr = [*c]GList;
pub const GClosure_slistautoptr = [*c]GSList;
pub const GClosure_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GClosure(arg__ptr: ?*GClosure) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_closure_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GClosure(arg__ptr: [*c]?*GClosure) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GClosure(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GClosure(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_closure_unref)))));
}
pub fn glib_slistautoptr_cleanup_GClosure(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_closure_unref)))));
}
pub fn glib_queueautoptr_cleanup_GClosure(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_closure_unref)))));
    }
}
pub const GEnumClass_autoptr = [*c]GEnumClass;
pub const GEnumClass_listautoptr = [*c]GList;
pub const GEnumClass_slistautoptr = [*c]GSList;
pub const GEnumClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GEnumClass(arg__ptr: [*c]GEnumClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GEnumClass(arg__ptr: [*c][*c]GEnumClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GEnumClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GEnumClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_type_class_unref)))));
}
pub fn glib_slistautoptr_cleanup_GEnumClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_type_class_unref)))));
}
pub fn glib_queueautoptr_cleanup_GEnumClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_type_class_unref)))));
    }
}
pub const GFlagsClass_autoptr = [*c]GFlagsClass;
pub const GFlagsClass_listautoptr = [*c]GList;
pub const GFlagsClass_slistautoptr = [*c]GSList;
pub const GFlagsClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFlagsClass(arg__ptr: [*c]GFlagsClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GFlagsClass(arg__ptr: [*c][*c]GFlagsClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GFlagsClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GFlagsClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_type_class_unref)))));
}
pub fn glib_slistautoptr_cleanup_GFlagsClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_type_class_unref)))));
}
pub fn glib_queueautoptr_cleanup_GFlagsClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_type_class_unref)))));
    }
}
pub const GObject_autoptr = [*c]GObject;
pub const GObject_listautoptr = [*c]GList;
pub const GObject_slistautoptr = [*c]GSList;
pub const GObject_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GObject(arg__ptr: [*c]GObject) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GObject(arg__ptr: [*c][*c]GObject) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GObject(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GObject(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GObject(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GObject(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_object_unref)))));
    }
}
pub const GInitiallyUnowned_autoptr = [*c]GInitiallyUnowned;
pub const GInitiallyUnowned_listautoptr = [*c]GList;
pub const GInitiallyUnowned_slistautoptr = [*c]GSList;
pub const GInitiallyUnowned_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GInitiallyUnowned(arg__ptr: [*c]GInitiallyUnowned) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GInitiallyUnowned(arg__ptr: [*c][*c]GInitiallyUnowned) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GInitiallyUnowned(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GInitiallyUnowned(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GInitiallyUnowned(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GInitiallyUnowned(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_object_unref)))));
    }
}
pub const GParamSpec_autoptr = [*c]GParamSpec;
pub const GParamSpec_listautoptr = [*c]GList;
pub const GParamSpec_slistautoptr = [*c]GSList;
pub const GParamSpec_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GParamSpec(arg__ptr: [*c]GParamSpec) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_param_spec_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GParamSpec(arg__ptr: [*c][*c]GParamSpec) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GParamSpec(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GParamSpec(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_param_spec_unref)))));
}
pub fn glib_slistautoptr_cleanup_GParamSpec(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_param_spec_unref)))));
}
pub fn glib_queueautoptr_cleanup_GParamSpec(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_param_spec_unref)))));
    }
}
pub const GTypeClass_autoptr = [*c]GTypeClass;
pub const GTypeClass_listautoptr = [*c]GList;
pub const GTypeClass_slistautoptr = [*c]GSList;
pub const GTypeClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTypeClass(arg__ptr: [*c]GTypeClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GTypeClass(arg__ptr: [*c][*c]GTypeClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GTypeClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GTypeClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_type_class_unref)))));
}
pub fn glib_slistautoptr_cleanup_GTypeClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_type_class_unref)))));
}
pub fn glib_queueautoptr_cleanup_GTypeClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), g_type_class_unref)))));
    }
}
pub fn glib_auto_cleanup_GValue(arg__ptr: [*c]GValue) callconv(.C) void {
    var _ptr = arg__ptr;
    g_value_unset(_ptr);
}
pub extern fn gst_allocator_flags_get_type() GType;
pub extern fn gst_bin_flags_get_type() GType;
pub extern fn gst_buffer_flags_get_type() GType;
pub extern fn gst_buffer_copy_flags_get_type() GType;
pub extern fn gst_buffer_pool_acquire_flags_get_type() GType;
pub extern fn gst_bus_flags_get_type() GType;
pub extern fn gst_bus_sync_reply_get_type() GType;
pub extern fn gst_caps_flags_get_type() GType;
pub extern fn gst_caps_intersect_mode_get_type() GType;
pub extern fn gst_clock_return_get_type() GType;
pub extern fn gst_clock_entry_type_get_type() GType;
pub extern fn gst_clock_flags_get_type() GType;
pub extern fn gst_debug_graph_details_get_type() GType;
pub extern fn gst_state_get_type() GType;
pub extern fn gst_state_change_return_get_type() GType;
pub extern fn gst_state_change_get_type() GType;
pub extern fn gst_element_flags_get_type() GType;
pub extern fn gst_core_error_get_type() GType;
pub extern fn gst_library_error_get_type() GType;
pub extern fn gst_resource_error_get_type() GType;
pub extern fn gst_stream_error_get_type() GType;
pub extern fn gst_event_type_flags_get_type() GType;
pub extern fn gst_event_type_get_type() GType;
pub extern fn gst_stream_flags_get_type() GType;
pub extern fn gst_qos_type_get_type() GType;
pub extern fn gst_gap_flags_get_type() GType;
pub extern fn gst_format_get_type() GType;
pub extern fn gst_debug_level_get_type() GType;
pub extern fn gst_debug_color_flags_get_type() GType;
pub extern fn gst_stack_trace_flags_get_type() GType;
pub extern fn gst_debug_color_mode_get_type() GType;
pub extern fn gst_iterator_result_get_type() GType;
pub extern fn gst_iterator_item_get_type() GType;
pub extern fn gst_memory_flags_get_type() GType;
pub extern fn gst_map_flags_get_type() GType;
pub extern fn gst_message_type_get_type() GType;
pub extern fn gst_structure_change_type_get_type() GType;
pub extern fn gst_stream_status_type_get_type() GType;
pub extern fn gst_progress_type_get_type() GType;
pub extern fn gst_meta_flags_get_type() GType;
pub extern fn gst_mini_object_flags_get_type() GType;
pub extern fn gst_lock_flags_get_type() GType;
pub extern fn gst_object_flags_get_type() GType;
pub extern fn gst_pad_direction_get_type() GType;
pub extern fn gst_pad_mode_get_type() GType;
pub extern fn gst_pad_link_return_get_type() GType;
pub extern fn gst_flow_return_get_type() GType;
pub extern fn gst_pad_link_check_get_type() GType;
pub extern fn gst_pad_probe_type_get_type() GType;
pub extern fn gst_pad_probe_return_get_type() GType;
pub extern fn gst_pad_flags_get_type() GType;
pub extern fn gst_pad_presence_get_type() GType;
pub extern fn gst_pad_template_flags_get_type() GType;
pub extern fn gst_parse_error_get_type() GType;
pub extern fn gst_parse_flags_get_type() GType;
pub extern fn gst_pipeline_flags_get_type() GType;
pub extern fn gst_plugin_error_get_type() GType;
pub extern fn gst_plugin_flags_get_type() GType;
pub extern fn gst_plugin_dependency_flags_get_type() GType;
pub extern fn gst_rank_get_type() GType;
pub extern fn gst_promise_result_get_type() GType;
pub extern fn gst_query_type_flags_get_type() GType;
pub extern fn gst_query_type_get_type() GType;
pub extern fn gst_buffering_mode_get_type() GType;
pub extern fn gst_scheduling_flags_get_type() GType;
pub extern fn gst_seek_type_get_type() GType;
pub extern fn gst_seek_flags_get_type() GType;
pub extern fn gst_segment_flags_get_type() GType;
pub extern fn gst_stream_type_get_type() GType;
pub extern fn gst_serialize_flags_get_type() GType;
pub extern fn gst_clock_type_get_type() GType;
pub extern fn gst_tag_merge_mode_get_type() GType;
pub extern fn gst_tag_flag_get_type() GType;
pub extern fn gst_tag_scope_get_type() GType;
pub extern fn gst_task_state_get_type() GType;
pub extern fn gst_toc_scope_get_type() GType;
pub extern fn gst_toc_entry_type_get_type() GType;
pub extern fn gst_toc_loop_type_get_type() GType;
pub extern fn gst_tracer_value_scope_get_type() GType;
pub extern fn gst_tracer_value_flags_get_type() GType;
pub extern fn gst_type_find_probability_get_type() GType;
pub extern fn gst_uri_error_get_type() GType;
pub extern fn gst_uri_type_get_type() GType;
pub extern fn gst_search_mode_get_type() GType;
pub extern fn gst_plugin_api_flags_get_type() GType;
pub const struct__GstAtomicQueue = opaque {};
pub const GstAtomicQueue = struct__GstAtomicQueue;
pub extern fn gst_atomic_queue_get_type() GType;
pub extern fn gst_atomic_queue_new(initial_size: guint) ?*GstAtomicQueue;
pub extern fn gst_atomic_queue_ref(queue: ?*GstAtomicQueue) void;
pub extern fn gst_atomic_queue_unref(queue: ?*GstAtomicQueue) void;
pub extern fn gst_atomic_queue_push(queue: ?*GstAtomicQueue, data: gpointer) void;
pub extern fn gst_atomic_queue_pop(queue: ?*GstAtomicQueue) gpointer;
pub extern fn gst_atomic_queue_peek(queue: ?*GstAtomicQueue) gpointer;
pub extern fn gst_atomic_queue_length(queue: ?*GstAtomicQueue) guint;
pub const GstAtomicQueue_autoptr = ?*GstAtomicQueue;
pub const GstAtomicQueue_listautoptr = [*c]GList;
pub const GstAtomicQueue_slistautoptr = [*c]GSList;
pub const GstAtomicQueue_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstAtomicQueue(arg__ptr: ?*GstAtomicQueue) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_atomic_queue_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GstAtomicQueue(arg__ptr: [*c]?*GstAtomicQueue) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstAtomicQueue(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstAtomicQueue(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_atomic_queue_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstAtomicQueue(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_atomic_queue_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstAtomicQueue(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_atomic_queue_unref)))));
    }
}
pub const struct__GstObject = extern struct {
    object: GInitiallyUnowned,
    lock: GMutex,
    name: [*c]gchar,
    parent: [*c]GstObject,
    flags: guint32,
    control_bindings: [*c]GList,
    control_rate: guint64,
    last_sync: guint64,
    _gst_reserved: gpointer,
};
pub const GstObject = struct__GstObject;
pub const struct__GstBusPrivate = opaque {};
pub const GstBusPrivate = struct__GstBusPrivate;
pub const struct__GstBus = extern struct {
    object: GstObject,
    priv: ?*GstBusPrivate,
    _gst_reserved: [4]gpointer,
};
pub const GstBus = struct__GstBus;
pub const struct__GstClockPrivate = opaque {};
pub const GstClockPrivate = struct__GstClockPrivate;
pub const struct__GstClock = extern struct {
    object: GstObject,
    priv: ?*GstClockPrivate,
    _gst_reserved: [4]gpointer,
};
pub const GstClock = struct__GstClock;
pub const GstClockTimeDiff = gint64;
pub const GstClockTime = guint64;
pub const struct__GstElement = extern struct {
    object: GstObject,
    state_lock: GRecMutex,
    state_cond: GCond,
    state_cookie: guint32,
    target_state: GstState,
    current_state: GstState,
    next_state: GstState,
    pending_state: GstState,
    last_return: GstStateChangeReturn,
    bus: [*c]GstBus,
    clock: [*c]GstClock,
    base_time: GstClockTimeDiff,
    start_time: GstClockTime,
    numpads: guint16,
    pads: [*c]GList,
    numsrcpads: guint16,
    srcpads: [*c]GList,
    numsinkpads: guint16,
    sinkpads: [*c]GList,
    pads_cookie: guint32,
    contexts: [*c]GList,
    _gst_reserved: [3]gpointer,
};
pub const GstElement = struct__GstElement;
pub const struct__GstObjectClass = extern struct {
    parent_class: GInitiallyUnownedClass,
    path_string_separator: [*c]const gchar,
    deep_notify: ?fn ([*c]GstObject, [*c]GstObject, [*c]GParamSpec) callconv(.C) void,
    _gst_reserved: [4]gpointer,
};
pub const GstObjectClass = struct__GstObjectClass;
pub const struct__GstElementFactory = opaque {};
pub const GstElementFactory = struct__GstElementFactory;
pub const GstMiniObjectCopyFunction = ?fn ([*c]const GstMiniObject) callconv(.C) [*c]GstMiniObject;
pub const GstMiniObjectDisposeFunction = ?fn ([*c]GstMiniObject) callconv(.C) gboolean;
pub const GstMiniObjectFreeFunction = ?fn ([*c]GstMiniObject) callconv(.C) void;
pub const struct__GstMiniObject = extern struct {
    type: GType,
    refcount: gint,
    lockstate: gint,
    flags: guint,
    copy: GstMiniObjectCopyFunction,
    dispose: GstMiniObjectDisposeFunction,
    free: GstMiniObjectFreeFunction,
    priv_uint: guint,
    priv_pointer: gpointer,
};
pub const GstMiniObject = struct__GstMiniObject;
pub const struct__GstCaps = extern struct {
    mini_object: GstMiniObject,
};
pub const GstCaps = struct__GstCaps;
const struct_unnamed_48 = extern struct {
    gtype: GType,
    documentation_caps: [*c]GstCaps,
};
const union_unnamed_47 = extern union {
    _gst_reserved: [4]gpointer,
    abi: struct_unnamed_48,
};
pub const struct__GstPadTemplate = extern struct {
    object: GstObject,
    name_template: [*c]gchar,
    direction: GstPadDirection,
    presence: GstPadPresence,
    caps: [*c]GstCaps,
    ABI: union_unnamed_47,
};
pub const GstPadTemplate = struct__GstPadTemplate;
pub const GstTaskFunction = ?fn (gpointer) callconv(.C) void;
pub const struct__GstTaskPrivate = opaque {};
pub const GstTaskPrivate = struct__GstTaskPrivate;
pub const struct__GstTask = extern struct {
    object: GstObject,
    state: GstTaskState,
    cond: GCond,
    lock: [*c]GRecMutex,
    func: GstTaskFunction,
    user_data: gpointer,
    notify: GDestroyNotify,
    running: gboolean,
    thread: [*c]GThread,
    priv: ?*GstTaskPrivate,
    _gst_reserved: [4]gpointer,
};
pub const GstTask = struct__GstTask;
pub const GstPadActivateFunction = ?fn (?*GstPad, [*c]GstObject) callconv(.C) gboolean;
pub const GstPadActivateModeFunction = ?fn (?*GstPad, [*c]GstObject, GstPadMode, gboolean) callconv(.C) gboolean;
pub const GstPadLinkFunction = ?fn (?*GstPad, [*c]GstObject, ?*GstPad) callconv(.C) GstPadLinkReturn;
pub const GstPadUnlinkFunction = ?fn (?*GstPad, [*c]GstObject) callconv(.C) void;
pub const struct__GstBufferPoolPrivate = opaque {};
pub const GstBufferPoolPrivate = struct__GstBufferPoolPrivate;
pub const struct__GstBufferPool = extern struct {
    object: GstObject,
    flushing: gint,
    priv: ?*GstBufferPoolPrivate,
    _gst_reserved: [4]gpointer,
};
pub const GstBufferPool = struct__GstBufferPool;
pub const struct__GstBuffer = extern struct {
    mini_object: GstMiniObject,
    pool: [*c]GstBufferPool,
    pts: GstClockTime,
    dts: GstClockTime,
    duration: GstClockTime,
    offset: guint64,
    offset_end: guint64,
};
pub const GstBuffer = struct__GstBuffer;
pub const GstPadChainFunction = ?fn (?*GstPad, [*c]GstObject, [*c]GstBuffer) callconv(.C) GstFlowReturn;
pub const struct__GstBufferList = opaque {};
pub const GstBufferList = struct__GstBufferList;
pub const GstPadChainListFunction = ?fn (?*GstPad, [*c]GstObject, ?*GstBufferList) callconv(.C) GstFlowReturn;
pub const GstPadGetRangeFunction = ?fn (?*GstPad, [*c]GstObject, guint64, guint, [*c][*c]GstBuffer) callconv(.C) GstFlowReturn;
pub const struct__GstEvent = extern struct {
    mini_object: GstMiniObject,
    type: GstEventType,
    timestamp: guint64,
    seqnum: guint32,
};
pub const GstEvent = struct__GstEvent;
pub const GstPadEventFunction = ?fn (?*GstPad, [*c]GstObject, [*c]GstEvent) callconv(.C) gboolean;
pub const struct__GstQuery = extern struct {
    mini_object: GstMiniObject,
    type: GstQueryType,
};
pub const GstQuery = struct__GstQuery;
pub const GstPadQueryFunction = ?fn (?*GstPad, [*c]GstObject, [*c]GstQuery) callconv(.C) gboolean;
pub const GstIteratorCopyFunction = ?fn ([*c]const GstIterator, [*c]GstIterator) callconv(.C) void;
pub const GstIteratorNextFunction = ?fn ([*c]GstIterator, [*c]GValue) callconv(.C) GstIteratorResult;
pub const GstIteratorItemFunction = ?fn ([*c]GstIterator, [*c]const GValue) callconv(.C) GstIteratorItem;
pub const GstIteratorResyncFunction = ?fn ([*c]GstIterator) callconv(.C) void;
pub const GstIteratorFreeFunction = ?fn ([*c]GstIterator) callconv(.C) void;
pub const struct__GstIterator = extern struct {
    copy: GstIteratorCopyFunction,
    next: GstIteratorNextFunction,
    item: GstIteratorItemFunction,
    resync: GstIteratorResyncFunction,
    free: GstIteratorFreeFunction,
    pushed: [*c]GstIterator,
    type: GType,
    lock: [*c]GMutex,
    cookie: guint32,
    master_cookie: [*c]guint32,
    size: guint,
    _gst_reserved: [4]gpointer,
};
pub const GstIterator = struct__GstIterator;
pub const GstPadIterIntLinkFunction = ?fn (?*GstPad, [*c]GstObject) callconv(.C) [*c]GstIterator;
pub const struct__GstPadPrivate = opaque {};
pub const GstPadPrivate = struct__GstPadPrivate;
pub const GstPadEventFullFunction = ?fn (?*GstPad, [*c]GstObject, [*c]GstEvent) callconv(.C) GstFlowReturn;
const struct_unnamed_50 = extern struct {
    last_flowret: GstFlowReturn,
    eventfullfunc: GstPadEventFullFunction,
};
const union_unnamed_49 = extern union {
    _gst_reserved: [4]gpointer,
    abi: struct_unnamed_50,
};
pub const struct__GstPad = extern struct {
    object: GstObject,
    element_private: gpointer,
    padtemplate: [*c]GstPadTemplate,
    direction: GstPadDirection,
    stream_rec_lock: GRecMutex,
    task: [*c]GstTask,
    block_cond: GCond,
    probes: GHookList,
    mode: GstPadMode,
    activatefunc: GstPadActivateFunction,
    activatedata: gpointer,
    activatenotify: GDestroyNotify,
    activatemodefunc: GstPadActivateModeFunction,
    activatemodedata: gpointer,
    activatemodenotify: GDestroyNotify,
    peer: ?*GstPad,
    linkfunc: GstPadLinkFunction,
    linkdata: gpointer,
    linknotify: GDestroyNotify,
    unlinkfunc: GstPadUnlinkFunction,
    unlinkdata: gpointer,
    unlinknotify: GDestroyNotify,
    chainfunc: GstPadChainFunction,
    chaindata: gpointer,
    chainnotify: GDestroyNotify,
    chainlistfunc: GstPadChainListFunction,
    chainlistdata: gpointer,
    chainlistnotify: GDestroyNotify,
    getrangefunc: GstPadGetRangeFunction,
    getrangedata: gpointer,
    getrangenotify: GDestroyNotify,
    eventfunc: GstPadEventFunction,
    eventdata: gpointer,
    eventnotify: GDestroyNotify,
    offset: gint64,
    queryfunc: GstPadQueryFunction,
    querydata: gpointer,
    querynotify: GDestroyNotify,
    iterintlinkfunc: GstPadIterIntLinkFunction,
    iterintlinkdata: gpointer,
    iterintlinknotify: GDestroyNotify,
    num_probes: gint,
    num_blocked: gint,
    priv: ?*GstPadPrivate,
    ABI: union_unnamed_49,
};
pub const GstPad = struct__GstPad;
pub const struct__GstMessage = extern struct {
    mini_object: GstMiniObject,
    type: GstMessageType,
    timestamp: guint64,
    src: [*c]GstObject,
    seqnum: guint32,
    lock: GMutex,
    cond: GCond,
};
pub const GstMessage = struct__GstMessage;
pub const struct__GstContext = opaque {};
pub const GstContext = struct__GstContext;
pub const struct__GstElementClass = extern struct {
    parent_class: GstObjectClass,
    metadata: gpointer,
    elementfactory: ?*GstElementFactory,
    padtemplates: [*c]GList,
    numpadtemplates: gint,
    pad_templ_cookie: guint32,
    pad_added: ?fn ([*c]GstElement, ?*GstPad) callconv(.C) void,
    pad_removed: ?fn ([*c]GstElement, ?*GstPad) callconv(.C) void,
    no_more_pads: ?fn ([*c]GstElement) callconv(.C) void,
    request_new_pad: ?fn ([*c]GstElement, [*c]GstPadTemplate, [*c]const gchar, [*c]const GstCaps) callconv(.C) ?*GstPad,
    release_pad: ?fn ([*c]GstElement, ?*GstPad) callconv(.C) void,
    get_state: ?fn ([*c]GstElement, [*c]GstState, [*c]GstState, GstClockTime) callconv(.C) GstStateChangeReturn,
    set_state: ?fn ([*c]GstElement, GstState) callconv(.C) GstStateChangeReturn,
    change_state: ?fn ([*c]GstElement, GstStateChange) callconv(.C) GstStateChangeReturn,
    state_changed: ?fn ([*c]GstElement, GstState, GstState, GstState) callconv(.C) void,
    set_bus: ?fn ([*c]GstElement, [*c]GstBus) callconv(.C) void,
    provide_clock: ?fn ([*c]GstElement) callconv(.C) [*c]GstClock,
    set_clock: ?fn ([*c]GstElement, [*c]GstClock) callconv(.C) gboolean,
    send_event: ?fn ([*c]GstElement, [*c]GstEvent) callconv(.C) gboolean,
    query: ?fn ([*c]GstElement, [*c]GstQuery) callconv(.C) gboolean,
    post_message: ?fn ([*c]GstElement, [*c]GstMessage) callconv(.C) gboolean,
    set_context: ?fn ([*c]GstElement, ?*GstContext) callconv(.C) void,
    _gst_reserved: [18]gpointer,
};
pub const GstElementClass = struct__GstElementClass;
pub const GST_STATE_VOID_PENDING: c_int = 0;
pub const GST_STATE_NULL: c_int = 1;
pub const GST_STATE_READY: c_int = 2;
pub const GST_STATE_PAUSED: c_int = 3;
pub const GST_STATE_PLAYING: c_int = 4;
pub const GstState = c_uint;
pub const GST_STATE_CHANGE_FAILURE: c_int = 0;
pub const GST_STATE_CHANGE_SUCCESS: c_int = 1;
pub const GST_STATE_CHANGE_ASYNC: c_int = 2;
pub const GST_STATE_CHANGE_NO_PREROLL: c_int = 3;
pub const GstStateChangeReturn = c_uint;
pub const GST_OBJECT_FLAG_MAY_BE_LEAKED: c_int = 1;
pub const GST_OBJECT_FLAG_LAST: c_int = 16;
pub const GstObjectFlags = c_uint;
pub extern fn gst_object_get_type() GType;
pub extern fn gst_object_set_name(object: [*c]GstObject, name: [*c]const gchar) gboolean;
pub extern fn gst_object_get_name(object: [*c]GstObject) [*c]gchar;
pub extern fn gst_object_set_parent(object: [*c]GstObject, parent: [*c]GstObject) gboolean;
pub extern fn gst_object_get_parent(object: [*c]GstObject) [*c]GstObject;
pub extern fn gst_object_unparent(object: [*c]GstObject) void;
pub extern fn gst_object_has_as_parent(object: [*c]GstObject, parent: [*c]GstObject) gboolean;
pub extern fn gst_object_has_as_ancestor(object: [*c]GstObject, ancestor: [*c]GstObject) gboolean;
pub extern fn gst_object_has_ancestor(object: [*c]GstObject, ancestor: [*c]GstObject) gboolean;
pub extern fn gst_object_default_deep_notify(object: [*c]GObject, orig: [*c]GstObject, pspec: [*c]GParamSpec, excluded_props: [*c][*c]gchar) void;
pub extern fn gst_object_ref(object: gpointer) gpointer;
pub extern fn gst_object_unref(object: gpointer) void;
pub extern fn gst_clear_object(object_ptr: [*c][*c]GstObject) void;
pub extern fn gst_object_ref_sink(object: gpointer) gpointer;
pub extern fn gst_object_replace(oldobj: [*c][*c]GstObject, newobj: [*c]GstObject) gboolean;
pub extern fn gst_object_get_path_string(object: [*c]GstObject) [*c]gchar;
pub extern fn gst_object_check_uniqueness(list: [*c]GList, name: [*c]const gchar) gboolean;
pub const struct__GstControlBindingPrivate = opaque {};
pub const GstControlBindingPrivate = struct__GstControlBindingPrivate;
const struct_unnamed_52 = extern struct {
    priv: ?*GstControlBindingPrivate,
};
const union_unnamed_51 = extern union {
    abi: struct_unnamed_52,
    _gst_reserved: [4]gpointer,
};
pub const struct__GstControlBinding = extern struct {
    parent: GstObject,
    name: [*c]gchar,
    pspec: [*c]GParamSpec,
    object: [*c]GstObject,
    disabled: gboolean,
    ABI: union_unnamed_51,
};
pub const GstControlBinding = struct__GstControlBinding;
pub const struct__GstControlBindingClass = extern struct {
    parent_class: GstObjectClass,
    sync_values: ?fn ([*c]GstControlBinding, [*c]GstObject, GstClockTime, GstClockTime) callconv(.C) gboolean,
    get_value: ?fn ([*c]GstControlBinding, GstClockTime) callconv(.C) [*c]GValue,
    get_value_array: ?fn ([*c]GstControlBinding, GstClockTime, GstClockTime, guint, gpointer) callconv(.C) gboolean,
    get_g_value_array: ?fn ([*c]GstControlBinding, GstClockTime, GstClockTime, guint, [*c]GValue) callconv(.C) gboolean,
    _gst_reserved: [4]gpointer,
};
pub const GstControlBindingClass = struct__GstControlBindingClass;
pub const GstClockID = gpointer;
pub const GstClockCallback = ?fn ([*c]GstClock, GstClockTime, GstClockID, gpointer) callconv(.C) gboolean;
pub const struct__GstClockEntry = extern struct {
    refcount: gint,
    clock: [*c]GstClock,
    type: GstClockEntryType,
    time: GstClockTime,
    interval: GstClockTime,
    status: GstClockReturn,
    func: GstClockCallback,
    user_data: gpointer,
    destroy_data: GDestroyNotify,
    unscheduled: gboolean,
    woken_up: gboolean,
    _gst_reserved: [4]gpointer,
};
pub const GstClockEntry = struct__GstClockEntry;
pub const struct__GstClockClass = extern struct {
    parent_class: GstObjectClass,
    change_resolution: ?fn ([*c]GstClock, GstClockTime, GstClockTime) callconv(.C) GstClockTime,
    get_resolution: ?fn ([*c]GstClock) callconv(.C) GstClockTime,
    get_internal_time: ?fn ([*c]GstClock) callconv(.C) GstClockTime,
    wait: ?fn ([*c]GstClock, [*c]GstClockEntry, [*c]GstClockTimeDiff) callconv(.C) GstClockReturn,
    wait_async: ?fn ([*c]GstClock, [*c]GstClockEntry) callconv(.C) GstClockReturn,
    unschedule: ?fn ([*c]GstClock, [*c]GstClockEntry) callconv(.C) void,
    _gst_reserved: [4]gpointer,
};
pub const GstClockClass = struct__GstClockClass;
pub const GST_CLOCK_OK: c_int = 0;
pub const GST_CLOCK_EARLY: c_int = 1;
pub const GST_CLOCK_UNSCHEDULED: c_int = 2;
pub const GST_CLOCK_BUSY: c_int = 3;
pub const GST_CLOCK_BADTIME: c_int = 4;
pub const GST_CLOCK_ERROR: c_int = 5;
pub const GST_CLOCK_UNSUPPORTED: c_int = 6;
pub const GST_CLOCK_DONE: c_int = 7;
pub const GstClockReturn = c_uint;
pub const GST_CLOCK_ENTRY_SINGLE: c_int = 0;
pub const GST_CLOCK_ENTRY_PERIODIC: c_int = 1;
pub const GstClockEntryType = c_uint;
pub const GST_CLOCK_FLAG_CAN_DO_SINGLE_SYNC: c_int = 16;
pub const GST_CLOCK_FLAG_CAN_DO_SINGLE_ASYNC: c_int = 32;
pub const GST_CLOCK_FLAG_CAN_DO_PERIODIC_SYNC: c_int = 64;
pub const GST_CLOCK_FLAG_CAN_DO_PERIODIC_ASYNC: c_int = 128;
pub const GST_CLOCK_FLAG_CAN_SET_RESOLUTION: c_int = 256;
pub const GST_CLOCK_FLAG_CAN_SET_MASTER: c_int = 512;
pub const GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC: c_int = 1024;
pub const GST_CLOCK_FLAG_LAST: c_int = 4096;
pub const GstClockFlags = c_uint;
pub extern fn gst_clock_get_type() GType;
pub extern fn gst_clock_set_resolution(clock: [*c]GstClock, resolution: GstClockTime) GstClockTime;
pub extern fn gst_clock_get_resolution(clock: [*c]GstClock) GstClockTime;
pub extern fn gst_clock_get_time(clock: [*c]GstClock) GstClockTime;
pub extern fn gst_clock_set_calibration(clock: [*c]GstClock, internal: GstClockTime, external: GstClockTime, rate_num: GstClockTime, rate_denom: GstClockTime) void;
pub extern fn gst_clock_get_calibration(clock: [*c]GstClock, internal: [*c]GstClockTime, external: [*c]GstClockTime, rate_num: [*c]GstClockTime, rate_denom: [*c]GstClockTime) void;
pub extern fn gst_clock_set_master(clock: [*c]GstClock, master: [*c]GstClock) gboolean;
pub extern fn gst_clock_get_master(clock: [*c]GstClock) [*c]GstClock;
pub extern fn gst_clock_set_timeout(clock: [*c]GstClock, timeout: GstClockTime) void;
pub extern fn gst_clock_get_timeout(clock: [*c]GstClock) GstClockTime;
pub extern fn gst_clock_add_observation(clock: [*c]GstClock, slave: GstClockTime, master: GstClockTime, r_squared: [*c]gdouble) gboolean;
pub extern fn gst_clock_add_observation_unapplied(clock: [*c]GstClock, slave: GstClockTime, master: GstClockTime, r_squared: [*c]gdouble, internal: [*c]GstClockTime, external: [*c]GstClockTime, rate_num: [*c]GstClockTime, rate_denom: [*c]GstClockTime) gboolean;
pub extern fn gst_clock_get_internal_time(clock: [*c]GstClock) GstClockTime;
pub extern fn gst_clock_adjust_unlocked(clock: [*c]GstClock, internal: GstClockTime) GstClockTime;
pub extern fn gst_clock_adjust_with_calibration(clock: [*c]GstClock, internal_target: GstClockTime, cinternal: GstClockTime, cexternal: GstClockTime, cnum: GstClockTime, cdenom: GstClockTime) GstClockTime;
pub extern fn gst_clock_unadjust_with_calibration(clock: [*c]GstClock, external_target: GstClockTime, cinternal: GstClockTime, cexternal: GstClockTime, cnum: GstClockTime, cdenom: GstClockTime) GstClockTime;
pub extern fn gst_clock_unadjust_unlocked(clock: [*c]GstClock, external: GstClockTime) GstClockTime;
pub extern fn gst_clock_wait_for_sync(clock: [*c]GstClock, timeout: GstClockTime) gboolean;
pub extern fn gst_clock_is_synced(clock: [*c]GstClock) gboolean;
pub extern fn gst_clock_set_synced(clock: [*c]GstClock, synced: gboolean) void;
pub extern fn gst_clock_new_single_shot_id(clock: [*c]GstClock, time: GstClockTime) GstClockID;
pub extern fn gst_clock_new_periodic_id(clock: [*c]GstClock, start_time: GstClockTime, interval: GstClockTime) GstClockID;
pub extern fn gst_clock_id_ref(id: GstClockID) GstClockID;
pub extern fn gst_clock_id_unref(id: GstClockID) void;
pub extern fn gst_clock_id_compare_func(id1: gconstpointer, id2: gconstpointer) gint;
pub extern fn gst_clock_id_get_clock(id: GstClockID) [*c]GstClock;
pub extern fn gst_clock_id_uses_clock(id: GstClockID, clock: [*c]GstClock) gboolean;
pub extern fn gst_clock_id_get_time(id: GstClockID) GstClockTime;
pub extern fn gst_clock_id_wait(id: GstClockID, jitter: [*c]GstClockTimeDiff) GstClockReturn;
pub extern fn gst_clock_id_wait_async(id: GstClockID, func: GstClockCallback, user_data: gpointer, destroy_data: GDestroyNotify) GstClockReturn;
pub extern fn gst_clock_id_unschedule(id: GstClockID) void;
pub extern fn gst_clock_single_shot_id_reinit(clock: [*c]GstClock, id: GstClockID, time: GstClockTime) gboolean;
pub extern fn gst_clock_periodic_id_reinit(clock: [*c]GstClock, id: GstClockID, start_time: GstClockTime, interval: GstClockTime) gboolean;
pub const GstClock_autoptr = [*c]GstClock;
pub const GstClock_listautoptr = [*c]GList;
pub const GstClock_slistautoptr = [*c]GSList;
pub const GstClock_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstClock(arg__ptr: [*c]GstClock) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstClock(arg__ptr: [*c][*c]GstClock) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstClock(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstClock(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstClock(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstClock(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub fn glib_auto_cleanup_GstClockID(arg__ptr: [*c]GstClockID) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr.* != null) {
        gst_clock_id_unref(_ptr.*);
    }
}
pub const GstControlSource = struct__GstControlSource;
pub const GstControlSourceGetValue = ?fn ([*c]GstControlSource, GstClockTime, [*c]gdouble) callconv(.C) gboolean;
pub const GstControlSourceGetValueArray = ?fn ([*c]GstControlSource, GstClockTime, GstClockTime, guint, [*c]gdouble) callconv(.C) gboolean;
pub const struct__GstControlSource = extern struct {
    parent: GstObject,
    get_value: GstControlSourceGetValue,
    get_value_array: GstControlSourceGetValueArray,
    _gst_reserved: [4]gpointer,
};
pub const struct__GstControlSourceClass = extern struct {
    parent_class: GstObjectClass,
    _gst_reserved: [4]gpointer,
};
pub const GstControlSourceClass = struct__GstControlSourceClass;
pub const struct__GstTimedValue = extern struct {
    timestamp: GstClockTime,
    value: gdouble,
};
pub const GstTimedValue = struct__GstTimedValue;
pub const struct__GstValueArray = opaque {};
pub const GstValueArray = struct__GstValueArray;
pub extern fn gst_control_source_get_type() GType;
pub extern fn gst_control_source_get_value(self: [*c]GstControlSource, timestamp: GstClockTime, value: [*c]gdouble) gboolean;
pub extern fn gst_control_source_get_value_array(self: [*c]GstControlSource, timestamp: GstClockTime, interval: GstClockTime, n_values: guint, values: [*c]gdouble) gboolean;
pub const GstControlSource_autoptr = [*c]GstControlSource;
pub const GstControlSource_listautoptr = [*c]GList;
pub const GstControlSource_slistautoptr = [*c]GSList;
pub const GstControlSource_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstControlSource(arg__ptr: [*c]GstControlSource) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstControlSource(arg__ptr: [*c][*c]GstControlSource) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstControlSource(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstControlSource(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstControlSource(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstControlSource(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub const GstValueArray_autoptr = ?*GstValueArray;
pub const GstValueArray_listautoptr = [*c]GList;
pub const GstValueArray_slistautoptr = [*c]GSList;
pub const GstValueArray_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstValueArray(arg__ptr: ?*GstValueArray) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstValueArray(arg__ptr: [*c]?*GstValueArray) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstValueArray(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstValueArray(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstValueArray(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstValueArray(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub const GstControlBindingConvert = ?fn ([*c]GstControlBinding, gdouble, [*c]GValue) callconv(.C) void;
pub extern fn gst_control_binding_get_type() GType;
pub extern fn gst_control_binding_sync_values(binding: [*c]GstControlBinding, object: [*c]GstObject, timestamp: GstClockTime, last_sync: GstClockTime) gboolean;
pub extern fn gst_control_binding_get_value(binding: [*c]GstControlBinding, timestamp: GstClockTime) [*c]GValue;
pub extern fn gst_control_binding_get_value_array(binding: [*c]GstControlBinding, timestamp: GstClockTime, interval: GstClockTime, n_values: guint, values: gpointer) gboolean;
pub extern fn gst_control_binding_get_g_value_array(binding: [*c]GstControlBinding, timestamp: GstClockTime, interval: GstClockTime, n_values: guint, values: [*c]GValue) gboolean;
pub extern fn gst_control_binding_set_disabled(binding: [*c]GstControlBinding, disabled: gboolean) void;
pub extern fn gst_control_binding_is_disabled(binding: [*c]GstControlBinding) gboolean;
pub const GstControlBinding_autoptr = [*c]GstControlBinding;
pub const GstControlBinding_listautoptr = [*c]GList;
pub const GstControlBinding_slistautoptr = [*c]GSList;
pub const GstControlBinding_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstControlBinding(arg__ptr: [*c]GstControlBinding) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstControlBinding(arg__ptr: [*c][*c]GstControlBinding) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstControlBinding(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstControlBinding(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstControlBinding(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstControlBinding(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub extern fn gst_object_suggest_next_sync(object: [*c]GstObject) GstClockTime;
pub extern fn gst_object_sync_values(object: [*c]GstObject, timestamp: GstClockTime) gboolean;
pub extern fn gst_object_has_active_control_bindings(object: [*c]GstObject) gboolean;
pub extern fn gst_object_set_control_bindings_disabled(object: [*c]GstObject, disabled: gboolean) void;
pub extern fn gst_object_set_control_binding_disabled(object: [*c]GstObject, property_name: [*c]const gchar, disabled: gboolean) void;
pub extern fn gst_object_add_control_binding(object: [*c]GstObject, binding: [*c]GstControlBinding) gboolean;
pub extern fn gst_object_get_control_binding(object: [*c]GstObject, property_name: [*c]const gchar) [*c]GstControlBinding;
pub extern fn gst_object_remove_control_binding(object: [*c]GstObject, binding: [*c]GstControlBinding) gboolean;
pub extern fn gst_object_get_value(object: [*c]GstObject, property_name: [*c]const gchar, timestamp: GstClockTime) [*c]GValue;
pub extern fn gst_object_get_value_array(object: [*c]GstObject, property_name: [*c]const gchar, timestamp: GstClockTime, interval: GstClockTime, n_values: guint, values: gpointer) gboolean;
pub extern fn gst_object_get_g_value_array(object: [*c]GstObject, property_name: [*c]const gchar, timestamp: GstClockTime, interval: GstClockTime, n_values: guint, values: [*c]GValue) gboolean;
pub extern fn gst_object_get_control_rate(object: [*c]GstObject) GstClockTime;
pub extern fn gst_object_set_control_rate(object: [*c]GstObject, control_rate: GstClockTime) void;
pub const GstObject_autoptr = [*c]GstObject;
pub const GstObject_listautoptr = [*c]GList;
pub const GstObject_slistautoptr = [*c]GSList;
pub const GstObject_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstObject(arg__ptr: [*c]GstObject) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstObject(arg__ptr: [*c][*c]GstObject) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstObject(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstObject(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstObject(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstObject(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub const struct__GstPadClass = extern struct {
    parent_class: GstObjectClass,
    linked: ?fn (?*GstPad, ?*GstPad) callconv(.C) void,
    unlinked: ?fn (?*GstPad, ?*GstPad) callconv(.C) void,
    _gst_reserved: [4]gpointer,
};
pub const GstPadClass = struct__GstPadClass;
const struct_unnamed_54 = extern struct {
    flow_ret: GstFlowReturn,
};
const union_unnamed_53 = extern union {
    _gst_reserved: [4]gpointer,
    abi: struct_unnamed_54,
};
pub const struct__GstPadProbeInfo = extern struct {
    type: GstPadProbeType,
    id: gulong,
    data: gpointer,
    offset: guint64,
    size: guint,
    ABI: union_unnamed_53,
};
pub const GstPadProbeInfo = struct__GstPadProbeInfo;
pub const GST_PAD_UNKNOWN: c_int = 0;
pub const GST_PAD_SRC: c_int = 1;
pub const GST_PAD_SINK: c_int = 2;
pub const GstPadDirection = c_uint;
pub const GST_PAD_MODE_NONE: c_int = 0;
pub const GST_PAD_MODE_PUSH: c_int = 1;
pub const GST_PAD_MODE_PULL: c_int = 2;
pub const GstPadMode = c_uint;
pub extern fn gst_pad_mode_get_name(mode: GstPadMode) [*c]const gchar;
pub extern var _gst_mini_object_type: GType;
pub extern fn gst_mini_object_get_type() GType;
pub const GstMiniObjectNotify = ?fn (gpointer, [*c]GstMiniObject) callconv(.C) void;
pub const GST_MINI_OBJECT_FLAG_LOCKABLE: c_int = 1;
pub const GST_MINI_OBJECT_FLAG_LOCK_READONLY: c_int = 2;
pub const GST_MINI_OBJECT_FLAG_MAY_BE_LEAKED: c_int = 4;
pub const GST_MINI_OBJECT_FLAG_LAST: c_int = 16;
pub const GstMiniObjectFlags = c_uint;
pub const GST_LOCK_FLAG_READ: c_int = 1;
pub const GST_LOCK_FLAG_WRITE: c_int = 2;
pub const GST_LOCK_FLAG_EXCLUSIVE: c_int = 4;
pub const GST_LOCK_FLAG_LAST: c_int = 256;
pub const GstLockFlags = c_uint;
pub extern fn gst_mini_object_init(mini_object: [*c]GstMiniObject, flags: guint, @"type": GType, copy_func: GstMiniObjectCopyFunction, dispose_func: GstMiniObjectDisposeFunction, free_func: GstMiniObjectFreeFunction) void;
pub extern fn gst_mini_object_ref(mini_object: [*c]GstMiniObject) [*c]GstMiniObject;
pub extern fn gst_mini_object_unref(mini_object: [*c]GstMiniObject) void;
pub extern fn gst_clear_mini_object(object_ptr: [*c][*c]GstMiniObject) void;
pub extern fn gst_mini_object_weak_ref(object: [*c]GstMiniObject, notify: GstMiniObjectNotify, data: gpointer) void;
pub extern fn gst_mini_object_weak_unref(object: [*c]GstMiniObject, notify: GstMiniObjectNotify, data: gpointer) void;
pub extern fn gst_mini_object_lock(object: [*c]GstMiniObject, flags: GstLockFlags) gboolean;
pub extern fn gst_mini_object_unlock(object: [*c]GstMiniObject, flags: GstLockFlags) void;
pub extern fn gst_mini_object_is_writable(mini_object: [*c]const GstMiniObject) gboolean;
pub extern fn gst_mini_object_make_writable(mini_object: [*c]GstMiniObject) [*c]GstMiniObject;
pub extern fn gst_mini_object_copy(mini_object: [*c]const GstMiniObject) [*c]GstMiniObject;
pub extern fn gst_mini_object_set_qdata(object: [*c]GstMiniObject, quark: GQuark, data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gst_mini_object_get_qdata(object: [*c]GstMiniObject, quark: GQuark) gpointer;
pub extern fn gst_mini_object_steal_qdata(object: [*c]GstMiniObject, quark: GQuark) gpointer;
pub extern fn gst_mini_object_add_parent(object: [*c]GstMiniObject, parent: [*c]GstMiniObject) void;
pub extern fn gst_mini_object_remove_parent(object: [*c]GstMiniObject, parent: [*c]GstMiniObject) void;
pub extern fn gst_mini_object_replace(olddata: [*c][*c]GstMiniObject, newdata: [*c]GstMiniObject) gboolean;
pub extern fn gst_mini_object_take(olddata: [*c][*c]GstMiniObject, newdata: [*c]GstMiniObject) gboolean;
pub extern fn gst_mini_object_steal(olddata: [*c][*c]GstMiniObject) [*c]GstMiniObject;
pub extern var _gst_memory_type: GType;
pub extern fn gst_memory_get_type() GType;
pub const GstMemory = struct__GstMemory;
pub const GstMemoryMapFunction = ?fn ([*c]GstMemory, gsize, GstMapFlags) callconv(.C) gpointer;
pub const GstMemoryUnmapFunction = ?fn ([*c]GstMemory) callconv(.C) void;
pub const GstMemoryCopyFunction = ?fn ([*c]GstMemory, gssize, gssize) callconv(.C) [*c]GstMemory;
pub const GstMemoryShareFunction = ?fn ([*c]GstMemory, gssize, gssize) callconv(.C) [*c]GstMemory;
pub const GstMemoryIsSpanFunction = ?fn ([*c]GstMemory, [*c]GstMemory, [*c]gsize) callconv(.C) gboolean;
pub const GstMemoryMapFullFunction = ?fn ([*c]GstMemory, [*c]GstMapInfo, gsize) callconv(.C) gpointer;
pub const GstMemoryUnmapFullFunction = ?fn ([*c]GstMemory, [*c]GstMapInfo) callconv(.C) void;
pub const struct__GstAllocatorPrivate = opaque {};
pub const GstAllocatorPrivate = struct__GstAllocatorPrivate;
pub const struct__GstAllocator = extern struct {
    object: GstObject,
    mem_type: [*c]const gchar,
    mem_map: GstMemoryMapFunction,
    mem_unmap: GstMemoryUnmapFunction,
    mem_copy: GstMemoryCopyFunction,
    mem_share: GstMemoryShareFunction,
    mem_is_span: GstMemoryIsSpanFunction,
    mem_map_full: GstMemoryMapFullFunction,
    mem_unmap_full: GstMemoryUnmapFullFunction,
    _gst_reserved: [2]gpointer,
    priv: ?*GstAllocatorPrivate,
};
pub const GstAllocator = struct__GstAllocator;
pub const struct__GstMemory = extern struct {
    mini_object: GstMiniObject,
    allocator: [*c]GstAllocator,
    parent: [*c]GstMemory,
    maxsize: gsize,
    @"align": gsize,
    offset: gsize,
    size: gsize,
};
pub const GST_MEMORY_FLAG_READONLY: c_int = 2;
pub const GST_MEMORY_FLAG_NO_SHARE: c_int = 16;
pub const GST_MEMORY_FLAG_ZERO_PREFIXED: c_int = 32;
pub const GST_MEMORY_FLAG_ZERO_PADDED: c_int = 64;
pub const GST_MEMORY_FLAG_PHYSICALLY_CONTIGUOUS: c_int = 128;
pub const GST_MEMORY_FLAG_NOT_MAPPABLE: c_int = 256;
pub const GST_MEMORY_FLAG_LAST: c_int = 1048576;
pub const GstMemoryFlags = c_uint;
pub const GST_MAP_READ: c_int = 1;
pub const GST_MAP_WRITE: c_int = 2;
pub const GST_MAP_FLAG_LAST: c_int = 65536;
pub const GstMapFlags = c_uint;
pub const GstMapInfo = extern struct {
    memory: [*c]GstMemory,
    flags: GstMapFlags,
    data: [*c]guint8,
    size: gsize,
    maxsize: gsize,
    user_data: [4]gpointer,
    _gst_reserved: [4]gpointer,
};
pub extern fn gst_memory_init(mem: [*c]GstMemory, flags: GstMemoryFlags, allocator: [*c]GstAllocator, parent: [*c]GstMemory, maxsize: gsize, @"align": gsize, offset: gsize, size: gsize) void;
pub extern fn gst_memory_is_type(mem: [*c]GstMemory, mem_type: [*c]const gchar) gboolean;
pub fn gst_memory_ref(arg_memory: [*c]GstMemory) callconv(.C) [*c]GstMemory {
    var memory = arg_memory;
    return @ptrCast([*c]GstMemory, @alignCast(@import("std").meta.alignment([*c]GstMemory), gst_mini_object_ref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), memory)))));
}
pub fn gst_memory_unref(arg_memory: [*c]GstMemory) callconv(.C) void {
    var memory = arg_memory;
    gst_mini_object_unref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), memory)));
}
pub extern fn gst_memory_get_sizes(mem: [*c]GstMemory, offset: [*c]gsize, maxsize: [*c]gsize) gsize;
pub extern fn gst_memory_resize(mem: [*c]GstMemory, offset: gssize, size: gsize) void;
pub extern fn gst_memory_make_mapped(mem: [*c]GstMemory, info: [*c]GstMapInfo, flags: GstMapFlags) [*c]GstMemory;
pub extern fn gst_memory_map(mem: [*c]GstMemory, info: [*c]GstMapInfo, flags: GstMapFlags) gboolean;
pub extern fn gst_memory_unmap(mem: [*c]GstMemory, info: [*c]GstMapInfo) void;
pub extern fn gst_memory_copy(mem: [*c]GstMemory, offset: gssize, size: gssize) [*c]GstMemory;
pub extern fn gst_memory_share(mem: [*c]GstMemory, offset: gssize, size: gssize) [*c]GstMemory;
pub extern fn gst_memory_is_span(mem1: [*c]GstMemory, mem2: [*c]GstMemory, offset: [*c]gsize) gboolean;
pub const GstMemory_autoptr = [*c]GstMemory;
pub const GstMemory_listautoptr = [*c]GList;
pub const GstMemory_slistautoptr = [*c]GSList;
pub const GstMemory_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstMemory(arg__ptr: [*c]GstMemory) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_memory_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GstMemory(arg__ptr: [*c][*c]GstMemory) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstMemory(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstMemory(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_memory_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstMemory(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_memory_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstMemory(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_memory_unref)))));
    }
}
pub const GstAllocator_autoptr = [*c]GstAllocator;
pub const GstAllocator_listautoptr = [*c]GList;
pub const GstAllocator_slistautoptr = [*c]GSList;
pub const GstAllocator_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstAllocator(arg__ptr: [*c]GstAllocator) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstAllocator(arg__ptr: [*c][*c]GstAllocator) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstAllocator(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstAllocator(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstAllocator(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstAllocator(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub const struct__GstAllocationParams = extern struct {
    flags: GstMemoryFlags,
    @"align": gsize,
    prefix: gsize,
    padding: gsize,
    _gst_reserved: [4]gpointer,
};
pub const GstAllocationParams = struct__GstAllocationParams;
pub const struct__GstAllocatorClass = extern struct {
    object_class: GstObjectClass,
    alloc: ?fn ([*c]GstAllocator, gsize, [*c]GstAllocationParams) callconv(.C) [*c]GstMemory,
    free: ?fn ([*c]GstAllocator, [*c]GstMemory) callconv(.C) void,
    _gst_reserved: [4]gpointer,
};
pub const GstAllocatorClass = struct__GstAllocatorClass;
pub extern fn gst_allocation_params_get_type() GType;
pub extern var gst_memory_alignment: gsize;
pub const GST_ALLOCATOR_FLAG_CUSTOM_ALLOC: c_int = 16;
pub const GST_ALLOCATOR_FLAG_LAST: c_int = 1048576;
pub const GstAllocatorFlags = c_uint;
pub extern fn gst_allocator_get_type() GType;
pub extern fn gst_allocator_register(name: [*c]const gchar, allocator: [*c]GstAllocator) void;
pub extern fn gst_allocator_find(name: [*c]const gchar) [*c]GstAllocator;
pub extern fn gst_allocator_set_default(allocator: [*c]GstAllocator) void;
pub extern fn gst_allocation_params_new() [*c]GstAllocationParams;
pub extern fn gst_allocation_params_init(params: [*c]GstAllocationParams) void;
pub extern fn gst_allocation_params_copy(params: [*c]const GstAllocationParams) [*c]GstAllocationParams;
pub extern fn gst_allocation_params_free(params: [*c]GstAllocationParams) void;
pub extern fn gst_allocator_alloc(allocator: [*c]GstAllocator, size: gsize, params: [*c]GstAllocationParams) [*c]GstMemory;
pub extern fn gst_allocator_free(allocator: [*c]GstAllocator, memory: [*c]GstMemory) void;
pub extern fn gst_memory_new_wrapped(flags: GstMemoryFlags, data: gpointer, maxsize: gsize, offset: gsize, size: gsize, user_data: gpointer, notify: GDestroyNotify) [*c]GstMemory;
pub const GstAllocationParams_autoptr = [*c]GstAllocationParams;
pub const GstAllocationParams_listautoptr = [*c]GList;
pub const GstAllocationParams_slistautoptr = [*c]GSList;
pub const GstAllocationParams_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstAllocationParams(arg__ptr: [*c]GstAllocationParams) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_allocation_params_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GstAllocationParams(arg__ptr: [*c][*c]GstAllocationParams) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstAllocationParams(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstAllocationParams(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_allocation_params_free)))));
}
pub fn glib_slistautoptr_cleanup_GstAllocationParams(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_allocation_params_free)))));
}
pub fn glib_queueautoptr_cleanup_GstAllocationParams(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_allocation_params_free)))));
    }
}
pub const struct__GstDateTime = opaque {};
pub const GstDateTime = struct__GstDateTime;
pub extern var _gst_date_time_type: GType;
pub extern fn gst_date_time_get_type() GType;
pub extern fn gst_date_time_has_year(datetime: ?*const GstDateTime) gboolean;
pub extern fn gst_date_time_has_month(datetime: ?*const GstDateTime) gboolean;
pub extern fn gst_date_time_has_day(datetime: ?*const GstDateTime) gboolean;
pub extern fn gst_date_time_has_time(datetime: ?*const GstDateTime) gboolean;
pub extern fn gst_date_time_has_second(datetime: ?*const GstDateTime) gboolean;
pub extern fn gst_date_time_get_year(datetime: ?*const GstDateTime) gint;
pub extern fn gst_date_time_get_month(datetime: ?*const GstDateTime) gint;
pub extern fn gst_date_time_get_day(datetime: ?*const GstDateTime) gint;
pub extern fn gst_date_time_get_hour(datetime: ?*const GstDateTime) gint;
pub extern fn gst_date_time_get_minute(datetime: ?*const GstDateTime) gint;
pub extern fn gst_date_time_get_second(datetime: ?*const GstDateTime) gint;
pub extern fn gst_date_time_get_microsecond(datetime: ?*const GstDateTime) gint;
pub extern fn gst_date_time_get_time_zone_offset(datetime: ?*const GstDateTime) gfloat;
pub extern fn gst_date_time_new_from_unix_epoch_local_time(secs: gint64) ?*GstDateTime;
pub extern fn gst_date_time_new_from_unix_epoch_utc(secs: gint64) ?*GstDateTime;
pub extern fn gst_date_time_new_from_unix_epoch_local_time_usecs(usecs: gint64) ?*GstDateTime;
pub extern fn gst_date_time_new_from_unix_epoch_utc_usecs(usecs: gint64) ?*GstDateTime;
pub extern fn gst_date_time_new_local_time(year: gint, month: gint, day: gint, hour: gint, minute: gint, seconds: gdouble) ?*GstDateTime;
pub extern fn gst_date_time_new_y(year: gint) ?*GstDateTime;
pub extern fn gst_date_time_new_ym(year: gint, month: gint) ?*GstDateTime;
pub extern fn gst_date_time_new_ymd(year: gint, month: gint, day: gint) ?*GstDateTime;
pub extern fn gst_date_time_new(tzoffset: gfloat, year: gint, month: gint, day: gint, hour: gint, minute: gint, seconds: gdouble) ?*GstDateTime;
pub extern fn gst_date_time_new_now_local_time() ?*GstDateTime;
pub extern fn gst_date_time_new_now_utc() ?*GstDateTime;
pub extern fn gst_date_time_to_iso8601_string(datetime: ?*GstDateTime) [*c]gchar;
pub extern fn gst_date_time_new_from_iso8601_string(string: [*c]const gchar) ?*GstDateTime;
pub extern fn gst_date_time_to_g_date_time(datetime: ?*GstDateTime) ?*GDateTime;
pub extern fn gst_date_time_new_from_g_date_time(dt: ?*GDateTime) ?*GstDateTime;
pub extern fn gst_date_time_ref(datetime: ?*GstDateTime) ?*GstDateTime;
pub extern fn gst_date_time_unref(datetime: ?*GstDateTime) void;
pub const GstDateTime_autoptr = ?*GstDateTime;
pub const GstDateTime_listautoptr = [*c]GList;
pub const GstDateTime_slistautoptr = [*c]GSList;
pub const GstDateTime_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstDateTime(arg__ptr: ?*GstDateTime) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_date_time_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GstDateTime(arg__ptr: [*c]?*GstDateTime) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstDateTime(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstDateTime(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_date_time_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstDateTime(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_date_time_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstDateTime(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_date_time_unref)))));
    }
}
pub extern var _gst_structure_type: GType;
pub const struct__GstStructure = extern struct {
    type: GType,
    name: GQuark,
};
pub const GstStructure = struct__GstStructure;
pub const GST_SERIALIZE_FLAG_NONE: c_int = 0;
pub const GST_SERIALIZE_FLAG_BACKWARD_COMPAT: c_int = 1;
pub const GstSerializeFlags = c_uint;
pub const GstStructureForeachFunc = ?fn (GQuark, [*c]const GValue, gpointer) callconv(.C) gboolean;
pub const GstStructureMapFunc = ?fn (GQuark, [*c]GValue, gpointer) callconv(.C) gboolean;
pub const GstStructureFilterMapFunc = ?fn (GQuark, [*c]GValue, gpointer) callconv(.C) gboolean;
pub extern fn gst_structure_get_type() GType;
pub extern fn gst_structure_new_empty(name: [*c]const gchar) [*c]GstStructure;
pub extern fn gst_structure_new_id_empty(quark: GQuark) [*c]GstStructure;
pub extern fn gst_structure_new(name: [*c]const gchar, firstfield: [*c]const gchar, ...) [*c]GstStructure;
pub extern fn gst_structure_new_valist(name: [*c]const gchar, firstfield: [*c]const gchar, varargs: va_list) [*c]GstStructure;
pub extern fn gst_structure_new_id(name_quark: GQuark, field_quark: GQuark, ...) [*c]GstStructure;
pub extern fn gst_structure_new_from_string(string: [*c]const gchar) [*c]GstStructure;
pub extern fn gst_structure_copy(structure: [*c]const GstStructure) [*c]GstStructure;
pub extern fn gst_structure_set_parent_refcount(structure: [*c]GstStructure, refcount: [*c]gint) gboolean;
pub extern fn gst_structure_free(structure: [*c]GstStructure) void;
pub extern fn gst_clear_structure(structure_ptr: [*c][*c]GstStructure) void;
pub extern fn gst_structure_take(oldstr_ptr: [*c][*c]GstStructure, newstr: [*c]GstStructure) gboolean;
pub extern fn gst_structure_get_name(structure: [*c]const GstStructure) [*c]const gchar;
pub extern fn gst_structure_get_name_id(structure: [*c]const GstStructure) GQuark;
pub extern fn gst_structure_has_name(structure: [*c]const GstStructure, name: [*c]const gchar) gboolean;
pub extern fn gst_structure_set_name(structure: [*c]GstStructure, name: [*c]const gchar) void;
pub extern fn gst_structure_id_set_value(structure: [*c]GstStructure, field: GQuark, value: [*c]const GValue) void;
pub extern fn gst_structure_set_value(structure: [*c]GstStructure, fieldname: [*c]const gchar, value: [*c]const GValue) void;
pub extern fn gst_structure_set_array(structure: [*c]GstStructure, fieldname: [*c]const gchar, array: [*c]const GValueArray) void;
pub extern fn gst_structure_set_list(structure: [*c]GstStructure, fieldname: [*c]const gchar, array: [*c]const GValueArray) void;
pub extern fn gst_structure_id_take_value(structure: [*c]GstStructure, field: GQuark, value: [*c]GValue) void;
pub extern fn gst_structure_take_value(structure: [*c]GstStructure, fieldname: [*c]const gchar, value: [*c]GValue) void;
pub extern fn gst_structure_set(structure: [*c]GstStructure, fieldname: [*c]const gchar, ...) void;
pub extern fn gst_structure_set_valist(structure: [*c]GstStructure, fieldname: [*c]const gchar, varargs: va_list) void;
pub extern fn gst_structure_id_set(structure: [*c]GstStructure, fieldname: GQuark, ...) void;
pub extern fn gst_structure_id_set_valist(structure: [*c]GstStructure, fieldname: GQuark, varargs: va_list) void;
pub extern fn gst_structure_get_valist(structure: [*c]const GstStructure, first_fieldname: [*c]const u8, args: va_list) gboolean;
pub extern fn gst_structure_get(structure: [*c]const GstStructure, first_fieldname: [*c]const u8, ...) gboolean;
pub extern fn gst_structure_id_get_valist(structure: [*c]const GstStructure, first_field_id: GQuark, args: va_list) gboolean;
pub extern fn gst_structure_id_get(structure: [*c]const GstStructure, first_field_id: GQuark, ...) gboolean;
pub extern fn gst_structure_id_get_value(structure: [*c]const GstStructure, field: GQuark) [*c]const GValue;
pub extern fn gst_structure_get_value(structure: [*c]const GstStructure, fieldname: [*c]const gchar) [*c]const GValue;
pub extern fn gst_structure_remove_field(structure: [*c]GstStructure, fieldname: [*c]const gchar) void;
pub extern fn gst_structure_remove_fields(structure: [*c]GstStructure, fieldname: [*c]const gchar, ...) void;
pub extern fn gst_structure_remove_fields_valist(structure: [*c]GstStructure, fieldname: [*c]const gchar, varargs: va_list) void;
pub extern fn gst_structure_remove_all_fields(structure: [*c]GstStructure) void;
pub extern fn gst_structure_get_field_type(structure: [*c]const GstStructure, fieldname: [*c]const gchar) GType;
pub extern fn gst_structure_foreach(structure: [*c]const GstStructure, func: GstStructureForeachFunc, user_data: gpointer) gboolean;
pub extern fn gst_structure_map_in_place(structure: [*c]GstStructure, func: GstStructureMapFunc, user_data: gpointer) gboolean;
pub extern fn gst_structure_filter_and_map_in_place(structure: [*c]GstStructure, func: GstStructureFilterMapFunc, user_data: gpointer) void;
pub extern fn gst_structure_n_fields(structure: [*c]const GstStructure) gint;
pub extern fn gst_structure_nth_field_name(structure: [*c]const GstStructure, index: guint) [*c]const gchar;
pub extern fn gst_structure_id_has_field(structure: [*c]const GstStructure, field: GQuark) gboolean;
pub extern fn gst_structure_id_has_field_typed(structure: [*c]const GstStructure, field: GQuark, @"type": GType) gboolean;
pub extern fn gst_structure_has_field(structure: [*c]const GstStructure, fieldname: [*c]const gchar) gboolean;
pub extern fn gst_structure_has_field_typed(structure: [*c]const GstStructure, fieldname: [*c]const gchar, @"type": GType) gboolean;
pub extern fn gst_structure_get_boolean(structure: [*c]const GstStructure, fieldname: [*c]const gchar, value: [*c]gboolean) gboolean;
pub extern fn gst_structure_get_int(structure: [*c]const GstStructure, fieldname: [*c]const gchar, value: [*c]gint) gboolean;
pub extern fn gst_structure_get_uint(structure: [*c]const GstStructure, fieldname: [*c]const gchar, value: [*c]guint) gboolean;
pub extern fn gst_structure_get_int64(structure: [*c]const GstStructure, fieldname: [*c]const gchar, value: [*c]gint64) gboolean;
pub extern fn gst_structure_get_uint64(structure: [*c]const GstStructure, fieldname: [*c]const gchar, value: [*c]guint64) gboolean;
pub extern fn gst_structure_get_double(structure: [*c]const GstStructure, fieldname: [*c]const gchar, value: [*c]gdouble) gboolean;
pub extern fn gst_structure_get_date(structure: [*c]const GstStructure, fieldname: [*c]const gchar, value: [*c]?*GDate) gboolean;
pub extern fn gst_structure_get_date_time(structure: [*c]const GstStructure, fieldname: [*c]const gchar, value: [*c]?*GstDateTime) gboolean;
pub extern fn gst_structure_get_clock_time(structure: [*c]const GstStructure, fieldname: [*c]const gchar, value: [*c]GstClockTime) gboolean;
pub extern fn gst_structure_get_string(structure: [*c]const GstStructure, fieldname: [*c]const gchar) [*c]const gchar;
pub extern fn gst_structure_get_enum(structure: [*c]const GstStructure, fieldname: [*c]const gchar, enumtype: GType, value: [*c]gint) gboolean;
pub extern fn gst_structure_get_fraction(structure: [*c]const GstStructure, fieldname: [*c]const gchar, value_numerator: [*c]gint, value_denominator: [*c]gint) gboolean;
pub extern fn gst_structure_get_flagset(structure: [*c]const GstStructure, fieldname: [*c]const gchar, value_flags: [*c]guint, value_mask: [*c]guint) gboolean;
pub extern fn gst_structure_get_array(structure: [*c]GstStructure, fieldname: [*c]const gchar, array: [*c][*c]GValueArray) gboolean;
pub extern fn gst_structure_get_list(structure: [*c]GstStructure, fieldname: [*c]const gchar, array: [*c][*c]GValueArray) gboolean;
pub extern fn gst_structure_to_string(structure: [*c]const GstStructure) [*c]gchar;
pub extern fn gst_structure_serialize(structure: [*c]const GstStructure, flags: GstSerializeFlags) [*c]gchar;
pub extern fn gst_structure_from_string(string: [*c]const gchar, end: [*c][*c]gchar) [*c]GstStructure;
pub extern fn gst_structure_fixate_field_nearest_int(structure: [*c]GstStructure, field_name: [*c]const u8, target: c_int) gboolean;
pub extern fn gst_structure_fixate_field_nearest_double(structure: [*c]GstStructure, field_name: [*c]const u8, target: f64) gboolean;
pub extern fn gst_structure_fixate_field_boolean(structure: [*c]GstStructure, field_name: [*c]const u8, target: gboolean) gboolean;
pub extern fn gst_structure_fixate_field_string(structure: [*c]GstStructure, field_name: [*c]const u8, target: [*c]const gchar) gboolean;
pub extern fn gst_structure_fixate_field_nearest_fraction(structure: [*c]GstStructure, field_name: [*c]const u8, target_numerator: gint, target_denominator: gint) gboolean;
pub extern fn gst_structure_fixate_field(structure: [*c]GstStructure, field_name: [*c]const u8) gboolean;
pub extern fn gst_structure_fixate(structure: [*c]GstStructure) void;
pub extern fn gst_structure_is_equal(structure1: [*c]const GstStructure, structure2: [*c]const GstStructure) gboolean;
pub extern fn gst_structure_is_subset(subset: [*c]const GstStructure, superset: [*c]const GstStructure) gboolean;
pub extern fn gst_structure_can_intersect(struct1: [*c]const GstStructure, struct2: [*c]const GstStructure) gboolean;
pub extern fn gst_structure_intersect(struct1: [*c]const GstStructure, struct2: [*c]const GstStructure) [*c]GstStructure;
pub const GstStructure_autoptr = [*c]GstStructure;
pub const GstStructure_listautoptr = [*c]GList;
pub const GstStructure_slistautoptr = [*c]GSList;
pub const GstStructure_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstStructure(arg__ptr: [*c]GstStructure) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_structure_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GstStructure(arg__ptr: [*c][*c]GstStructure) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstStructure(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstStructure(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_structure_free)))));
}
pub fn glib_slistautoptr_cleanup_GstStructure(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_structure_free)))));
}
pub fn glib_queueautoptr_cleanup_GstStructure(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_structure_free)))));
    }
}
pub const struct__GstCapsFeatures = opaque {};
pub const GstCapsFeatures = struct__GstCapsFeatures;
pub extern var _gst_caps_features_type: GType;
pub extern var _gst_caps_features_any: ?*GstCapsFeatures;
pub extern var _gst_caps_features_memory_system_memory: ?*GstCapsFeatures;
pub extern fn gst_caps_features_get_type() GType;
pub extern fn gst_is_caps_features(obj: gconstpointer) gboolean;
pub extern fn gst_caps_features_new_empty() ?*GstCapsFeatures;
pub extern fn gst_caps_features_new_any() ?*GstCapsFeatures;
pub extern fn gst_caps_features_new_single(feature: [*c]const gchar) ?*GstCapsFeatures;
pub extern fn gst_caps_features_new(feature1: [*c]const gchar, ...) ?*GstCapsFeatures;
pub extern fn gst_caps_features_new_valist(feature1: [*c]const gchar, varargs: va_list) ?*GstCapsFeatures;
pub extern fn gst_caps_features_new_id(feature1: GQuark, ...) ?*GstCapsFeatures;
pub extern fn gst_caps_features_new_id_valist(feature1: GQuark, varargs: va_list) ?*GstCapsFeatures;
pub extern fn gst_caps_features_set_parent_refcount(features: ?*GstCapsFeatures, refcount: [*c]gint) gboolean;
pub extern fn gst_caps_features_copy(features: ?*const GstCapsFeatures) ?*GstCapsFeatures;
pub extern fn gst_caps_features_free(features: ?*GstCapsFeatures) void;
pub extern fn gst_caps_features_to_string(features: ?*const GstCapsFeatures) [*c]gchar;
pub extern fn gst_caps_features_from_string(features: [*c]const gchar) ?*GstCapsFeatures;
pub extern fn gst_caps_features_get_size(features: ?*const GstCapsFeatures) guint;
pub extern fn gst_caps_features_get_nth(features: ?*const GstCapsFeatures, i: guint) [*c]const gchar;
pub extern fn gst_caps_features_get_nth_id(features: ?*const GstCapsFeatures, i: guint) GQuark;
pub extern fn gst_caps_features_contains(features: ?*const GstCapsFeatures, feature: [*c]const gchar) gboolean;
pub extern fn gst_caps_features_contains_id(features: ?*const GstCapsFeatures, feature: GQuark) gboolean;
pub extern fn gst_caps_features_is_equal(features1: ?*const GstCapsFeatures, features2: ?*const GstCapsFeatures) gboolean;
pub extern fn gst_caps_features_is_any(features: ?*const GstCapsFeatures) gboolean;
pub extern fn gst_caps_features_add(features: ?*GstCapsFeatures, feature: [*c]const gchar) void;
pub extern fn gst_caps_features_add_id(features: ?*GstCapsFeatures, feature: GQuark) void;
pub extern fn gst_caps_features_remove(features: ?*GstCapsFeatures, feature: [*c]const gchar) void;
pub extern fn gst_caps_features_remove_id(features: ?*GstCapsFeatures, feature: GQuark) void;
pub const GstCapsFeatures_autoptr = ?*GstCapsFeatures;
pub const GstCapsFeatures_listautoptr = [*c]GList;
pub const GstCapsFeatures_slistautoptr = [*c]GSList;
pub const GstCapsFeatures_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstCapsFeatures(arg__ptr: ?*GstCapsFeatures) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_caps_features_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GstCapsFeatures(arg__ptr: [*c]?*GstCapsFeatures) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstCapsFeatures(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstCapsFeatures(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_caps_features_free)))));
}
pub fn glib_slistautoptr_cleanup_GstCapsFeatures(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_caps_features_free)))));
}
pub fn glib_queueautoptr_cleanup_GstCapsFeatures(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_caps_features_free)))));
    }
}
pub extern var _gst_caps_type: GType;
pub const GST_CAPS_FLAG_ANY: c_int = 16;
pub const GstCapsFlags = c_uint;
pub const GST_CAPS_INTERSECT_ZIG_ZAG: c_int = 0;
pub const GST_CAPS_INTERSECT_FIRST: c_int = 1;
pub const GstCapsIntersectMode = c_uint;
pub const struct__GstStaticCaps = extern struct {
    caps: [*c]GstCaps,
    string: [*c]const u8,
    _gst_reserved: [4]gpointer,
};
pub const GstStaticCaps = struct__GstStaticCaps;
pub extern var _gst_caps_any: [*c]GstCaps;
pub extern var _gst_caps_none: [*c]GstCaps;
pub fn gst_caps_ref(arg_caps: [*c]GstCaps) callconv(.C) [*c]GstCaps {
    var caps = arg_caps;
    return @ptrCast([*c]GstCaps, @alignCast(@import("std").meta.alignment([*c]GstCaps), gst_mini_object_ref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), caps)))));
}
pub fn gst_caps_unref(arg_caps: [*c]GstCaps) callconv(.C) void {
    var caps = arg_caps;
    gst_mini_object_unref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), caps)));
} // /usr/include/glib-2.0/glib/gmacros.h:820:31: warning: ignoring StaticAssert declaration
// /usr/include/glib-2.0/glib/gmem.h:133:9: warning: unsupported bool expression type
// /usr/include/gstreamer-1.0/gst/gstcaps.h:207:1: warning: unable to translate function, demoted to extern
pub extern fn gst_clear_caps(arg_caps_ptr: [*c][*c]GstCaps) callconv(.C) void;
pub extern fn gst_caps_copy(caps: [*c]const GstCaps) [*c]GstCaps;
pub fn gst_caps_replace(arg_old_caps: [*c][*c]GstCaps, arg_new_caps: [*c]GstCaps) callconv(.C) gboolean {
    var old_caps = arg_old_caps;
    var new_caps = arg_new_caps;
    return gst_mini_object_replace(@ptrCast([*c][*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c][*c]GstMiniObject), old_caps)), @ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), new_caps)));
}
pub fn gst_caps_take(arg_old_caps: [*c][*c]GstCaps, arg_new_caps: [*c]GstCaps) callconv(.C) gboolean {
    var old_caps = arg_old_caps;
    var new_caps = arg_new_caps;
    return gst_mini_object_take(@ptrCast([*c][*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c][*c]GstMiniObject), old_caps)), @ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), new_caps)));
}
pub const GstCapsForeachFunc = ?fn (?*GstCapsFeatures, [*c]GstStructure, gpointer) callconv(.C) gboolean;
pub const GstCapsMapFunc = ?fn (?*GstCapsFeatures, [*c]GstStructure, gpointer) callconv(.C) gboolean;
pub const GstCapsFilterMapFunc = ?fn (?*GstCapsFeatures, [*c]GstStructure, gpointer) callconv(.C) gboolean;
pub extern fn gst_caps_get_type() GType;
pub extern fn gst_caps_new_empty() [*c]GstCaps;
pub extern fn gst_caps_new_any() [*c]GstCaps;
pub extern fn gst_caps_new_empty_simple(media_type: [*c]const u8) [*c]GstCaps;
pub extern fn gst_caps_new_simple(media_type: [*c]const u8, fieldname: [*c]const u8, ...) [*c]GstCaps;
pub extern fn gst_caps_new_full(struct1: [*c]GstStructure, ...) [*c]GstCaps;
pub extern fn gst_caps_new_full_valist(structure: [*c]GstStructure, var_args: va_list) [*c]GstCaps;
pub extern fn gst_static_caps_get_type() GType;
pub extern fn gst_static_caps_get(static_caps: [*c]GstStaticCaps) [*c]GstCaps;
pub extern fn gst_static_caps_cleanup(static_caps: [*c]GstStaticCaps) void;
pub extern fn gst_caps_append(caps1: [*c]GstCaps, caps2: [*c]GstCaps) void;
pub extern fn gst_caps_append_structure(caps: [*c]GstCaps, structure: [*c]GstStructure) void;
pub extern fn gst_caps_append_structure_full(caps: [*c]GstCaps, structure: [*c]GstStructure, features: ?*GstCapsFeatures) void;
pub extern fn gst_caps_remove_structure(caps: [*c]GstCaps, idx: guint) void;
pub extern fn gst_caps_merge(caps1: [*c]GstCaps, caps2: [*c]GstCaps) [*c]GstCaps;
pub extern fn gst_caps_merge_structure(caps: [*c]GstCaps, structure: [*c]GstStructure) [*c]GstCaps;
pub extern fn gst_caps_merge_structure_full(caps: [*c]GstCaps, structure: [*c]GstStructure, features: ?*GstCapsFeatures) [*c]GstCaps;
pub extern fn gst_caps_get_size(caps: [*c]const GstCaps) guint;
pub extern fn gst_caps_get_structure(caps: [*c]const GstCaps, index: guint) [*c]GstStructure;
pub extern fn gst_caps_steal_structure(caps: [*c]GstCaps, index: guint) [*c]GstStructure;
pub extern fn gst_caps_set_features(caps: [*c]GstCaps, index: guint, features: ?*GstCapsFeatures) void;
pub extern fn gst_caps_set_features_simple(caps: [*c]GstCaps, features: ?*GstCapsFeatures) void;
pub extern fn gst_caps_get_features(caps: [*c]const GstCaps, index: guint) ?*GstCapsFeatures;
pub extern fn gst_caps_copy_nth(caps: [*c]const GstCaps, nth: guint) [*c]GstCaps;
pub extern fn gst_caps_truncate(caps: [*c]GstCaps) [*c]GstCaps;
pub extern fn gst_caps_set_value(caps: [*c]GstCaps, field: [*c]const u8, value: [*c]const GValue) void;
pub extern fn gst_caps_set_simple(caps: [*c]GstCaps, field: [*c]const u8, ...) void;
pub extern fn gst_caps_set_simple_valist(caps: [*c]GstCaps, field: [*c]const u8, varargs: va_list) void;
pub extern fn gst_caps_foreach(caps: [*c]const GstCaps, func: GstCapsForeachFunc, user_data: gpointer) gboolean;
pub extern fn gst_caps_map_in_place(caps: [*c]GstCaps, func: GstCapsMapFunc, user_data: gpointer) gboolean;
pub extern fn gst_caps_filter_and_map_in_place(caps: [*c]GstCaps, func: GstCapsFilterMapFunc, user_data: gpointer) void;
pub extern fn gst_caps_is_any(caps: [*c]const GstCaps) gboolean;
pub extern fn gst_caps_is_empty(caps: [*c]const GstCaps) gboolean;
pub extern fn gst_caps_is_fixed(caps: [*c]const GstCaps) gboolean;
pub extern fn gst_caps_is_always_compatible(caps1: [*c]const GstCaps, caps2: [*c]const GstCaps) gboolean;
pub extern fn gst_caps_is_subset(subset: [*c]const GstCaps, superset: [*c]const GstCaps) gboolean;
pub extern fn gst_caps_is_subset_structure(caps: [*c]const GstCaps, structure: [*c]const GstStructure) gboolean;
pub extern fn gst_caps_is_subset_structure_full(caps: [*c]const GstCaps, structure: [*c]const GstStructure, features: ?*const GstCapsFeatures) gboolean;
pub extern fn gst_caps_is_equal(caps1: [*c]const GstCaps, caps2: [*c]const GstCaps) gboolean;
pub extern fn gst_caps_is_equal_fixed(caps1: [*c]const GstCaps, caps2: [*c]const GstCaps) gboolean;
pub extern fn gst_caps_can_intersect(caps1: [*c]const GstCaps, caps2: [*c]const GstCaps) gboolean;
pub extern fn gst_caps_is_strictly_equal(caps1: [*c]const GstCaps, caps2: [*c]const GstCaps) gboolean;
pub extern fn gst_caps_intersect(caps1: [*c]GstCaps, caps2: [*c]GstCaps) [*c]GstCaps;
pub extern fn gst_caps_intersect_full(caps1: [*c]GstCaps, caps2: [*c]GstCaps, mode: GstCapsIntersectMode) [*c]GstCaps;
pub extern fn gst_caps_subtract(minuend: [*c]GstCaps, subtrahend: [*c]GstCaps) [*c]GstCaps;
pub extern fn gst_caps_normalize(caps: [*c]GstCaps) [*c]GstCaps;
pub extern fn gst_caps_simplify(caps: [*c]GstCaps) [*c]GstCaps;
pub extern fn gst_caps_fixate(caps: [*c]GstCaps) [*c]GstCaps;
pub extern fn gst_caps_to_string(caps: [*c]const GstCaps) [*c]gchar;
pub extern fn gst_caps_serialize(caps: [*c]const GstCaps, flags: GstSerializeFlags) [*c]gchar;
pub extern fn gst_caps_from_string(string: [*c]const gchar) [*c]GstCaps;
pub const GstCaps_autoptr = [*c]GstCaps;
pub const GstCaps_listautoptr = [*c]GList;
pub const GstCaps_slistautoptr = [*c]GSList;
pub const GstCaps_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstCaps(arg__ptr: [*c]GstCaps) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_caps_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GstCaps(arg__ptr: [*c][*c]GstCaps) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstCaps(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstCaps(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_caps_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstCaps(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_caps_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstCaps(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_caps_unref)))));
    }
}
pub extern var _gst_buffer_type: GType;
pub const GstMeta = struct__GstMeta;
pub const GstMetaInitFunction = ?fn ([*c]GstMeta, gpointer, [*c]GstBuffer) callconv(.C) gboolean;
pub const GstMetaFreeFunction = ?fn ([*c]GstMeta, [*c]GstBuffer) callconv(.C) void;
pub const GstMetaTransformFunction = ?fn ([*c]GstBuffer, [*c]GstMeta, [*c]GstBuffer, GQuark, gpointer) callconv(.C) gboolean;
pub const struct__GstMetaInfo = extern struct {
    api: GType,
    type: GType,
    size: gsize,
    init_func: GstMetaInitFunction,
    free_func: GstMetaFreeFunction,
    transform_func: GstMetaTransformFunction,
};
pub const GstMetaInfo = struct__GstMetaInfo;
pub const struct__GstMeta = extern struct {
    flags: GstMetaFlags,
    info: [*c]const GstMetaInfo,
};
pub const GST_META_FLAG_NONE: c_int = 0;
pub const GST_META_FLAG_READONLY: c_int = 1;
pub const GST_META_FLAG_POOLED: c_int = 2;
pub const GST_META_FLAG_LOCKED: c_int = 4;
pub const GST_META_FLAG_LAST: c_int = 65536;
pub const GstMetaFlags = c_uint;
pub const GstCustomMeta = extern struct {
    meta: GstMeta,
};
pub extern var _gst_meta_transform_copy: GQuark;
pub const GstMetaTransformCopy = extern struct {
    region: gboolean,
    offset: gsize,
    size: gsize,
};
pub const GstCustomMetaTransformFunction = ?fn ([*c]GstBuffer, [*c]GstCustomMeta, [*c]GstBuffer, GQuark, gpointer, gpointer) callconv(.C) gboolean;
pub extern fn gst_meta_api_type_register(api: [*c]const gchar, tags: [*c][*c]const gchar) GType;
pub extern fn gst_meta_api_type_has_tag(api: GType, tag: GQuark) gboolean;
pub extern fn gst_meta_register(api: GType, impl: [*c]const gchar, size: gsize, init_func: GstMetaInitFunction, free_func: GstMetaFreeFunction, transform_func: GstMetaTransformFunction) [*c]const GstMetaInfo;
pub extern fn gst_meta_register_custom(name: [*c]const gchar, tags: [*c][*c]const gchar, transform_func: GstCustomMetaTransformFunction, user_data: gpointer, destroy_data: GDestroyNotify) [*c]const GstMetaInfo;
pub extern fn gst_meta_info_is_custom(info: [*c]const GstMetaInfo) gboolean;
pub extern fn gst_custom_meta_get_structure(meta: [*c]GstCustomMeta) [*c]GstStructure;
pub extern fn gst_custom_meta_has_name(meta: [*c]GstCustomMeta, name: [*c]const gchar) gboolean;
pub extern fn gst_meta_get_info(impl: [*c]const gchar) [*c]const GstMetaInfo;
pub extern fn gst_meta_api_type_get_tags(api: GType) [*c]const [*c]const gchar;
pub extern fn gst_meta_get_seqnum(meta: [*c]const GstMeta) guint64;
pub extern fn gst_meta_compare_seqnum(meta1: [*c]const GstMeta, meta2: [*c]const GstMeta) gint;
pub extern var _gst_meta_tag_memory: GQuark;
pub const GST_BUFFER_FLAG_LIVE: c_int = 16;
pub const GST_BUFFER_FLAG_DECODE_ONLY: c_int = 32;
pub const GST_BUFFER_FLAG_DISCONT: c_int = 64;
pub const GST_BUFFER_FLAG_RESYNC: c_int = 128;
pub const GST_BUFFER_FLAG_CORRUPTED: c_int = 256;
pub const GST_BUFFER_FLAG_MARKER: c_int = 512;
pub const GST_BUFFER_FLAG_HEADER: c_int = 1024;
pub const GST_BUFFER_FLAG_GAP: c_int = 2048;
pub const GST_BUFFER_FLAG_DROPPABLE: c_int = 4096;
pub const GST_BUFFER_FLAG_DELTA_UNIT: c_int = 8192;
pub const GST_BUFFER_FLAG_TAG_MEMORY: c_int = 16384;
pub const GST_BUFFER_FLAG_SYNC_AFTER: c_int = 32768;
pub const GST_BUFFER_FLAG_NON_DROPPABLE: c_int = 65536;
pub const GST_BUFFER_FLAG_LAST: c_int = 1048576;
pub const GstBufferFlags = c_uint;
pub extern fn gst_buffer_get_type() GType;
pub extern fn gst_buffer_get_max_memory() guint;
pub extern fn gst_buffer_new() [*c]GstBuffer;
pub extern fn gst_buffer_new_allocate(allocator: [*c]GstAllocator, size: gsize, params: [*c]GstAllocationParams) [*c]GstBuffer;
pub extern fn gst_buffer_new_wrapped_full(flags: GstMemoryFlags, data: gpointer, maxsize: gsize, offset: gsize, size: gsize, user_data: gpointer, notify: GDestroyNotify) [*c]GstBuffer;
pub extern fn gst_buffer_new_wrapped(data: gpointer, size: gsize) [*c]GstBuffer;
pub extern fn gst_buffer_new_wrapped_bytes(bytes: ?*GBytes) [*c]GstBuffer;
pub extern fn gst_buffer_new_memdup(data: gconstpointer, size: gsize) [*c]GstBuffer;
pub extern fn gst_buffer_n_memory(buffer: [*c]GstBuffer) guint;
pub extern fn gst_buffer_insert_memory(buffer: [*c]GstBuffer, idx: gint, mem: [*c]GstMemory) void;
pub extern fn gst_buffer_replace_memory_range(buffer: [*c]GstBuffer, idx: guint, length: gint, mem: [*c]GstMemory) void;
pub extern fn gst_buffer_peek_memory(buffer: [*c]GstBuffer, idx: guint) [*c]GstMemory;
pub extern fn gst_buffer_get_memory_range(buffer: [*c]GstBuffer, idx: guint, length: gint) [*c]GstMemory;
pub extern fn gst_buffer_remove_memory_range(buffer: [*c]GstBuffer, idx: guint, length: gint) void;
pub extern fn gst_buffer_prepend_memory(buffer: [*c]GstBuffer, mem: [*c]GstMemory) void;
pub extern fn gst_buffer_append_memory(buffer: [*c]GstBuffer, mem: [*c]GstMemory) void;
pub extern fn gst_buffer_replace_memory(buffer: [*c]GstBuffer, idx: guint, mem: [*c]GstMemory) void;
pub extern fn gst_buffer_replace_all_memory(buffer: [*c]GstBuffer, mem: [*c]GstMemory) void;
pub extern fn gst_buffer_get_memory(buffer: [*c]GstBuffer, idx: guint) [*c]GstMemory;
pub extern fn gst_buffer_get_all_memory(buffer: [*c]GstBuffer) [*c]GstMemory;
pub extern fn gst_buffer_remove_memory(buffer: [*c]GstBuffer, idx: guint) void;
pub extern fn gst_buffer_remove_all_memory(buffer: [*c]GstBuffer) void;
pub extern fn gst_buffer_find_memory(buffer: [*c]GstBuffer, offset: gsize, size: gsize, idx: [*c]guint, length: [*c]guint, skip: [*c]gsize) gboolean;
pub extern fn gst_buffer_is_memory_range_writable(buffer: [*c]GstBuffer, idx: guint, length: gint) gboolean;
pub extern fn gst_buffer_is_all_memory_writable(buffer: [*c]GstBuffer) gboolean;
pub extern fn gst_buffer_fill(buffer: [*c]GstBuffer, offset: gsize, src: gconstpointer, size: gsize) gsize;
pub extern fn gst_buffer_extract(buffer: [*c]GstBuffer, offset: gsize, dest: gpointer, size: gsize) gsize;
pub extern fn gst_buffer_memcmp(buffer: [*c]GstBuffer, offset: gsize, mem: gconstpointer, size: gsize) gint;
pub extern fn gst_buffer_memset(buffer: [*c]GstBuffer, offset: gsize, val: guint8, size: gsize) gsize;
pub extern fn gst_buffer_get_sizes_range(buffer: [*c]GstBuffer, idx: guint, length: gint, offset: [*c]gsize, maxsize: [*c]gsize) gsize;
pub extern fn gst_buffer_resize_range(buffer: [*c]GstBuffer, idx: guint, length: gint, offset: gssize, size: gssize) gboolean;
pub extern fn gst_buffer_get_sizes(buffer: [*c]GstBuffer, offset: [*c]gsize, maxsize: [*c]gsize) gsize;
pub extern fn gst_buffer_get_size(buffer: [*c]GstBuffer) gsize;
pub extern fn gst_buffer_resize(buffer: [*c]GstBuffer, offset: gssize, size: gssize) void;
pub extern fn gst_buffer_set_size(buffer: [*c]GstBuffer, size: gssize) void;
pub extern fn gst_buffer_map_range(buffer: [*c]GstBuffer, idx: guint, length: gint, info: [*c]GstMapInfo, flags: GstMapFlags) gboolean;
pub extern fn gst_buffer_map(buffer: [*c]GstBuffer, info: [*c]GstMapInfo, flags: GstMapFlags) gboolean;
pub extern fn gst_buffer_unmap(buffer: [*c]GstBuffer, info: [*c]GstMapInfo) void;
pub extern fn gst_buffer_extract_dup(buffer: [*c]GstBuffer, offset: gsize, size: gsize, dest: [*c]gpointer, dest_size: [*c]gsize) void;
pub extern fn gst_buffer_get_flags(buffer: [*c]GstBuffer) GstBufferFlags;
pub extern fn gst_buffer_has_flags(buffer: [*c]GstBuffer, flags: GstBufferFlags) gboolean;
pub extern fn gst_buffer_set_flags(buffer: [*c]GstBuffer, flags: GstBufferFlags) gboolean;
pub extern fn gst_buffer_unset_flags(buffer: [*c]GstBuffer, flags: GstBufferFlags) gboolean;
pub fn gst_buffer_ref(arg_buf: [*c]GstBuffer) callconv(.C) [*c]GstBuffer {
    var buf = arg_buf;
    return @ptrCast([*c]GstBuffer, @alignCast(@import("std").meta.alignment([*c]GstBuffer), gst_mini_object_ref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), buf)))));
}
pub fn gst_buffer_unref(arg_buf: [*c]GstBuffer) callconv(.C) void {
    var buf = arg_buf;
    gst_mini_object_unref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), buf)));
} // /usr/include/glib-2.0/glib/gmacros.h:820:31: warning: ignoring StaticAssert declaration
// /usr/include/glib-2.0/glib/gmem.h:133:9: warning: unsupported bool expression type
// /usr/include/gstreamer-1.0/gst/gstbuffer.h:448:1: warning: unable to translate function, demoted to extern
pub extern fn gst_clear_buffer(arg_buf_ptr: [*c][*c]GstBuffer) callconv(.C) void;
pub fn gst_buffer_copy(arg_buf: [*c]const GstBuffer) callconv(.C) [*c]GstBuffer {
    var buf = arg_buf;
    return @ptrCast([*c]GstBuffer, @alignCast(@import("std").meta.alignment([*c]GstBuffer), gst_mini_object_copy(@ptrCast([*c]const GstMiniObject, @alignCast(@import("std").meta.alignment([*c]const GstMiniObject), buf)))));
}
pub extern fn gst_buffer_copy_deep(buf: [*c]const GstBuffer) [*c]GstBuffer;
pub const GST_BUFFER_COPY_NONE: c_int = 0;
pub const GST_BUFFER_COPY_FLAGS: c_int = 1;
pub const GST_BUFFER_COPY_TIMESTAMPS: c_int = 2;
pub const GST_BUFFER_COPY_META: c_int = 4;
pub const GST_BUFFER_COPY_MEMORY: c_int = 8;
pub const GST_BUFFER_COPY_MERGE: c_int = 16;
pub const GST_BUFFER_COPY_DEEP: c_int = 32;
pub const GstBufferCopyFlags = c_uint;
pub extern fn gst_buffer_copy_into(dest: [*c]GstBuffer, src: [*c]GstBuffer, flags: GstBufferCopyFlags, offset: gsize, size: gsize) gboolean;
pub fn gst_buffer_replace(arg_obuf: [*c][*c]GstBuffer, arg_nbuf: [*c]GstBuffer) callconv(.C) gboolean {
    var obuf = arg_obuf;
    var nbuf = arg_nbuf;
    return gst_mini_object_replace(@ptrCast([*c][*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c][*c]GstMiniObject), obuf)), @ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), nbuf)));
}
pub extern fn gst_buffer_copy_region(parent: [*c]GstBuffer, flags: GstBufferCopyFlags, offset: gsize, size: gsize) [*c]GstBuffer;
pub extern fn gst_buffer_append_region(buf1: [*c]GstBuffer, buf2: [*c]GstBuffer, offset: gssize, size: gssize) [*c]GstBuffer;
pub extern fn gst_buffer_append(buf1: [*c]GstBuffer, buf2: [*c]GstBuffer) [*c]GstBuffer;
pub const GstBufferForeachMetaFunc = ?fn ([*c]GstBuffer, [*c][*c]GstMeta, gpointer) callconv(.C) gboolean;
pub extern fn gst_buffer_get_meta(buffer: [*c]GstBuffer, api: GType) [*c]GstMeta;
pub extern fn gst_buffer_get_n_meta(buffer: [*c]GstBuffer, api_type: GType) guint;
pub extern fn gst_buffer_add_meta(buffer: [*c]GstBuffer, info: [*c]const GstMetaInfo, params: gpointer) [*c]GstMeta;
pub extern fn gst_buffer_remove_meta(buffer: [*c]GstBuffer, meta: [*c]GstMeta) gboolean;
pub extern fn gst_buffer_iterate_meta(buffer: [*c]GstBuffer, state: [*c]gpointer) [*c]GstMeta;
pub extern fn gst_buffer_iterate_meta_filtered(buffer: [*c]GstBuffer, state: [*c]gpointer, meta_api_type: GType) [*c]GstMeta;
pub extern fn gst_buffer_foreach_meta(buffer: [*c]GstBuffer, func: GstBufferForeachMetaFunc, user_data: gpointer) gboolean;
pub extern fn gst_buffer_add_custom_meta(buffer: [*c]GstBuffer, name: [*c]const gchar) [*c]GstCustomMeta;
pub extern fn gst_buffer_get_custom_meta(buffer: [*c]GstBuffer, name: [*c]const gchar) [*c]GstCustomMeta;
pub const struct__GstParentBufferMeta = extern struct {
    parent: GstMeta,
    buffer: [*c]GstBuffer,
};
pub const GstParentBufferMeta = struct__GstParentBufferMeta;
pub extern fn gst_parent_buffer_meta_api_get_type() GType;
pub extern fn gst_parent_buffer_meta_get_info() [*c]const GstMetaInfo;
pub extern fn gst_buffer_add_parent_buffer_meta(buffer: [*c]GstBuffer, ref: [*c]GstBuffer) [*c]GstParentBufferMeta;
pub const struct__GstReferenceTimestampMeta = extern struct {
    parent: GstMeta,
    reference: [*c]GstCaps,
    timestamp: GstClockTime,
    duration: GstClockTime,
};
pub const GstReferenceTimestampMeta = struct__GstReferenceTimestampMeta;
pub extern fn gst_reference_timestamp_meta_api_get_type() GType;
pub extern fn gst_reference_timestamp_meta_get_info() [*c]const GstMetaInfo;
pub extern fn gst_buffer_add_reference_timestamp_meta(buffer: [*c]GstBuffer, reference: [*c]GstCaps, timestamp: GstClockTime, duration: GstClockTime) [*c]GstReferenceTimestampMeta;
pub extern fn gst_buffer_get_reference_timestamp_meta(buffer: [*c]GstBuffer, reference: [*c]GstCaps) [*c]GstReferenceTimestampMeta;
pub const GstBuffer_autoptr = [*c]GstBuffer;
pub const GstBuffer_listautoptr = [*c]GList;
pub const GstBuffer_slistautoptr = [*c]GSList;
pub const GstBuffer_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstBuffer(arg__ptr: [*c]GstBuffer) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_buffer_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GstBuffer(arg__ptr: [*c][*c]GstBuffer) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstBuffer(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstBuffer(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_buffer_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstBuffer(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_buffer_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstBuffer(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_buffer_unref)))));
    }
}
pub const GstBufferPool_autoptr = [*c]GstBufferPool;
pub const GstBufferPool_listautoptr = [*c]GList;
pub const GstBufferPool_slistautoptr = [*c]GSList;
pub const GstBufferPool_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstBufferPool(arg__ptr: [*c]GstBufferPool) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstBufferPool(arg__ptr: [*c][*c]GstBufferPool) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstBufferPool(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstBufferPool(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstBufferPool(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstBufferPool(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub extern var _gst_buffer_list_type: GType;
pub const GstBufferListFunc = ?fn ([*c][*c]GstBuffer, guint, gpointer) callconv(.C) gboolean;
pub fn gst_buffer_list_ref(arg_list: ?*GstBufferList) callconv(.C) ?*GstBufferList {
    var list = arg_list;
    return @ptrCast(?*GstBufferList, gst_mini_object_ref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), list))));
}
pub fn gst_buffer_list_unref(arg_list: ?*GstBufferList) callconv(.C) void {
    var list = arg_list;
    gst_mini_object_unref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), list)));
} // /usr/include/glib-2.0/glib/gmacros.h:820:31: warning: ignoring StaticAssert declaration
// /usr/include/glib-2.0/glib/gmem.h:133:9: warning: unsupported bool expression type
// /usr/include/gstreamer-1.0/gst/gstbufferlist.h:77:1: warning: unable to translate function, demoted to extern
pub extern fn gst_clear_buffer_list(arg_list_ptr: [*c]?*GstBufferList) callconv(.C) void;
pub fn gst_buffer_list_copy(arg_list: ?*const GstBufferList) callconv(.C) ?*GstBufferList {
    var list = arg_list;
    return @ptrCast(?*GstBufferList, gst_mini_object_copy(@ptrCast([*c]const GstMiniObject, @alignCast(@import("std").meta.alignment([*c]const GstMiniObject), list))));
}
pub fn gst_buffer_list_replace(arg_old_list: [*c]?*GstBufferList, arg_new_list: ?*GstBufferList) callconv(.C) gboolean {
    var old_list = arg_old_list;
    var new_list = arg_new_list;
    return gst_mini_object_replace(@ptrCast([*c][*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c][*c]GstMiniObject), old_list)), @ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), new_list)));
}
pub fn gst_buffer_list_take(arg_old_list: [*c]?*GstBufferList, arg_new_list: ?*GstBufferList) callconv(.C) gboolean {
    var old_list = arg_old_list;
    var new_list = arg_new_list;
    return gst_mini_object_take(@ptrCast([*c][*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c][*c]GstMiniObject), old_list)), @ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), new_list)));
}
pub extern fn gst_buffer_list_get_type() GType;
pub extern fn gst_buffer_list_new() ?*GstBufferList;
pub extern fn gst_buffer_list_new_sized(size: guint) ?*GstBufferList;
pub extern fn gst_buffer_list_length(list: ?*GstBufferList) guint;
pub extern fn gst_buffer_list_get(list: ?*GstBufferList, idx: guint) [*c]GstBuffer;
pub extern fn gst_buffer_list_get_writable(list: ?*GstBufferList, idx: guint) [*c]GstBuffer;
pub extern fn gst_buffer_list_insert(list: ?*GstBufferList, idx: gint, buffer: [*c]GstBuffer) void;
pub extern fn gst_buffer_list_remove(list: ?*GstBufferList, idx: guint, length: guint) void;
pub extern fn gst_buffer_list_foreach(list: ?*GstBufferList, func: GstBufferListFunc, user_data: gpointer) gboolean;
pub extern fn gst_buffer_list_copy_deep(list: ?*const GstBufferList) ?*GstBufferList;
pub extern fn gst_buffer_list_calculate_size(list: ?*GstBufferList) gsize;
pub const GstBufferList_autoptr = ?*GstBufferList;
pub const GstBufferList_listautoptr = [*c]GList;
pub const GstBufferList_slistautoptr = [*c]GSList;
pub const GstBufferList_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstBufferList(arg__ptr: ?*GstBufferList) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_buffer_list_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GstBufferList(arg__ptr: [*c]?*GstBufferList) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstBufferList(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstBufferList(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_buffer_list_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstBufferList(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_buffer_list_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstBufferList(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_buffer_list_unref)))));
    }
}
pub const struct__GstPadTemplateClass = extern struct {
    parent_class: GstObjectClass,
    pad_created: ?fn ([*c]GstPadTemplate, ?*GstPad) callconv(.C) void,
    _gst_reserved: [4]gpointer,
};
pub const GstPadTemplateClass = struct__GstPadTemplateClass;
pub const struct__GstStaticPadTemplate = extern struct {
    name_template: [*c]const gchar,
    direction: GstPadDirection,
    presence: GstPadPresence,
    static_caps: GstStaticCaps,
};
pub const GstStaticPadTemplate = struct__GstStaticPadTemplate;
pub const GST_EVENT_TYPE_UPSTREAM: c_int = 1;
pub const GST_EVENT_TYPE_DOWNSTREAM: c_int = 2;
pub const GST_EVENT_TYPE_SERIALIZED: c_int = 4;
pub const GST_EVENT_TYPE_STICKY: c_int = 8;
pub const GST_EVENT_TYPE_STICKY_MULTI: c_int = 16;
pub const GstEventTypeFlags = c_uint;
pub const GST_EVENT_UNKNOWN: c_int = 0;
pub const GST_EVENT_FLUSH_START: c_int = 2563;
pub const GST_EVENT_FLUSH_STOP: c_int = 5127;
pub const GST_EVENT_STREAM_START: c_int = 10254;
pub const GST_EVENT_CAPS: c_int = 12814;
pub const GST_EVENT_SEGMENT: c_int = 17934;
pub const GST_EVENT_STREAM_COLLECTION: c_int = 19230;
pub const GST_EVENT_TAG: c_int = 20510;
pub const GST_EVENT_BUFFERSIZE: c_int = 23054;
pub const GST_EVENT_SINK_MESSAGE: c_int = 25630;
pub const GST_EVENT_STREAM_GROUP_DONE: c_int = 26894;
pub const GST_EVENT_EOS: c_int = 28174;
pub const GST_EVENT_TOC: c_int = 30750;
pub const GST_EVENT_PROTECTION: c_int = 33310;
pub const GST_EVENT_SEGMENT_DONE: c_int = 38406;
pub const GST_EVENT_GAP: c_int = 40966;
pub const GST_EVENT_INSTANT_RATE_CHANGE: c_int = 46090;
pub const GST_EVENT_QOS: c_int = 48641;
pub const GST_EVENT_SEEK: c_int = 51201;
pub const GST_EVENT_NAVIGATION: c_int = 53761;
pub const GST_EVENT_LATENCY: c_int = 56321;
pub const GST_EVENT_STEP: c_int = 58881;
pub const GST_EVENT_RECONFIGURE: c_int = 61441;
pub const GST_EVENT_TOC_SELECT: c_int = 64001;
pub const GST_EVENT_SELECT_STREAMS: c_int = 66561;
pub const GST_EVENT_INSTANT_RATE_SYNC_TIME: c_int = 66817;
pub const GST_EVENT_CUSTOM_UPSTREAM: c_int = 69121;
pub const GST_EVENT_CUSTOM_DOWNSTREAM: c_int = 71686;
pub const GST_EVENT_CUSTOM_DOWNSTREAM_OOB: c_int = 74242;
pub const GST_EVENT_CUSTOM_DOWNSTREAM_STICKY: c_int = 76830;
pub const GST_EVENT_CUSTOM_BOTH: c_int = 79367;
pub const GST_EVENT_CUSTOM_BOTH_OOB: c_int = 81923;
pub const GstEventType = c_uint;
pub const GST_STREAM_FLAG_NONE: c_int = 0;
pub const GST_STREAM_FLAG_SPARSE: c_int = 1;
pub const GST_STREAM_FLAG_SELECT: c_int = 2;
pub const GST_STREAM_FLAG_UNSELECT: c_int = 4;
pub const GstStreamFlags = c_uint;
pub const GST_ITERATOR_DONE: c_int = 0;
pub const GST_ITERATOR_OK: c_int = 1;
pub const GST_ITERATOR_RESYNC: c_int = 2;
pub const GST_ITERATOR_ERROR: c_int = 3;
pub const GstIteratorResult = c_uint;
pub const GST_ITERATOR_ITEM_SKIP: c_int = 0;
pub const GST_ITERATOR_ITEM_PASS: c_int = 1;
pub const GST_ITERATOR_ITEM_END: c_int = 2;
pub const GstIteratorItem = c_uint;
pub const GstIteratorForeachFunction = ?fn ([*c]const GValue, gpointer) callconv(.C) void;
pub const GstIteratorFoldFunction = ?fn ([*c]const GValue, [*c]GValue, gpointer) callconv(.C) gboolean;
pub extern fn gst_iterator_get_type() GType;
pub extern fn gst_iterator_new(size: guint, @"type": GType, lock: [*c]GMutex, master_cookie: [*c]guint32, copy: GstIteratorCopyFunction, next: GstIteratorNextFunction, item: GstIteratorItemFunction, resync: GstIteratorResyncFunction, free: GstIteratorFreeFunction) [*c]GstIterator;
pub extern fn gst_iterator_new_list(@"type": GType, lock: [*c]GMutex, master_cookie: [*c]guint32, list: [*c][*c]GList, owner: [*c]GObject, item: GstIteratorItemFunction) [*c]GstIterator;
pub extern fn gst_iterator_new_single(@"type": GType, object: [*c]const GValue) [*c]GstIterator;
pub extern fn gst_iterator_copy(it: [*c]const GstIterator) [*c]GstIterator;
pub extern fn gst_iterator_next(it: [*c]GstIterator, elem: [*c]GValue) GstIteratorResult;
pub extern fn gst_iterator_resync(it: [*c]GstIterator) void;
pub extern fn gst_iterator_free(it: [*c]GstIterator) void;
pub extern fn gst_iterator_push(it: [*c]GstIterator, other: [*c]GstIterator) void;
pub extern fn gst_iterator_filter(it: [*c]GstIterator, func: GCompareFunc, user_data: [*c]const GValue) [*c]GstIterator;
pub extern fn gst_iterator_fold(it: [*c]GstIterator, func: GstIteratorFoldFunction, ret: [*c]GValue, user_data: gpointer) GstIteratorResult;
pub extern fn gst_iterator_foreach(it: [*c]GstIterator, func: GstIteratorForeachFunction, user_data: gpointer) GstIteratorResult;
pub extern fn gst_iterator_find_custom(it: [*c]GstIterator, func: GCompareFunc, elem: [*c]GValue, user_data: gpointer) gboolean;
pub const GstIterator_autoptr = [*c]GstIterator;
pub const GstIterator_listautoptr = [*c]GList;
pub const GstIterator_slistautoptr = [*c]GSList;
pub const GstIterator_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstIterator(arg__ptr: [*c]GstIterator) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_iterator_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GstIterator(arg__ptr: [*c][*c]GstIterator) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstIterator(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstIterator(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_iterator_free)))));
}
pub fn glib_slistautoptr_cleanup_GstIterator(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_iterator_free)))));
}
pub fn glib_queueautoptr_cleanup_GstIterator(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_iterator_free)))));
    }
}
pub const GST_FORMAT_UNDEFINED: c_int = 0;
pub const GST_FORMAT_DEFAULT: c_int = 1;
pub const GST_FORMAT_BYTES: c_int = 2;
pub const GST_FORMAT_TIME: c_int = 3;
pub const GST_FORMAT_BUFFERS: c_int = 4;
pub const GST_FORMAT_PERCENT: c_int = 5;
pub const GstFormat = c_uint;
pub const struct__GstFormatDefinition = extern struct {
    value: GstFormat,
    nick: [*c]const gchar,
    description: [*c]const gchar,
    quark: GQuark,
};
pub const GstFormatDefinition = struct__GstFormatDefinition;
pub extern fn gst_format_get_name(format: GstFormat) [*c]const gchar;
pub extern fn gst_format_to_quark(format: GstFormat) GQuark;
pub extern fn gst_format_register(nick: [*c]const gchar, description: [*c]const gchar) GstFormat;
pub extern fn gst_format_get_by_nick(nick: [*c]const gchar) GstFormat;
pub extern fn gst_formats_contains(formats: [*c]const GstFormat, format: GstFormat) gboolean;
pub extern fn gst_format_get_details(format: GstFormat) [*c]const GstFormatDefinition;
pub extern fn gst_format_iterate_definitions() [*c]GstIterator;
pub const struct__GstSegment = extern struct {
    flags: GstSegmentFlags,
    rate: gdouble,
    applied_rate: gdouble,
    format: GstFormat,
    base: guint64,
    offset: guint64,
    start: guint64,
    stop: guint64,
    time: guint64,
    position: guint64,
    duration: guint64,
    _gst_reserved: [4]gpointer,
};
pub const GstSegment = struct__GstSegment;
pub const GST_SEEK_TYPE_NONE: c_int = 0;
pub const GST_SEEK_TYPE_SET: c_int = 1;
pub const GST_SEEK_TYPE_END: c_int = 2;
pub const GstSeekType = c_uint;
pub const GST_SEEK_FLAG_NONE: c_int = 0;
pub const GST_SEEK_FLAG_FLUSH: c_int = 1;
pub const GST_SEEK_FLAG_ACCURATE: c_int = 2;
pub const GST_SEEK_FLAG_KEY_UNIT: c_int = 4;
pub const GST_SEEK_FLAG_SEGMENT: c_int = 8;
pub const GST_SEEK_FLAG_TRICKMODE: c_int = 16;
pub const GST_SEEK_FLAG_SKIP: c_int = 16;
pub const GST_SEEK_FLAG_SNAP_BEFORE: c_int = 32;
pub const GST_SEEK_FLAG_SNAP_AFTER: c_int = 64;
pub const GST_SEEK_FLAG_SNAP_NEAREST: c_int = 96;
pub const GST_SEEK_FLAG_TRICKMODE_KEY_UNITS: c_int = 128;
pub const GST_SEEK_FLAG_TRICKMODE_NO_AUDIO: c_int = 256;
pub const GST_SEEK_FLAG_TRICKMODE_FORWARD_PREDICTED: c_int = 512;
pub const GST_SEEK_FLAG_INSTANT_RATE_CHANGE: c_int = 1024;
pub const GstSeekFlags = c_uint;
pub const GST_SEGMENT_FLAG_NONE: c_int = 0;
pub const GST_SEGMENT_FLAG_RESET: c_int = 1;
pub const GST_SEGMENT_FLAG_TRICKMODE: c_int = 16;
pub const GST_SEGMENT_FLAG_SKIP: c_int = 16;
pub const GST_SEGMENT_FLAG_SEGMENT: c_int = 8;
pub const GST_SEGMENT_FLAG_TRICKMODE_KEY_UNITS: c_int = 128;
pub const GST_SEGMENT_FLAG_TRICKMODE_FORWARD_PREDICTED: c_int = 512;
pub const GST_SEGMENT_FLAG_TRICKMODE_NO_AUDIO: c_int = 256;
pub const GstSegmentFlags = c_uint;
pub extern fn gst_segment_get_type() GType;
pub extern fn gst_segment_new() [*c]GstSegment;
pub extern fn gst_segment_copy(segment: [*c]const GstSegment) [*c]GstSegment;
pub extern fn gst_segment_copy_into(src: [*c]const GstSegment, dest: [*c]GstSegment) void;
pub extern fn gst_segment_free(segment: [*c]GstSegment) void;
pub extern fn gst_segment_init(segment: [*c]GstSegment, format: GstFormat) void;
pub extern fn gst_segment_to_stream_time_full(segment: [*c]const GstSegment, format: GstFormat, position: guint64, stream_time: [*c]guint64) gint;
pub extern fn gst_segment_to_stream_time(segment: [*c]const GstSegment, format: GstFormat, position: guint64) guint64;
pub extern fn gst_segment_position_from_stream_time_full(segment: [*c]const GstSegment, format: GstFormat, stream_time: guint64, position: [*c]guint64) gint;
pub extern fn gst_segment_position_from_stream_time(segment: [*c]const GstSegment, format: GstFormat, stream_time: guint64) guint64;
pub extern fn gst_segment_to_running_time(segment: [*c]const GstSegment, format: GstFormat, position: guint64) guint64;
pub extern fn gst_segment_to_running_time_full(segment: [*c]const GstSegment, format: GstFormat, position: guint64, running_time: [*c]guint64) gint;
pub extern fn gst_segment_to_position(segment: [*c]const GstSegment, format: GstFormat, running_time: guint64) guint64;
pub extern fn gst_segment_position_from_running_time_full(segment: [*c]const GstSegment, format: GstFormat, running_time: guint64, position: [*c]guint64) gint;
pub extern fn gst_segment_position_from_running_time(segment: [*c]const GstSegment, format: GstFormat, running_time: guint64) guint64;
pub extern fn gst_segment_set_running_time(segment: [*c]GstSegment, format: GstFormat, running_time: guint64) gboolean;
pub extern fn gst_segment_offset_running_time(segment: [*c]GstSegment, format: GstFormat, offset: gint64) gboolean;
pub extern fn gst_segment_clip(segment: [*c]const GstSegment, format: GstFormat, start: guint64, stop: guint64, clip_start: [*c]guint64, clip_stop: [*c]guint64) gboolean;
pub extern fn gst_segment_do_seek(segment: [*c]GstSegment, rate: gdouble, format: GstFormat, flags: GstSeekFlags, start_type: GstSeekType, start: guint64, stop_type: GstSeekType, stop: guint64, update: [*c]gboolean) gboolean;
pub extern fn gst_segment_is_equal(s0: [*c]const GstSegment, s1: [*c]const GstSegment) gboolean;
pub const GstSegment_autoptr = [*c]GstSegment;
pub const GstSegment_listautoptr = [*c]GList;
pub const GstSegment_slistautoptr = [*c]GSList;
pub const GstSegment_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstSegment(arg__ptr: [*c]GstSegment) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_segment_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GstSegment(arg__ptr: [*c][*c]GstSegment) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstSegment(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstSegment(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_segment_free)))));
}
pub fn glib_slistautoptr_cleanup_GstSegment(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_segment_free)))));
}
pub fn glib_queueautoptr_cleanup_GstSegment(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_segment_free)))));
    }
}
pub extern var _gst_sample_type: GType;
pub const struct__GstSample = opaque {};
pub const GstSample = struct__GstSample;
pub extern fn gst_sample_get_type() GType;
pub extern fn gst_sample_new(buffer: [*c]GstBuffer, caps: [*c]GstCaps, segment: [*c]const GstSegment, info: [*c]GstStructure) ?*GstSample;
pub extern fn gst_sample_get_buffer(sample: ?*GstSample) [*c]GstBuffer;
pub extern fn gst_sample_get_caps(sample: ?*GstSample) [*c]GstCaps;
pub extern fn gst_sample_get_segment(sample: ?*GstSample) [*c]GstSegment;
pub extern fn gst_sample_get_info(sample: ?*GstSample) [*c]const GstStructure;
pub extern fn gst_sample_get_buffer_list(sample: ?*GstSample) ?*GstBufferList;
pub extern fn gst_sample_set_buffer_list(sample: ?*GstSample, buffer_list: ?*GstBufferList) void;
pub extern fn gst_sample_set_buffer(sample: ?*GstSample, buffer: [*c]GstBuffer) void;
pub extern fn gst_sample_set_caps(sample: ?*GstSample, caps: [*c]GstCaps) void;
pub extern fn gst_sample_set_segment(sample: ?*GstSample, segment: [*c]const GstSegment) void;
pub extern fn gst_sample_set_info(sample: ?*GstSample, info: [*c]GstStructure) gboolean;
pub fn gst_sample_ref(arg_sample: ?*GstSample) callconv(.C) ?*GstSample {
    var sample = arg_sample;
    return @ptrCast(?*GstSample, gst_mini_object_ref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), sample))));
}
pub fn gst_sample_unref(arg_sample: ?*GstSample) callconv(.C) void {
    var sample = arg_sample;
    gst_mini_object_unref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), sample)));
}
pub fn gst_sample_copy(arg_buf: ?*const GstSample) callconv(.C) ?*GstSample {
    var buf = arg_buf;
    return @ptrCast(?*GstSample, gst_mini_object_copy(@ptrCast([*c]const GstMiniObject, @alignCast(@import("std").meta.alignment([*c]const GstMiniObject), buf))));
}
pub const GstSample_autoptr = ?*GstSample;
pub const GstSample_listautoptr = [*c]GList;
pub const GstSample_slistautoptr = [*c]GSList;
pub const GstSample_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstSample(arg__ptr: ?*GstSample) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_sample_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GstSample(arg__ptr: [*c]?*GstSample) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstSample(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstSample(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_sample_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstSample(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_sample_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstSample(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_sample_unref)))));
    }
}
pub const GST_TAG_MERGE_UNDEFINED: c_int = 0;
pub const GST_TAG_MERGE_REPLACE_ALL: c_int = 1;
pub const GST_TAG_MERGE_REPLACE: c_int = 2;
pub const GST_TAG_MERGE_APPEND: c_int = 3;
pub const GST_TAG_MERGE_PREPEND: c_int = 4;
pub const GST_TAG_MERGE_KEEP: c_int = 5;
pub const GST_TAG_MERGE_KEEP_ALL: c_int = 6;
pub const GST_TAG_MERGE_COUNT: c_int = 7;
pub const GstTagMergeMode = c_uint;
pub const GST_TAG_FLAG_UNDEFINED: c_int = 0;
pub const GST_TAG_FLAG_META: c_int = 1;
pub const GST_TAG_FLAG_ENCODED: c_int = 2;
pub const GST_TAG_FLAG_DECODED: c_int = 3;
pub const GST_TAG_FLAG_COUNT: c_int = 4;
pub const GstTagFlag = c_uint;
pub const struct__GstTagList = extern struct {
    mini_object: GstMiniObject,
};
pub const GstTagList = struct__GstTagList;
pub extern var _gst_tag_list_type: GType;
pub const GstTagForeachFunc = ?fn ([*c]const GstTagList, [*c]const gchar, gpointer) callconv(.C) void;
pub const GstTagMergeFunc = ?fn ([*c]GValue, [*c]const GValue) callconv(.C) void;
pub extern fn gst_tag_list_get_type() GType;
pub extern fn gst_tag_register(name: [*c]const gchar, flag: GstTagFlag, @"type": GType, nick: [*c]const gchar, blurb: [*c]const gchar, func: GstTagMergeFunc) void;
pub extern fn gst_tag_register_static(name: [*c]const gchar, flag: GstTagFlag, @"type": GType, nick: [*c]const gchar, blurb: [*c]const gchar, func: GstTagMergeFunc) void;
pub extern fn gst_tag_merge_use_first(dest: [*c]GValue, src: [*c]const GValue) void;
pub extern fn gst_tag_merge_strings_with_comma(dest: [*c]GValue, src: [*c]const GValue) void;
pub extern fn gst_tag_exists(tag: [*c]const gchar) gboolean;
pub extern fn gst_tag_get_type(tag: [*c]const gchar) GType;
pub extern fn gst_tag_get_nick(tag: [*c]const gchar) [*c]const gchar;
pub extern fn gst_tag_get_description(tag: [*c]const gchar) [*c]const gchar;
pub extern fn gst_tag_get_flag(tag: [*c]const gchar) GstTagFlag;
pub extern fn gst_tag_is_fixed(tag: [*c]const gchar) gboolean;
pub const GST_TAG_SCOPE_STREAM: c_int = 0;
pub const GST_TAG_SCOPE_GLOBAL: c_int = 1;
pub const GstTagScope = c_uint;
pub extern fn gst_tag_list_new_empty() [*c]GstTagList;
pub extern fn gst_tag_list_new(tag: [*c]const gchar, ...) [*c]GstTagList;
pub extern fn gst_tag_list_new_valist(var_args: va_list) [*c]GstTagList;
pub extern fn gst_tag_list_set_scope(list: [*c]GstTagList, scope: GstTagScope) void;
pub extern fn gst_tag_list_get_scope(list: [*c]const GstTagList) GstTagScope;
pub extern fn gst_tag_list_to_string(list: [*c]const GstTagList) [*c]gchar;
pub extern fn gst_tag_list_new_from_string(str: [*c]const gchar) [*c]GstTagList;
pub extern fn gst_tag_list_n_tags(list: [*c]const GstTagList) gint;
pub extern fn gst_tag_list_nth_tag_name(list: [*c]const GstTagList, index: guint) [*c]const gchar;
pub extern fn gst_tag_list_is_empty(list: [*c]const GstTagList) gboolean;
pub extern fn gst_tag_list_is_equal(list1: [*c]const GstTagList, list2: [*c]const GstTagList) gboolean;
pub extern fn gst_tag_list_insert(into: [*c]GstTagList, from: [*c]const GstTagList, mode: GstTagMergeMode) void;
pub extern fn gst_tag_list_merge(list1: [*c]const GstTagList, list2: [*c]const GstTagList, mode: GstTagMergeMode) [*c]GstTagList;
pub extern fn gst_tag_list_get_tag_size(list: [*c]const GstTagList, tag: [*c]const gchar) guint;
pub extern fn gst_tag_list_add(list: [*c]GstTagList, mode: GstTagMergeMode, tag: [*c]const gchar, ...) void;
pub extern fn gst_tag_list_add_values(list: [*c]GstTagList, mode: GstTagMergeMode, tag: [*c]const gchar, ...) void;
pub extern fn gst_tag_list_add_valist(list: [*c]GstTagList, mode: GstTagMergeMode, tag: [*c]const gchar, var_args: va_list) void;
pub extern fn gst_tag_list_add_valist_values(list: [*c]GstTagList, mode: GstTagMergeMode, tag: [*c]const gchar, var_args: va_list) void;
pub extern fn gst_tag_list_add_value(list: [*c]GstTagList, mode: GstTagMergeMode, tag: [*c]const gchar, value: [*c]const GValue) void;
pub extern fn gst_tag_list_remove_tag(list: [*c]GstTagList, tag: [*c]const gchar) void;
pub extern fn gst_tag_list_foreach(list: [*c]const GstTagList, func: GstTagForeachFunc, user_data: gpointer) void;
pub extern fn gst_tag_list_get_value_index(list: [*c]const GstTagList, tag: [*c]const gchar, index: guint) [*c]const GValue;
pub extern fn gst_tag_list_copy_value(dest: [*c]GValue, list: [*c]const GstTagList, tag: [*c]const gchar) gboolean;
pub extern fn gst_tag_list_get_boolean(list: [*c]const GstTagList, tag: [*c]const gchar, value: [*c]gboolean) gboolean;
pub extern fn gst_tag_list_get_boolean_index(list: [*c]const GstTagList, tag: [*c]const gchar, index: guint, value: [*c]gboolean) gboolean;
pub extern fn gst_tag_list_get_int(list: [*c]const GstTagList, tag: [*c]const gchar, value: [*c]gint) gboolean;
pub extern fn gst_tag_list_get_int_index(list: [*c]const GstTagList, tag: [*c]const gchar, index: guint, value: [*c]gint) gboolean;
pub extern fn gst_tag_list_get_uint(list: [*c]const GstTagList, tag: [*c]const gchar, value: [*c]guint) gboolean;
pub extern fn gst_tag_list_get_uint_index(list: [*c]const GstTagList, tag: [*c]const gchar, index: guint, value: [*c]guint) gboolean;
pub extern fn gst_tag_list_get_int64(list: [*c]const GstTagList, tag: [*c]const gchar, value: [*c]gint64) gboolean;
pub extern fn gst_tag_list_get_int64_index(list: [*c]const GstTagList, tag: [*c]const gchar, index: guint, value: [*c]gint64) gboolean;
pub extern fn gst_tag_list_get_uint64(list: [*c]const GstTagList, tag: [*c]const gchar, value: [*c]guint64) gboolean;
pub extern fn gst_tag_list_get_uint64_index(list: [*c]const GstTagList, tag: [*c]const gchar, index: guint, value: [*c]guint64) gboolean;
pub extern fn gst_tag_list_get_float(list: [*c]const GstTagList, tag: [*c]const gchar, value: [*c]gfloat) gboolean;
pub extern fn gst_tag_list_get_float_index(list: [*c]const GstTagList, tag: [*c]const gchar, index: guint, value: [*c]gfloat) gboolean;
pub extern fn gst_tag_list_get_double(list: [*c]const GstTagList, tag: [*c]const gchar, value: [*c]gdouble) gboolean;
pub extern fn gst_tag_list_get_double_index(list: [*c]const GstTagList, tag: [*c]const gchar, index: guint, value: [*c]gdouble) gboolean;
pub extern fn gst_tag_list_get_string(list: [*c]const GstTagList, tag: [*c]const gchar, value: [*c][*c]gchar) gboolean;
pub extern fn gst_tag_list_get_string_index(list: [*c]const GstTagList, tag: [*c]const gchar, index: guint, value: [*c][*c]gchar) gboolean;
pub extern fn gst_tag_list_peek_string_index(list: [*c]const GstTagList, tag: [*c]const gchar, index: guint, value: [*c][*c]const gchar) gboolean;
pub extern fn gst_tag_list_get_pointer(list: [*c]const GstTagList, tag: [*c]const gchar, value: [*c]gpointer) gboolean;
pub extern fn gst_tag_list_get_pointer_index(list: [*c]const GstTagList, tag: [*c]const gchar, index: guint, value: [*c]gpointer) gboolean;
pub extern fn gst_tag_list_get_date(list: [*c]const GstTagList, tag: [*c]const gchar, value: [*c]?*GDate) gboolean;
pub extern fn gst_tag_list_get_date_index(list: [*c]const GstTagList, tag: [*c]const gchar, index: guint, value: [*c]?*GDate) gboolean;
pub extern fn gst_tag_list_get_date_time(list: [*c]const GstTagList, tag: [*c]const gchar, value: [*c]?*GstDateTime) gboolean;
pub extern fn gst_tag_list_get_date_time_index(list: [*c]const GstTagList, tag: [*c]const gchar, index: guint, value: [*c]?*GstDateTime) gboolean;
pub extern fn gst_tag_list_get_sample(list: [*c]const GstTagList, tag: [*c]const gchar, sample: [*c]?*GstSample) gboolean;
pub extern fn gst_tag_list_get_sample_index(list: [*c]const GstTagList, tag: [*c]const gchar, index: guint, sample: [*c]?*GstSample) gboolean;
pub fn gst_tag_list_ref(arg_taglist: [*c]GstTagList) callconv(.C) [*c]GstTagList {
    var taglist = arg_taglist;
    return @ptrCast([*c]GstTagList, @alignCast(@import("std").meta.alignment([*c]GstTagList), gst_mini_object_ref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), taglist)))));
}
pub fn gst_tag_list_unref(arg_taglist: [*c]GstTagList) callconv(.C) void {
    var taglist = arg_taglist;
    gst_mini_object_unref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), taglist)));
} // /usr/include/glib-2.0/glib/gmacros.h:820:31: warning: ignoring StaticAssert declaration
// /usr/include/glib-2.0/glib/gmem.h:133:9: warning: unsupported bool expression type
// /usr/include/gstreamer-1.0/gst/gsttaglist.h:417:1: warning: unable to translate function, demoted to extern
pub extern fn gst_clear_tag_list(arg_taglist_ptr: [*c][*c]GstTagList) callconv(.C) void;
pub extern fn gst_tag_list_copy(taglist: [*c]const GstTagList) [*c]GstTagList;
pub fn gst_tag_list_replace(arg_old_taglist: [*c][*c]GstTagList, arg_new_taglist: [*c]GstTagList) callconv(.C) gboolean {
    var old_taglist = arg_old_taglist;
    var new_taglist = arg_new_taglist;
    return gst_mini_object_replace(@ptrCast([*c][*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c][*c]GstMiniObject), old_taglist)), @ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), new_taglist)));
}
pub fn gst_tag_list_take(arg_old_taglist: [*c][*c]GstTagList, arg_new_taglist: [*c]GstTagList) callconv(.C) gboolean {
    var old_taglist = arg_old_taglist;
    var new_taglist = arg_new_taglist;
    return gst_mini_object_take(@ptrCast([*c][*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c][*c]GstMiniObject), old_taglist)), @ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), new_taglist)));
}
pub const GstTagList_autoptr = [*c]GstTagList;
pub const GstTagList_listautoptr = [*c]GList;
pub const GstTagList_slistautoptr = [*c]GSList;
pub const GstTagList_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstTagList(arg__ptr: [*c]GstTagList) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_tag_list_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GstTagList(arg__ptr: [*c][*c]GstTagList) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstTagList(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstTagList(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_tag_list_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstTagList(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_tag_list_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstTagList(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_tag_list_unref)))));
    }
}
pub const GST_MESSAGE_UNKNOWN: c_int = 0;
pub const GST_MESSAGE_EOS: c_int = 1;
pub const GST_MESSAGE_ERROR: c_int = 2;
pub const GST_MESSAGE_WARNING: c_int = 4;
pub const GST_MESSAGE_INFO: c_int = 8;
pub const GST_MESSAGE_TAG: c_int = 16;
pub const GST_MESSAGE_BUFFERING: c_int = 32;
pub const GST_MESSAGE_STATE_CHANGED: c_int = 64;
pub const GST_MESSAGE_STATE_DIRTY: c_int = 128;
pub const GST_MESSAGE_STEP_DONE: c_int = 256;
pub const GST_MESSAGE_CLOCK_PROVIDE: c_int = 512;
pub const GST_MESSAGE_CLOCK_LOST: c_int = 1024;
pub const GST_MESSAGE_NEW_CLOCK: c_int = 2048;
pub const GST_MESSAGE_STRUCTURE_CHANGE: c_int = 4096;
pub const GST_MESSAGE_STREAM_STATUS: c_int = 8192;
pub const GST_MESSAGE_APPLICATION: c_int = 16384;
pub const GST_MESSAGE_ELEMENT: c_int = 32768;
pub const GST_MESSAGE_SEGMENT_START: c_int = 65536;
pub const GST_MESSAGE_SEGMENT_DONE: c_int = 131072;
pub const GST_MESSAGE_DURATION_CHANGED: c_int = 262144;
pub const GST_MESSAGE_LATENCY: c_int = 524288;
pub const GST_MESSAGE_ASYNC_START: c_int = 1048576;
pub const GST_MESSAGE_ASYNC_DONE: c_int = 2097152;
pub const GST_MESSAGE_REQUEST_STATE: c_int = 4194304;
pub const GST_MESSAGE_STEP_START: c_int = 8388608;
pub const GST_MESSAGE_QOS: c_int = 16777216;
pub const GST_MESSAGE_PROGRESS: c_int = 33554432;
pub const GST_MESSAGE_TOC: c_int = 67108864;
pub const GST_MESSAGE_RESET_TIME: c_int = 134217728;
pub const GST_MESSAGE_STREAM_START: c_int = 268435456;
pub const GST_MESSAGE_NEED_CONTEXT: c_int = 536870912;
pub const GST_MESSAGE_HAVE_CONTEXT: c_int = 1073741824;
pub const GST_MESSAGE_EXTENDED: c_int = -2147483648;
pub const GST_MESSAGE_DEVICE_ADDED: c_int = -2147483647;
pub const GST_MESSAGE_DEVICE_REMOVED: c_int = -2147483646;
pub const GST_MESSAGE_PROPERTY_NOTIFY: c_int = -2147483645;
pub const GST_MESSAGE_STREAM_COLLECTION: c_int = -2147483644;
pub const GST_MESSAGE_STREAMS_SELECTED: c_int = -2147483643;
pub const GST_MESSAGE_REDIRECT: c_int = -2147483642;
pub const GST_MESSAGE_DEVICE_CHANGED: c_int = -2147483641;
pub const GST_MESSAGE_INSTANT_RATE_REQUEST: c_int = -2147483640;
pub const GST_MESSAGE_ANY: c_int = -1;
pub const GstMessageType = c_int;
pub const GST_QUERY_TYPE_UPSTREAM: c_int = 1;
pub const GST_QUERY_TYPE_DOWNSTREAM: c_int = 2;
pub const GST_QUERY_TYPE_SERIALIZED: c_int = 4;
pub const GstQueryTypeFlags = c_uint;
pub const GST_QUERY_UNKNOWN: c_int = 0;
pub const GST_QUERY_POSITION: c_int = 2563;
pub const GST_QUERY_DURATION: c_int = 5123;
pub const GST_QUERY_LATENCY: c_int = 7683;
pub const GST_QUERY_JITTER: c_int = 10243;
pub const GST_QUERY_RATE: c_int = 12803;
pub const GST_QUERY_SEEKING: c_int = 15363;
pub const GST_QUERY_SEGMENT: c_int = 17923;
pub const GST_QUERY_CONVERT: c_int = 20483;
pub const GST_QUERY_FORMATS: c_int = 23043;
pub const GST_QUERY_BUFFERING: c_int = 28163;
pub const GST_QUERY_CUSTOM: c_int = 30723;
pub const GST_QUERY_URI: c_int = 33283;
pub const GST_QUERY_ALLOCATION: c_int = 35846;
pub const GST_QUERY_SCHEDULING: c_int = 38401;
pub const GST_QUERY_ACCEPT_CAPS: c_int = 40963;
pub const GST_QUERY_CAPS: c_int = 43523;
pub const GST_QUERY_DRAIN: c_int = 46086;
pub const GST_QUERY_CONTEXT: c_int = 48643;
pub const GST_QUERY_BITRATE: c_int = 51202;
pub const GstQueryType = c_uint;
pub extern var _gst_query_type: GType;
pub const GST_BUFFERING_STREAM: c_int = 0;
pub const GST_BUFFERING_DOWNLOAD: c_int = 1;
pub const GST_BUFFERING_TIMESHIFT: c_int = 2;
pub const GST_BUFFERING_LIVE: c_int = 3;
pub const GstBufferingMode = c_uint;
pub extern var _gst_toc_type: GType;
pub extern var _gst_toc_entry_type: GType;
pub const struct__GstTocEntry = opaque {};
pub const GstTocEntry = struct__GstTocEntry;
pub const struct__GstToc = opaque {};
pub const GstToc = struct__GstToc;
pub const GST_TOC_SCOPE_GLOBAL: c_int = 1;
pub const GST_TOC_SCOPE_CURRENT: c_int = 2;
pub const GstTocScope = c_uint;
pub const GST_TOC_ENTRY_TYPE_ANGLE: c_int = -3;
pub const GST_TOC_ENTRY_TYPE_VERSION: c_int = -2;
pub const GST_TOC_ENTRY_TYPE_EDITION: c_int = -1;
pub const GST_TOC_ENTRY_TYPE_INVALID: c_int = 0;
pub const GST_TOC_ENTRY_TYPE_TITLE: c_int = 1;
pub const GST_TOC_ENTRY_TYPE_TRACK: c_int = 2;
pub const GST_TOC_ENTRY_TYPE_CHAPTER: c_int = 3;
pub const GstTocEntryType = c_int;
pub const GST_TOC_LOOP_NONE: c_int = 0;
pub const GST_TOC_LOOP_FORWARD: c_int = 1;
pub const GST_TOC_LOOP_REVERSE: c_int = 2;
pub const GST_TOC_LOOP_PING_PONG: c_int = 3;
pub const GstTocLoopType = c_uint;
pub extern fn gst_toc_get_type() GType;
pub extern fn gst_toc_entry_get_type() GType;
pub extern fn gst_toc_new(scope: GstTocScope) ?*GstToc;
pub extern fn gst_toc_get_scope(toc: ?*const GstToc) GstTocScope;
pub extern fn gst_toc_set_tags(toc: ?*GstToc, tags: [*c]GstTagList) void;
pub extern fn gst_toc_merge_tags(toc: ?*GstToc, tags: [*c]GstTagList, mode: GstTagMergeMode) void;
pub extern fn gst_toc_get_tags(toc: ?*const GstToc) [*c]GstTagList;
pub extern fn gst_toc_append_entry(toc: ?*GstToc, entry: ?*GstTocEntry) void;
pub extern fn gst_toc_get_entries(toc: ?*const GstToc) [*c]GList;
pub extern fn gst_toc_dump(toc: ?*GstToc) void;
pub extern fn gst_toc_entry_new(@"type": GstTocEntryType, uid: [*c]const gchar) ?*GstTocEntry;
pub extern fn gst_toc_find_entry(toc: ?*const GstToc, uid: [*c]const gchar) ?*GstTocEntry;
pub extern fn gst_toc_entry_get_entry_type(entry: ?*const GstTocEntry) GstTocEntryType;
pub extern fn gst_toc_entry_get_uid(entry: ?*const GstTocEntry) [*c]const gchar;
pub extern fn gst_toc_entry_append_sub_entry(entry: ?*GstTocEntry, subentry: ?*GstTocEntry) void;
pub extern fn gst_toc_entry_get_sub_entries(entry: ?*const GstTocEntry) [*c]GList;
pub extern fn gst_toc_entry_set_tags(entry: ?*GstTocEntry, tags: [*c]GstTagList) void;
pub extern fn gst_toc_entry_merge_tags(entry: ?*GstTocEntry, tags: [*c]GstTagList, mode: GstTagMergeMode) void;
pub extern fn gst_toc_entry_get_tags(entry: ?*const GstTocEntry) [*c]GstTagList;
pub extern fn gst_toc_entry_is_alternative(entry: ?*const GstTocEntry) gboolean;
pub extern fn gst_toc_entry_is_sequence(entry: ?*const GstTocEntry) gboolean;
pub extern fn gst_toc_entry_set_start_stop_times(entry: ?*GstTocEntry, start: gint64, stop: gint64) void;
pub extern fn gst_toc_entry_get_start_stop_times(entry: ?*const GstTocEntry, start: [*c]gint64, stop: [*c]gint64) gboolean;
pub extern fn gst_toc_entry_set_loop(entry: ?*GstTocEntry, loop_type: GstTocLoopType, repeat_count: gint) void;
pub extern fn gst_toc_entry_get_loop(entry: ?*const GstTocEntry, loop_type: [*c]GstTocLoopType, repeat_count: [*c]gint) gboolean;
pub extern fn gst_toc_entry_get_toc(entry: ?*GstTocEntry) ?*GstToc;
pub extern fn gst_toc_entry_get_parent(entry: ?*GstTocEntry) ?*GstTocEntry;
pub extern fn gst_toc_entry_type_get_nick(@"type": GstTocEntryType) [*c]const gchar;
pub fn _gst_autoptr_toc_unref(arg_toc: ?*GstToc) callconv(.C) void {
    var toc = arg_toc;
    gst_mini_object_unref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), toc)));
}
pub fn _gst_autoptr_toc_entry_unref(arg_entry: ?*GstTocEntry) callconv(.C) void {
    var entry = arg_entry;
    gst_mini_object_unref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), entry)));
}
pub const GstToc_autoptr = ?*GstToc;
pub const GstToc_listautoptr = [*c]GList;
pub const GstToc_slistautoptr = [*c]GSList;
pub const GstToc_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstToc(arg__ptr: ?*GstToc) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        _gst_autoptr_toc_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GstToc(arg__ptr: [*c]?*GstToc) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstToc(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstToc(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), _gst_autoptr_toc_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstToc(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), _gst_autoptr_toc_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstToc(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), _gst_autoptr_toc_unref)))));
    }
}
pub const GstTocEntry_autoptr = ?*GstTocEntry;
pub const GstTocEntry_listautoptr = [*c]GList;
pub const GstTocEntry_slistautoptr = [*c]GSList;
pub const GstTocEntry_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstTocEntry(arg__ptr: ?*GstTocEntry) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        _gst_autoptr_toc_entry_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GstTocEntry(arg__ptr: [*c]?*GstTocEntry) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstTocEntry(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstTocEntry(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), _gst_autoptr_toc_entry_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstTocEntry(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), _gst_autoptr_toc_entry_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstTocEntry(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), _gst_autoptr_toc_entry_unref)))));
    }
}
pub extern var _gst_context_type: GType;
pub extern fn gst_context_get_type() GType;
pub fn gst_context_ref(arg_context: ?*GstContext) callconv(.C) ?*GstContext {
    var context = arg_context;
    return @ptrCast(?*GstContext, gst_mini_object_ref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), context))));
}
pub fn gst_context_unref(arg_context: ?*GstContext) callconv(.C) void {
    var context = arg_context;
    gst_mini_object_unref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), context)));
}
pub fn gst_context_copy(arg_context: ?*const GstContext) callconv(.C) ?*GstContext {
    var context = arg_context;
    return @ptrCast(?*GstContext, gst_mini_object_copy(@ptrCast([*c]const GstMiniObject, @alignCast(@import("std").meta.alignment([*c]const GstMiniObject), context))));
}
pub fn gst_context_replace(arg_old_context: [*c]?*GstContext, arg_new_context: ?*GstContext) callconv(.C) gboolean {
    var old_context = arg_old_context;
    var new_context = arg_new_context;
    return gst_mini_object_replace(@ptrCast([*c][*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c][*c]GstMiniObject), old_context)), @ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), new_context)));
}
pub extern fn gst_context_new(context_type: [*c]const gchar, persistent: gboolean) ?*GstContext;
pub extern fn gst_context_get_context_type(context: ?*const GstContext) [*c]const gchar;
pub extern fn gst_context_has_context_type(context: ?*const GstContext, context_type: [*c]const gchar) gboolean;
pub extern fn gst_context_get_structure(context: ?*const GstContext) [*c]const GstStructure;
pub extern fn gst_context_writable_structure(context: ?*GstContext) [*c]GstStructure;
pub extern fn gst_context_is_persistent(context: ?*const GstContext) gboolean;
pub const GstContext_autoptr = ?*GstContext;
pub const GstContext_listautoptr = [*c]GList;
pub const GstContext_slistautoptr = [*c]GSList;
pub const GstContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstContext(arg__ptr: ?*GstContext) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_context_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GstContext(arg__ptr: [*c]?*GstContext) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstContext(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstContext(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_context_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstContext(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_context_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstContext(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_context_unref)))));
    }
}
pub extern fn gst_query_type_get_name(@"type": GstQueryType) [*c]const gchar;
pub extern fn gst_query_type_to_quark(@"type": GstQueryType) GQuark;
pub extern fn gst_query_type_get_flags(@"type": GstQueryType) GstQueryTypeFlags;
pub extern fn gst_query_get_type() GType;
pub fn gst_query_ref(arg_q: [*c]GstQuery) callconv(.C) [*c]GstQuery {
    var q = arg_q;
    return @ptrCast([*c]GstQuery, @alignCast(@import("std").meta.alignment([*c]GstQuery), gst_mini_object_ref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), q)))));
}
pub fn gst_query_unref(arg_q: [*c]GstQuery) callconv(.C) void {
    var q = arg_q;
    gst_mini_object_unref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), q)));
} // /usr/include/glib-2.0/glib/gmacros.h:820:31: warning: ignoring StaticAssert declaration
// /usr/include/glib-2.0/glib/gmem.h:133:9: warning: unsupported bool expression type
// /usr/include/gstreamer-1.0/gst/gstquery.h:246:1: warning: unable to translate function, demoted to extern
pub extern fn gst_clear_query(arg_query_ptr: [*c][*c]GstQuery) callconv(.C) void;
pub fn gst_query_copy(arg_q: [*c]const GstQuery) callconv(.C) [*c]GstQuery {
    var q = arg_q;
    return @ptrCast([*c]GstQuery, @alignCast(@import("std").meta.alignment([*c]GstQuery), gst_mini_object_copy(@ptrCast([*c]const GstMiniObject, @alignCast(@import("std").meta.alignment([*c]const GstMiniObject), q)))));
}
pub fn gst_query_replace(arg_old_query: [*c][*c]GstQuery, arg_new_query: [*c]GstQuery) callconv(.C) gboolean {
    var old_query = arg_old_query;
    var new_query = arg_new_query;
    return gst_mini_object_replace(@ptrCast([*c][*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c][*c]GstMiniObject), old_query)), @ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), new_query)));
}
pub fn gst_query_take(arg_old_query: [*c][*c]GstQuery, arg_new_query: [*c]GstQuery) callconv(.C) gboolean {
    var old_query = arg_old_query;
    var new_query = arg_new_query;
    return gst_mini_object_take(@ptrCast([*c][*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c][*c]GstMiniObject), old_query)), @ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), new_query)));
}
pub extern fn gst_query_new_custom(@"type": GstQueryType, structure: [*c]GstStructure) [*c]GstQuery;
pub extern fn gst_query_get_structure(query: [*c]GstQuery) [*c]const GstStructure;
pub extern fn gst_query_writable_structure(query: [*c]GstQuery) [*c]GstStructure;
pub extern fn gst_query_new_position(format: GstFormat) [*c]GstQuery;
pub extern fn gst_query_set_position(query: [*c]GstQuery, format: GstFormat, cur: gint64) void;
pub extern fn gst_query_parse_position(query: [*c]GstQuery, format: [*c]GstFormat, cur: [*c]gint64) void;
pub extern fn gst_query_new_duration(format: GstFormat) [*c]GstQuery;
pub extern fn gst_query_set_duration(query: [*c]GstQuery, format: GstFormat, duration: gint64) void;
pub extern fn gst_query_parse_duration(query: [*c]GstQuery, format: [*c]GstFormat, duration: [*c]gint64) void;
pub extern fn gst_query_new_latency() [*c]GstQuery;
pub extern fn gst_query_set_latency(query: [*c]GstQuery, live: gboolean, min_latency: GstClockTime, max_latency: GstClockTime) void;
pub extern fn gst_query_parse_latency(query: [*c]GstQuery, live: [*c]gboolean, min_latency: [*c]GstClockTime, max_latency: [*c]GstClockTime) void;
pub extern fn gst_query_new_convert(src_format: GstFormat, value: gint64, dest_format: GstFormat) [*c]GstQuery;
pub extern fn gst_query_set_convert(query: [*c]GstQuery, src_format: GstFormat, src_value: gint64, dest_format: GstFormat, dest_value: gint64) void;
pub extern fn gst_query_parse_convert(query: [*c]GstQuery, src_format: [*c]GstFormat, src_value: [*c]gint64, dest_format: [*c]GstFormat, dest_value: [*c]gint64) void;
pub extern fn gst_query_new_segment(format: GstFormat) [*c]GstQuery;
pub extern fn gst_query_set_segment(query: [*c]GstQuery, rate: gdouble, format: GstFormat, start_value: gint64, stop_value: gint64) void;
pub extern fn gst_query_parse_segment(query: [*c]GstQuery, rate: [*c]gdouble, format: [*c]GstFormat, start_value: [*c]gint64, stop_value: [*c]gint64) void;
pub extern fn gst_query_new_seeking(format: GstFormat) [*c]GstQuery;
pub extern fn gst_query_set_seeking(query: [*c]GstQuery, format: GstFormat, seekable: gboolean, segment_start: gint64, segment_end: gint64) void;
pub extern fn gst_query_parse_seeking(query: [*c]GstQuery, format: [*c]GstFormat, seekable: [*c]gboolean, segment_start: [*c]gint64, segment_end: [*c]gint64) void;
pub extern fn gst_query_new_formats() [*c]GstQuery;
pub extern fn gst_query_set_formats(query: [*c]GstQuery, n_formats: gint, ...) void;
pub extern fn gst_query_set_formatsv(query: [*c]GstQuery, n_formats: gint, formats: [*c]const GstFormat) void;
pub extern fn gst_query_parse_n_formats(query: [*c]GstQuery, n_formats: [*c]guint) void;
pub extern fn gst_query_parse_nth_format(query: [*c]GstQuery, nth: guint, format: [*c]GstFormat) void;
pub extern fn gst_query_new_buffering(format: GstFormat) [*c]GstQuery;
pub extern fn gst_query_set_buffering_percent(query: [*c]GstQuery, busy: gboolean, percent: gint) void;
pub extern fn gst_query_parse_buffering_percent(query: [*c]GstQuery, busy: [*c]gboolean, percent: [*c]gint) void;
pub extern fn gst_query_set_buffering_stats(query: [*c]GstQuery, mode: GstBufferingMode, avg_in: gint, avg_out: gint, buffering_left: gint64) void;
pub extern fn gst_query_parse_buffering_stats(query: [*c]GstQuery, mode: [*c]GstBufferingMode, avg_in: [*c]gint, avg_out: [*c]gint, buffering_left: [*c]gint64) void;
pub extern fn gst_query_set_buffering_range(query: [*c]GstQuery, format: GstFormat, start: gint64, stop: gint64, estimated_total: gint64) void;
pub extern fn gst_query_parse_buffering_range(query: [*c]GstQuery, format: [*c]GstFormat, start: [*c]gint64, stop: [*c]gint64, estimated_total: [*c]gint64) void;
pub extern fn gst_query_add_buffering_range(query: [*c]GstQuery, start: gint64, stop: gint64) gboolean;
pub extern fn gst_query_get_n_buffering_ranges(query: [*c]GstQuery) guint;
pub extern fn gst_query_parse_nth_buffering_range(query: [*c]GstQuery, index: guint, start: [*c]gint64, stop: [*c]gint64) gboolean;
pub extern fn gst_query_new_uri() [*c]GstQuery;
pub extern fn gst_query_parse_uri(query: [*c]GstQuery, uri: [*c][*c]gchar) void;
pub extern fn gst_query_set_uri(query: [*c]GstQuery, uri: [*c]const gchar) void;
pub extern fn gst_query_parse_uri_redirection(query: [*c]GstQuery, uri: [*c][*c]gchar) void;
pub extern fn gst_query_set_uri_redirection(query: [*c]GstQuery, uri: [*c]const gchar) void;
pub extern fn gst_query_parse_uri_redirection_permanent(query: [*c]GstQuery, permanent: [*c]gboolean) void;
pub extern fn gst_query_set_uri_redirection_permanent(query: [*c]GstQuery, permanent: gboolean) void;
pub extern fn gst_query_new_allocation(caps: [*c]GstCaps, need_pool: gboolean) [*c]GstQuery;
pub extern fn gst_query_parse_allocation(query: [*c]GstQuery, caps: [*c][*c]GstCaps, need_pool: [*c]gboolean) void;
pub extern fn gst_query_add_allocation_pool(query: [*c]GstQuery, pool: [*c]GstBufferPool, size: guint, min_buffers: guint, max_buffers: guint) void;
pub extern fn gst_query_get_n_allocation_pools(query: [*c]GstQuery) guint;
pub extern fn gst_query_parse_nth_allocation_pool(query: [*c]GstQuery, index: guint, pool: [*c][*c]GstBufferPool, size: [*c]guint, min_buffers: [*c]guint, max_buffers: [*c]guint) void;
pub extern fn gst_query_set_nth_allocation_pool(query: [*c]GstQuery, index: guint, pool: [*c]GstBufferPool, size: guint, min_buffers: guint, max_buffers: guint) void;
pub extern fn gst_query_remove_nth_allocation_pool(query: [*c]GstQuery, index: guint) void;
pub extern fn gst_query_add_allocation_param(query: [*c]GstQuery, allocator: [*c]GstAllocator, params: [*c]const GstAllocationParams) void;
pub extern fn gst_query_get_n_allocation_params(query: [*c]GstQuery) guint;
pub extern fn gst_query_parse_nth_allocation_param(query: [*c]GstQuery, index: guint, allocator: [*c][*c]GstAllocator, params: [*c]GstAllocationParams) void;
pub extern fn gst_query_set_nth_allocation_param(query: [*c]GstQuery, index: guint, allocator: [*c]GstAllocator, params: [*c]const GstAllocationParams) void;
pub extern fn gst_query_remove_nth_allocation_param(query: [*c]GstQuery, index: guint) void;
pub extern fn gst_query_add_allocation_meta(query: [*c]GstQuery, api: GType, params: [*c]const GstStructure) void;
pub extern fn gst_query_get_n_allocation_metas(query: [*c]GstQuery) guint;
pub extern fn gst_query_parse_nth_allocation_meta(query: [*c]GstQuery, index: guint, params: [*c][*c]const GstStructure) GType;
pub extern fn gst_query_remove_nth_allocation_meta(query: [*c]GstQuery, index: guint) void;
pub extern fn gst_query_find_allocation_meta(query: [*c]GstQuery, api: GType, index: [*c]guint) gboolean;
pub const GST_SCHEDULING_FLAG_SEEKABLE: c_int = 1;
pub const GST_SCHEDULING_FLAG_SEQUENTIAL: c_int = 2;
pub const GST_SCHEDULING_FLAG_BANDWIDTH_LIMITED: c_int = 4;
pub const GstSchedulingFlags = c_uint;
pub extern fn gst_query_new_scheduling() [*c]GstQuery;
pub extern fn gst_query_set_scheduling(query: [*c]GstQuery, flags: GstSchedulingFlags, minsize: gint, maxsize: gint, @"align": gint) void;
pub extern fn gst_query_parse_scheduling(query: [*c]GstQuery, flags: [*c]GstSchedulingFlags, minsize: [*c]gint, maxsize: [*c]gint, @"align": [*c]gint) void;
pub extern fn gst_query_add_scheduling_mode(query: [*c]GstQuery, mode: GstPadMode) void;
pub extern fn gst_query_get_n_scheduling_modes(query: [*c]GstQuery) guint;
pub extern fn gst_query_parse_nth_scheduling_mode(query: [*c]GstQuery, index: guint) GstPadMode;
pub extern fn gst_query_has_scheduling_mode(query: [*c]GstQuery, mode: GstPadMode) gboolean;
pub extern fn gst_query_has_scheduling_mode_with_flags(query: [*c]GstQuery, mode: GstPadMode, flags: GstSchedulingFlags) gboolean;
pub extern fn gst_query_new_accept_caps(caps: [*c]GstCaps) [*c]GstQuery;
pub extern fn gst_query_parse_accept_caps(query: [*c]GstQuery, caps: [*c][*c]GstCaps) void;
pub extern fn gst_query_set_accept_caps_result(query: [*c]GstQuery, result: gboolean) void;
pub extern fn gst_query_parse_accept_caps_result(query: [*c]GstQuery, result: [*c]gboolean) void;
pub extern fn gst_query_new_caps(filter: [*c]GstCaps) [*c]GstQuery;
pub extern fn gst_query_parse_caps(query: [*c]GstQuery, filter: [*c][*c]GstCaps) void;
pub extern fn gst_query_set_caps_result(query: [*c]GstQuery, caps: [*c]GstCaps) void;
pub extern fn gst_query_parse_caps_result(query: [*c]GstQuery, caps: [*c][*c]GstCaps) void;
pub extern fn gst_query_new_drain() [*c]GstQuery;
pub extern fn gst_query_new_context(context_type: [*c]const gchar) [*c]GstQuery;
pub extern fn gst_query_parse_context_type(query: [*c]GstQuery, context_type: [*c][*c]const gchar) gboolean;
pub extern fn gst_query_set_context(query: [*c]GstQuery, context: ?*GstContext) void;
pub extern fn gst_query_parse_context(query: [*c]GstQuery, context: [*c]?*GstContext) void;
pub extern fn gst_query_new_bitrate() [*c]GstQuery;
pub extern fn gst_query_set_bitrate(query: [*c]GstQuery, nominal_bitrate: guint) void;
pub extern fn gst_query_parse_bitrate(query: [*c]GstQuery, nominal_bitrate: [*c]guint) void;
pub const GstQuery_autoptr = [*c]GstQuery;
pub const GstQuery_listautoptr = [*c]GList;
pub const GstQuery_slistautoptr = [*c]GSList;
pub const GstQuery_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstQuery(arg__ptr: [*c]GstQuery) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_query_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GstQuery(arg__ptr: [*c][*c]GstQuery) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstQuery(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstQuery(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_query_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstQuery(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_query_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstQuery(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_query_unref)))));
    }
}
pub const struct__GstDevicePrivate = opaque {};
pub const GstDevicePrivate = struct__GstDevicePrivate;
pub const struct__GstDevice = extern struct {
    parent: GstObject,
    priv: ?*GstDevicePrivate,
    _gst_reserved: [4]gpointer,
};
pub const GstDevice = struct__GstDevice;
pub const struct__GstDeviceClass = extern struct {
    parent_class: GstObjectClass,
    create_element: ?fn ([*c]GstDevice, [*c]const gchar) callconv(.C) [*c]GstElement,
    reconfigure_element: ?fn ([*c]GstDevice, [*c]GstElement) callconv(.C) gboolean,
    _gst_reserved: [4]gpointer,
};
pub const GstDeviceClass = struct__GstDeviceClass;
pub extern fn gst_device_get_type() GType;
pub extern fn gst_device_create_element(device: [*c]GstDevice, name: [*c]const gchar) [*c]GstElement;
pub extern fn gst_device_get_caps(device: [*c]GstDevice) [*c]GstCaps;
pub extern fn gst_device_get_display_name(device: [*c]GstDevice) [*c]gchar;
pub extern fn gst_device_get_device_class(device: [*c]GstDevice) [*c]gchar;
pub extern fn gst_device_get_properties(device: [*c]GstDevice) [*c]GstStructure;
pub extern fn gst_device_reconfigure_element(device: [*c]GstDevice, element: [*c]GstElement) gboolean;
pub extern fn gst_device_has_classesv(device: [*c]GstDevice, classes: [*c][*c]gchar) gboolean;
pub extern fn gst_device_has_classes(device: [*c]GstDevice, classes: [*c]const gchar) gboolean;
pub const GstDevice_autoptr = [*c]GstDevice;
pub const GstDevice_listautoptr = [*c]GList;
pub const GstDevice_slistautoptr = [*c]GSList;
pub const GstDevice_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstDevice(arg__ptr: [*c]GstDevice) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstDevice(arg__ptr: [*c][*c]GstDevice) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstDevice(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstDevice(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstDevice(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstDevice(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub const GST_STREAM_TYPE_UNKNOWN: c_int = 1;
pub const GST_STREAM_TYPE_AUDIO: c_int = 2;
pub const GST_STREAM_TYPE_VIDEO: c_int = 4;
pub const GST_STREAM_TYPE_CONTAINER: c_int = 8;
pub const GST_STREAM_TYPE_TEXT: c_int = 16;
pub const GstStreamType = c_uint;
pub const struct__GstStreamPrivate = opaque {};
pub const GstStreamPrivate = struct__GstStreamPrivate;
pub const struct__GstStream = extern struct {
    object: GstObject,
    stream_id: [*c]const gchar,
    priv: ?*GstStreamPrivate,
    _gst_reserved: [4]gpointer,
};
pub const GstStream = struct__GstStream;
pub const struct__GstStreamClass = extern struct {
    parent_class: GstObjectClass,
    _gst_reserved: [4]gpointer,
};
pub const GstStreamClass = struct__GstStreamClass;
pub extern fn gst_stream_get_type() GType;
pub extern fn gst_stream_new(stream_id: [*c]const gchar, caps: [*c]GstCaps, @"type": GstStreamType, flags: GstStreamFlags) [*c]GstStream;
pub extern fn gst_stream_get_stream_id(stream: [*c]GstStream) [*c]const gchar;
pub extern fn gst_stream_set_stream_flags(stream: [*c]GstStream, flags: GstStreamFlags) void;
pub extern fn gst_stream_get_stream_flags(stream: [*c]GstStream) GstStreamFlags;
pub extern fn gst_stream_set_stream_type(stream: [*c]GstStream, stream_type: GstStreamType) void;
pub extern fn gst_stream_get_stream_type(stream: [*c]GstStream) GstStreamType;
pub extern fn gst_stream_set_tags(stream: [*c]GstStream, tags: [*c]GstTagList) void;
pub extern fn gst_stream_get_tags(stream: [*c]GstStream) [*c]GstTagList;
pub extern fn gst_stream_set_caps(stream: [*c]GstStream, caps: [*c]GstCaps) void;
pub extern fn gst_stream_get_caps(stream: [*c]GstStream) [*c]GstCaps;
pub extern fn gst_stream_type_get_name(stype: GstStreamType) [*c]const gchar;
pub const GstStream_autoptr = [*c]GstStream;
pub const GstStream_listautoptr = [*c]GList;
pub const GstStream_slistautoptr = [*c]GSList;
pub const GstStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstStream(arg__ptr: [*c]GstStream) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstStream(arg__ptr: [*c][*c]GstStream) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstStream(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstStream(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstStream(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstStream(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub const struct__GstStreamCollectionPrivate = opaque {};
pub const GstStreamCollectionPrivate = struct__GstStreamCollectionPrivate;
pub const struct__GstStreamCollection = extern struct {
    object: GstObject,
    upstream_id: [*c]gchar,
    priv: ?*GstStreamCollectionPrivate,
    _gst_reserved: [4]gpointer,
};
pub const GstStreamCollection = struct__GstStreamCollection;
pub const struct__GstStreamCollectionClass = extern struct {
    parent_class: GstObjectClass,
    stream_notify: ?fn ([*c]GstStreamCollection, [*c]GstStream, [*c]GParamSpec) callconv(.C) void,
    _gst_reserved: [4]gpointer,
};
pub const GstStreamCollectionClass = struct__GstStreamCollectionClass;
pub extern fn gst_stream_collection_get_type() GType;
pub extern fn gst_stream_collection_new(upstream_id: [*c]const gchar) [*c]GstStreamCollection;
pub extern fn gst_stream_collection_get_upstream_id(collection: [*c]GstStreamCollection) [*c]const gchar;
pub extern fn gst_stream_collection_get_size(collection: [*c]GstStreamCollection) guint;
pub extern fn gst_stream_collection_get_stream(collection: [*c]GstStreamCollection, index: guint) [*c]GstStream;
pub extern fn gst_stream_collection_add_stream(collection: [*c]GstStreamCollection, stream: [*c]GstStream) gboolean;
pub const GstStreamCollection_autoptr = [*c]GstStreamCollection;
pub const GstStreamCollection_listautoptr = [*c]GList;
pub const GstStreamCollection_slistautoptr = [*c]GSList;
pub const GstStreamCollection_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstStreamCollection(arg__ptr: [*c]GstStreamCollection) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstStreamCollection(arg__ptr: [*c][*c]GstStreamCollection) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstStreamCollection(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstStreamCollection(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstStreamCollection(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstStreamCollection(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub extern var _gst_message_type: GType;
pub const GST_STRUCTURE_CHANGE_TYPE_PAD_LINK: c_int = 0;
pub const GST_STRUCTURE_CHANGE_TYPE_PAD_UNLINK: c_int = 1;
pub const GstStructureChangeType = c_uint;
pub const GST_STREAM_STATUS_TYPE_CREATE: c_int = 0;
pub const GST_STREAM_STATUS_TYPE_ENTER: c_int = 1;
pub const GST_STREAM_STATUS_TYPE_LEAVE: c_int = 2;
pub const GST_STREAM_STATUS_TYPE_DESTROY: c_int = 3;
pub const GST_STREAM_STATUS_TYPE_START: c_int = 8;
pub const GST_STREAM_STATUS_TYPE_PAUSE: c_int = 9;
pub const GST_STREAM_STATUS_TYPE_STOP: c_int = 10;
pub const GstStreamStatusType = c_uint;
pub const GST_PROGRESS_TYPE_START: c_int = 0;
pub const GST_PROGRESS_TYPE_CONTINUE: c_int = 1;
pub const GST_PROGRESS_TYPE_COMPLETE: c_int = 2;
pub const GST_PROGRESS_TYPE_CANCELED: c_int = 3;
pub const GST_PROGRESS_TYPE_ERROR: c_int = 4;
pub const GstProgressType = c_uint;
pub extern fn gst_message_get_type() GType;
pub extern fn gst_message_type_get_name(@"type": GstMessageType) [*c]const gchar;
pub extern fn gst_message_type_to_quark(@"type": GstMessageType) GQuark;
pub fn gst_message_ref(arg_msg: [*c]GstMessage) callconv(.C) [*c]GstMessage {
    var msg = arg_msg;
    return @ptrCast([*c]GstMessage, @alignCast(@import("std").meta.alignment([*c]GstMessage), gst_mini_object_ref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), msg)))));
}
pub fn gst_message_unref(arg_msg: [*c]GstMessage) callconv(.C) void {
    var msg = arg_msg;
    gst_mini_object_unref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), msg)));
} // /usr/include/glib-2.0/glib/gmacros.h:820:31: warning: ignoring StaticAssert declaration
// /usr/include/glib-2.0/glib/gmem.h:133:9: warning: unsupported bool expression type
// /usr/include/gstreamer-1.0/gst/gstmessage.h:378:1: warning: unable to translate function, demoted to extern
pub extern fn gst_clear_message(arg_msg_ptr: [*c][*c]GstMessage) callconv(.C) void;
pub fn gst_message_copy(arg_msg: [*c]const GstMessage) callconv(.C) [*c]GstMessage {
    var msg = arg_msg;
    return @ptrCast([*c]GstMessage, @alignCast(@import("std").meta.alignment([*c]GstMessage), gst_mini_object_copy(@ptrCast([*c]const GstMiniObject, @alignCast(@import("std").meta.alignment([*c]const GstMiniObject), msg)))));
}
pub fn gst_message_replace(arg_old_message: [*c][*c]GstMessage, arg_new_message: [*c]GstMessage) callconv(.C) gboolean {
    var old_message = arg_old_message;
    var new_message = arg_new_message;
    return gst_mini_object_replace(@ptrCast([*c][*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c][*c]GstMiniObject), old_message)), @ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), new_message)));
}
pub fn gst_message_take(arg_old_message: [*c][*c]GstMessage, arg_new_message: [*c]GstMessage) callconv(.C) gboolean {
    var old_message = arg_old_message;
    var new_message = arg_new_message;
    return gst_mini_object_take(@ptrCast([*c][*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c][*c]GstMiniObject), old_message)), @ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), new_message)));
}
pub extern fn gst_message_new_custom(@"type": GstMessageType, src: [*c]GstObject, structure: [*c]GstStructure) [*c]GstMessage;
pub extern fn gst_message_get_structure(message: [*c]GstMessage) [*c]const GstStructure;
pub extern fn gst_message_writable_structure(message: [*c]GstMessage) [*c]GstStructure;
pub extern fn gst_message_has_name(message: [*c]GstMessage, name: [*c]const gchar) gboolean;
pub extern fn gst_message_get_seqnum(message: [*c]GstMessage) guint32;
pub extern fn gst_message_set_seqnum(message: [*c]GstMessage, seqnum: guint32) void;
pub extern fn gst_message_new_eos(src: [*c]GstObject) [*c]GstMessage;
pub extern fn gst_message_new_error(src: [*c]GstObject, @"error": [*c]GError, debug: [*c]const gchar) [*c]GstMessage;
pub extern fn gst_message_new_error_with_details(src: [*c]GstObject, @"error": [*c]GError, debug: [*c]const gchar, details: [*c]GstStructure) [*c]GstMessage;
pub extern fn gst_message_parse_error(message: [*c]GstMessage, gerror: [*c][*c]GError, debug: [*c][*c]gchar) void;
pub extern fn gst_message_parse_error_details(message: [*c]GstMessage, structure: [*c][*c]const GstStructure) void;
pub extern fn gst_message_new_warning(src: [*c]GstObject, @"error": [*c]GError, debug: [*c]const gchar) [*c]GstMessage;
pub extern fn gst_message_new_warning_with_details(src: [*c]GstObject, @"error": [*c]GError, debug: [*c]const gchar, details: [*c]GstStructure) [*c]GstMessage;
pub extern fn gst_message_parse_warning(message: [*c]GstMessage, gerror: [*c][*c]GError, debug: [*c][*c]gchar) void;
pub extern fn gst_message_parse_warning_details(message: [*c]GstMessage, structure: [*c][*c]const GstStructure) void;
pub extern fn gst_message_new_info(src: [*c]GstObject, @"error": [*c]GError, debug: [*c]const gchar) [*c]GstMessage;
pub extern fn gst_message_new_info_with_details(src: [*c]GstObject, @"error": [*c]GError, debug: [*c]const gchar, details: [*c]GstStructure) [*c]GstMessage;
pub extern fn gst_message_parse_info(message: [*c]GstMessage, gerror: [*c][*c]GError, debug: [*c][*c]gchar) void;
pub extern fn gst_message_parse_info_details(message: [*c]GstMessage, structure: [*c][*c]const GstStructure) void;
pub extern fn gst_message_new_tag(src: [*c]GstObject, tag_list: [*c]GstTagList) [*c]GstMessage;
pub extern fn gst_message_parse_tag(message: [*c]GstMessage, tag_list: [*c][*c]GstTagList) void;
pub extern fn gst_message_new_buffering(src: [*c]GstObject, percent: gint) [*c]GstMessage;
pub extern fn gst_message_parse_buffering(message: [*c]GstMessage, percent: [*c]gint) void;
pub extern fn gst_message_set_buffering_stats(message: [*c]GstMessage, mode: GstBufferingMode, avg_in: gint, avg_out: gint, buffering_left: gint64) void;
pub extern fn gst_message_parse_buffering_stats(message: [*c]GstMessage, mode: [*c]GstBufferingMode, avg_in: [*c]gint, avg_out: [*c]gint, buffering_left: [*c]gint64) void;
pub extern fn gst_message_new_state_changed(src: [*c]GstObject, oldstate: GstState, newstate: GstState, pending: GstState) [*c]GstMessage;
pub extern fn gst_message_parse_state_changed(message: [*c]GstMessage, oldstate: [*c]GstState, newstate: [*c]GstState, pending: [*c]GstState) void;
pub extern fn gst_message_new_state_dirty(src: [*c]GstObject) [*c]GstMessage;
pub extern fn gst_message_new_step_done(src: [*c]GstObject, format: GstFormat, amount: guint64, rate: gdouble, flush: gboolean, intermediate: gboolean, duration: guint64, eos: gboolean) [*c]GstMessage;
pub extern fn gst_message_parse_step_done(message: [*c]GstMessage, format: [*c]GstFormat, amount: [*c]guint64, rate: [*c]gdouble, flush: [*c]gboolean, intermediate: [*c]gboolean, duration: [*c]guint64, eos: [*c]gboolean) void;
pub extern fn gst_message_new_clock_provide(src: [*c]GstObject, clock: [*c]GstClock, ready: gboolean) [*c]GstMessage;
pub extern fn gst_message_parse_clock_provide(message: [*c]GstMessage, clock: [*c][*c]GstClock, ready: [*c]gboolean) void;
pub extern fn gst_message_new_clock_lost(src: [*c]GstObject, clock: [*c]GstClock) [*c]GstMessage;
pub extern fn gst_message_parse_clock_lost(message: [*c]GstMessage, clock: [*c][*c]GstClock) void;
pub extern fn gst_message_new_new_clock(src: [*c]GstObject, clock: [*c]GstClock) [*c]GstMessage;
pub extern fn gst_message_parse_new_clock(message: [*c]GstMessage, clock: [*c][*c]GstClock) void;
pub extern fn gst_message_new_application(src: [*c]GstObject, structure: [*c]GstStructure) [*c]GstMessage;
pub extern fn gst_message_new_element(src: [*c]GstObject, structure: [*c]GstStructure) [*c]GstMessage;
pub extern fn gst_message_new_segment_start(src: [*c]GstObject, format: GstFormat, position: gint64) [*c]GstMessage;
pub extern fn gst_message_parse_segment_start(message: [*c]GstMessage, format: [*c]GstFormat, position: [*c]gint64) void;
pub extern fn gst_message_new_segment_done(src: [*c]GstObject, format: GstFormat, position: gint64) [*c]GstMessage;
pub extern fn gst_message_parse_segment_done(message: [*c]GstMessage, format: [*c]GstFormat, position: [*c]gint64) void;
pub extern fn gst_message_new_duration_changed(src: [*c]GstObject) [*c]GstMessage;
pub extern fn gst_message_new_latency(src: [*c]GstObject) [*c]GstMessage;
pub extern fn gst_message_new_async_start(src: [*c]GstObject) [*c]GstMessage;
pub extern fn gst_message_new_async_done(src: [*c]GstObject, running_time: GstClockTime) [*c]GstMessage;
pub extern fn gst_message_parse_async_done(message: [*c]GstMessage, running_time: [*c]GstClockTime) void;
pub extern fn gst_message_new_structure_change(src: [*c]GstObject, @"type": GstStructureChangeType, owner: [*c]GstElement, busy: gboolean) [*c]GstMessage;
pub extern fn gst_message_parse_structure_change(message: [*c]GstMessage, @"type": [*c]GstStructureChangeType, owner: [*c][*c]GstElement, busy: [*c]gboolean) void;
pub extern fn gst_message_new_stream_status(src: [*c]GstObject, @"type": GstStreamStatusType, owner: [*c]GstElement) [*c]GstMessage;
pub extern fn gst_message_parse_stream_status(message: [*c]GstMessage, @"type": [*c]GstStreamStatusType, owner: [*c][*c]GstElement) void;
pub extern fn gst_message_set_stream_status_object(message: [*c]GstMessage, object: [*c]const GValue) void;
pub extern fn gst_message_get_stream_status_object(message: [*c]GstMessage) [*c]const GValue;
pub extern fn gst_message_new_request_state(src: [*c]GstObject, state: GstState) [*c]GstMessage;
pub extern fn gst_message_parse_request_state(message: [*c]GstMessage, state: [*c]GstState) void;
pub extern fn gst_message_new_step_start(src: [*c]GstObject, active: gboolean, format: GstFormat, amount: guint64, rate: gdouble, flush: gboolean, intermediate: gboolean) [*c]GstMessage;
pub extern fn gst_message_parse_step_start(message: [*c]GstMessage, active: [*c]gboolean, format: [*c]GstFormat, amount: [*c]guint64, rate: [*c]gdouble, flush: [*c]gboolean, intermediate: [*c]gboolean) void;
pub extern fn gst_message_new_qos(src: [*c]GstObject, live: gboolean, running_time: guint64, stream_time: guint64, timestamp: guint64, duration: guint64) [*c]GstMessage;
pub extern fn gst_message_set_qos_values(message: [*c]GstMessage, jitter: gint64, proportion: gdouble, quality: gint) void;
pub extern fn gst_message_set_qos_stats(message: [*c]GstMessage, format: GstFormat, processed: guint64, dropped: guint64) void;
pub extern fn gst_message_parse_qos(message: [*c]GstMessage, live: [*c]gboolean, running_time: [*c]guint64, stream_time: [*c]guint64, timestamp: [*c]guint64, duration: [*c]guint64) void;
pub extern fn gst_message_parse_qos_values(message: [*c]GstMessage, jitter: [*c]gint64, proportion: [*c]gdouble, quality: [*c]gint) void;
pub extern fn gst_message_parse_qos_stats(message: [*c]GstMessage, format: [*c]GstFormat, processed: [*c]guint64, dropped: [*c]guint64) void;
pub extern fn gst_message_new_progress(src: [*c]GstObject, @"type": GstProgressType, code: [*c]const gchar, text: [*c]const gchar) [*c]GstMessage;
pub extern fn gst_message_parse_progress(message: [*c]GstMessage, @"type": [*c]GstProgressType, code: [*c][*c]gchar, text: [*c][*c]gchar) void;
pub extern fn gst_message_new_toc(src: [*c]GstObject, toc: ?*GstToc, updated: gboolean) [*c]GstMessage;
pub extern fn gst_message_parse_toc(message: [*c]GstMessage, toc: [*c]?*GstToc, updated: [*c]gboolean) void;
pub extern fn gst_message_new_reset_time(src: [*c]GstObject, running_time: GstClockTime) [*c]GstMessage;
pub extern fn gst_message_parse_reset_time(message: [*c]GstMessage, running_time: [*c]GstClockTime) void;
pub extern fn gst_message_new_stream_start(src: [*c]GstObject) [*c]GstMessage;
pub extern fn gst_message_set_group_id(message: [*c]GstMessage, group_id: guint) void;
pub extern fn gst_message_parse_group_id(message: [*c]GstMessage, group_id: [*c]guint) gboolean;
pub extern fn gst_message_new_need_context(src: [*c]GstObject, context_type: [*c]const gchar) [*c]GstMessage;
pub extern fn gst_message_parse_context_type(message: [*c]GstMessage, context_type: [*c][*c]const gchar) gboolean;
pub extern fn gst_message_new_have_context(src: [*c]GstObject, context: ?*GstContext) [*c]GstMessage;
pub extern fn gst_message_parse_have_context(message: [*c]GstMessage, context: [*c]?*GstContext) void;
pub extern fn gst_message_new_device_added(src: [*c]GstObject, device: [*c]GstDevice) [*c]GstMessage;
pub extern fn gst_message_parse_device_added(message: [*c]GstMessage, device: [*c][*c]GstDevice) void;
pub extern fn gst_message_new_device_removed(src: [*c]GstObject, device: [*c]GstDevice) [*c]GstMessage;
pub extern fn gst_message_parse_device_removed(message: [*c]GstMessage, device: [*c][*c]GstDevice) void;
pub extern fn gst_message_new_device_changed(src: [*c]GstObject, device: [*c]GstDevice, changed_device: [*c]GstDevice) [*c]GstMessage;
pub extern fn gst_message_parse_device_changed(message: [*c]GstMessage, device: [*c][*c]GstDevice, changed_device: [*c][*c]GstDevice) void;
pub extern fn gst_message_new_property_notify(src: [*c]GstObject, property_name: [*c]const gchar, val: [*c]GValue) [*c]GstMessage;
pub extern fn gst_message_parse_property_notify(message: [*c]GstMessage, object: [*c][*c]GstObject, property_name: [*c][*c]const gchar, property_value: [*c][*c]const GValue) void;
pub extern fn gst_message_new_stream_collection(src: [*c]GstObject, collection: [*c]GstStreamCollection) [*c]GstMessage;
pub extern fn gst_message_parse_stream_collection(message: [*c]GstMessage, collection: [*c][*c]GstStreamCollection) void;
pub extern fn gst_message_new_streams_selected(src: [*c]GstObject, collection: [*c]GstStreamCollection) [*c]GstMessage;
pub extern fn gst_message_streams_selected_add(message: [*c]GstMessage, stream: [*c]GstStream) void;
pub extern fn gst_message_parse_streams_selected(message: [*c]GstMessage, collection: [*c][*c]GstStreamCollection) void;
pub extern fn gst_message_streams_selected_get_size(message: [*c]GstMessage) guint;
pub extern fn gst_message_streams_selected_get_stream(message: [*c]GstMessage, idx: guint) [*c]GstStream;
pub extern fn gst_message_new_redirect(src: [*c]GstObject, location: [*c]const gchar, tag_list: [*c]GstTagList, entry_struct: [*c]const GstStructure) [*c]GstMessage;
pub extern fn gst_message_add_redirect_entry(message: [*c]GstMessage, location: [*c]const gchar, tag_list: [*c]GstTagList, entry_struct: [*c]const GstStructure) void;
pub extern fn gst_message_parse_redirect_entry(message: [*c]GstMessage, entry_index: gsize, location: [*c][*c]const gchar, tag_list: [*c][*c]GstTagList, entry_struct: [*c][*c]const GstStructure) void;
pub extern fn gst_message_get_num_redirect_entries(message: [*c]GstMessage) gsize;
pub extern fn gst_message_new_instant_rate_request(src: [*c]GstObject, rate_multiplier: gdouble) [*c]GstMessage;
pub extern fn gst_message_parse_instant_rate_request(message: [*c]GstMessage, rate_multiplier: [*c]gdouble) void;
pub const GstMessage_autoptr = [*c]GstMessage;
pub const GstMessage_listautoptr = [*c]GList;
pub const GstMessage_slistautoptr = [*c]GSList;
pub const GstMessage_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstMessage(arg__ptr: [*c]GstMessage) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_message_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GstMessage(arg__ptr: [*c][*c]GstMessage) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstMessage(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstMessage(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_message_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstMessage(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_message_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstMessage(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_message_unref)))));
    }
}
pub extern var _gst_event_type: GType;
pub fn gst_event_replace(arg_old_event: [*c][*c]GstEvent, arg_new_event: [*c]GstEvent) callconv(.C) gboolean {
    var old_event = arg_old_event;
    var new_event = arg_new_event;
    return gst_mini_object_replace(@ptrCast([*c][*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c][*c]GstMiniObject), old_event)), @ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), new_event)));
}
pub fn gst_event_steal(arg_old_event: [*c][*c]GstEvent) callconv(.C) [*c]GstEvent {
    var old_event = arg_old_event;
    return @ptrCast([*c]GstEvent, @alignCast(@import("std").meta.alignment([*c]GstEvent), gst_mini_object_steal(@ptrCast([*c][*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c][*c]GstMiniObject), old_event)))));
}
pub fn gst_event_take(arg_old_event: [*c][*c]GstEvent, arg_new_event: [*c]GstEvent) callconv(.C) gboolean {
    var old_event = arg_old_event;
    var new_event = arg_new_event;
    return gst_mini_object_take(@ptrCast([*c][*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c][*c]GstMiniObject), old_event)), @ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), new_event)));
}
pub const GST_QOS_TYPE_OVERFLOW: c_int = 0;
pub const GST_QOS_TYPE_UNDERFLOW: c_int = 1;
pub const GST_QOS_TYPE_THROTTLE: c_int = 2;
pub const GstQOSType = c_uint;
pub const GST_GAP_FLAG_MISSING_DATA: c_int = 1;
pub const GstGapFlags = c_uint;
pub extern fn gst_event_type_get_name(@"type": GstEventType) [*c]const gchar;
pub extern fn gst_event_type_to_quark(@"type": GstEventType) GQuark;
pub extern fn gst_event_type_get_flags(@"type": GstEventType) GstEventTypeFlags;
pub fn gst_event_ref(arg_event: [*c]GstEvent) callconv(.C) [*c]GstEvent {
    var event = arg_event;
    return @ptrCast([*c]GstEvent, @alignCast(@import("std").meta.alignment([*c]GstEvent), gst_mini_object_ref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), event)))));
}
pub fn gst_event_unref(arg_event: [*c]GstEvent) callconv(.C) void {
    var event = arg_event;
    gst_mini_object_unref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), event)));
} // /usr/include/glib-2.0/glib/gmacros.h:820:31: warning: ignoring StaticAssert declaration
// /usr/include/glib-2.0/glib/gmem.h:133:9: warning: unsupported bool expression type
// /usr/include/gstreamer-1.0/gst/gstevent.h:435:1: warning: unable to translate function, demoted to extern
pub extern fn gst_clear_event(arg_event_ptr: [*c][*c]GstEvent) callconv(.C) void;
pub fn gst_event_copy(arg_event: [*c]const GstEvent) callconv(.C) [*c]GstEvent {
    var event = arg_event;
    return @ptrCast([*c]GstEvent, @alignCast(@import("std").meta.alignment([*c]GstEvent), gst_mini_object_copy(@ptrCast([*c]const GstMiniObject, @alignCast(@import("std").meta.alignment([*c]const GstMiniObject), event)))));
}
pub extern fn gst_event_get_type() GType;
pub extern fn gst_event_new_custom(@"type": GstEventType, structure: [*c]GstStructure) [*c]GstEvent;
pub extern fn gst_event_get_structure(event: [*c]GstEvent) [*c]const GstStructure;
pub extern fn gst_event_writable_structure(event: [*c]GstEvent) [*c]GstStructure;
pub extern fn gst_event_has_name(event: [*c]GstEvent, name: [*c]const gchar) gboolean;
pub extern fn gst_event_has_name_id(event: [*c]GstEvent, name: GQuark) gboolean;
pub extern fn gst_event_get_seqnum(event: [*c]GstEvent) guint32;
pub extern fn gst_event_set_seqnum(event: [*c]GstEvent, seqnum: guint32) void;
pub extern fn gst_event_get_running_time_offset(event: [*c]GstEvent) gint64;
pub extern fn gst_event_set_running_time_offset(event: [*c]GstEvent, offset: gint64) void;
pub extern fn gst_event_new_stream_start(stream_id: [*c]const gchar) [*c]GstEvent;
pub extern fn gst_event_parse_stream_start(event: [*c]GstEvent, stream_id: [*c][*c]const gchar) void;
pub extern fn gst_event_set_stream(event: [*c]GstEvent, stream: [*c]GstStream) void;
pub extern fn gst_event_parse_stream(event: [*c]GstEvent, stream: [*c][*c]GstStream) void;
pub extern fn gst_event_set_stream_flags(event: [*c]GstEvent, flags: GstStreamFlags) void;
pub extern fn gst_event_parse_stream_flags(event: [*c]GstEvent, flags: [*c]GstStreamFlags) void;
pub extern fn gst_event_set_group_id(event: [*c]GstEvent, group_id: guint) void;
pub extern fn gst_event_parse_group_id(event: [*c]GstEvent, group_id: [*c]guint) gboolean;
pub extern fn gst_event_new_flush_start() [*c]GstEvent;
pub extern fn gst_event_new_flush_stop(reset_time: gboolean) [*c]GstEvent;
pub extern fn gst_event_parse_flush_stop(event: [*c]GstEvent, reset_time: [*c]gboolean) void;
pub extern fn gst_event_new_stream_collection(collection: [*c]GstStreamCollection) [*c]GstEvent;
pub extern fn gst_event_parse_stream_collection(event: [*c]GstEvent, collection: [*c][*c]GstStreamCollection) void;
pub extern fn gst_event_new_select_streams(streams: [*c]GList) [*c]GstEvent;
pub extern fn gst_event_parse_select_streams(event: [*c]GstEvent, streams: [*c][*c]GList) void;
pub extern fn gst_event_new_stream_group_done(group_id: guint) [*c]GstEvent;
pub extern fn gst_event_parse_stream_group_done(event: [*c]GstEvent, group_id: [*c]guint) void;
pub extern fn gst_event_new_eos() [*c]GstEvent;
pub extern fn gst_event_new_gap(timestamp: GstClockTime, duration: GstClockTime) [*c]GstEvent;
pub extern fn gst_event_parse_gap(event: [*c]GstEvent, timestamp: [*c]GstClockTime, duration: [*c]GstClockTime) void;
pub extern fn gst_event_set_gap_flags(event: [*c]GstEvent, flags: GstGapFlags) void;
pub extern fn gst_event_parse_gap_flags(event: [*c]GstEvent, flags: [*c]GstGapFlags) void;
pub extern fn gst_event_new_caps(caps: [*c]GstCaps) [*c]GstEvent;
pub extern fn gst_event_parse_caps(event: [*c]GstEvent, caps: [*c][*c]GstCaps) void;
pub extern fn gst_event_new_segment(segment: [*c]const GstSegment) [*c]GstEvent;
pub extern fn gst_event_parse_segment(event: [*c]GstEvent, segment: [*c][*c]const GstSegment) void;
pub extern fn gst_event_copy_segment(event: [*c]GstEvent, segment: [*c]GstSegment) void;
pub extern fn gst_event_new_tag(taglist: [*c]GstTagList) [*c]GstEvent;
pub extern fn gst_event_parse_tag(event: [*c]GstEvent, taglist: [*c][*c]GstTagList) void;
pub extern fn gst_event_new_toc(toc: ?*GstToc, updated: gboolean) [*c]GstEvent;
pub extern fn gst_event_parse_toc(event: [*c]GstEvent, toc: [*c]?*GstToc, updated: [*c]gboolean) void;
pub extern fn gst_event_new_protection(system_id: [*c]const gchar, data: [*c]GstBuffer, origin: [*c]const gchar) [*c]GstEvent;
pub extern fn gst_event_parse_protection(event: [*c]GstEvent, system_id: [*c][*c]const gchar, data: [*c][*c]GstBuffer, origin: [*c][*c]const gchar) void;
pub extern fn gst_event_new_buffer_size(format: GstFormat, minsize: gint64, maxsize: gint64, @"async": gboolean) [*c]GstEvent;
pub extern fn gst_event_parse_buffer_size(event: [*c]GstEvent, format: [*c]GstFormat, minsize: [*c]gint64, maxsize: [*c]gint64, @"async": [*c]gboolean) void;
pub extern fn gst_event_new_sink_message(name: [*c]const gchar, msg: [*c]GstMessage) [*c]GstEvent;
pub extern fn gst_event_parse_sink_message(event: [*c]GstEvent, msg: [*c][*c]GstMessage) void;
pub extern fn gst_event_new_qos(@"type": GstQOSType, proportion: gdouble, diff: GstClockTimeDiff, timestamp: GstClockTime) [*c]GstEvent;
pub extern fn gst_event_parse_qos(event: [*c]GstEvent, @"type": [*c]GstQOSType, proportion: [*c]gdouble, diff: [*c]GstClockTimeDiff, timestamp: [*c]GstClockTime) void;
pub extern fn gst_event_new_seek(rate: gdouble, format: GstFormat, flags: GstSeekFlags, start_type: GstSeekType, start: gint64, stop_type: GstSeekType, stop: gint64) [*c]GstEvent;
pub extern fn gst_event_parse_seek(event: [*c]GstEvent, rate: [*c]gdouble, format: [*c]GstFormat, flags: [*c]GstSeekFlags, start_type: [*c]GstSeekType, start: [*c]gint64, stop_type: [*c]GstSeekType, stop: [*c]gint64) void;
pub extern fn gst_event_set_seek_trickmode_interval(event: [*c]GstEvent, interval: GstClockTime) void;
pub extern fn gst_event_parse_seek_trickmode_interval(event: [*c]GstEvent, interval: [*c]GstClockTime) void;
pub extern fn gst_event_new_navigation(structure: [*c]GstStructure) [*c]GstEvent;
pub extern fn gst_event_new_latency(latency: GstClockTime) [*c]GstEvent;
pub extern fn gst_event_parse_latency(event: [*c]GstEvent, latency: [*c]GstClockTime) void;
pub extern fn gst_event_new_step(format: GstFormat, amount: guint64, rate: gdouble, flush: gboolean, intermediate: gboolean) [*c]GstEvent;
pub extern fn gst_event_parse_step(event: [*c]GstEvent, format: [*c]GstFormat, amount: [*c]guint64, rate: [*c]gdouble, flush: [*c]gboolean, intermediate: [*c]gboolean) void;
pub extern fn gst_event_new_reconfigure() [*c]GstEvent;
pub extern fn gst_event_new_toc_select(uid: [*c]const gchar) [*c]GstEvent;
pub extern fn gst_event_parse_toc_select(event: [*c]GstEvent, uid: [*c][*c]gchar) void;
pub extern fn gst_event_new_segment_done(format: GstFormat, position: gint64) [*c]GstEvent;
pub extern fn gst_event_parse_segment_done(event: [*c]GstEvent, format: [*c]GstFormat, position: [*c]gint64) void;
pub extern fn gst_event_new_instant_rate_change(rate_multiplier: gdouble, new_flags: GstSegmentFlags) [*c]GstEvent;
pub extern fn gst_event_parse_instant_rate_change(event: [*c]GstEvent, rate_multiplier: [*c]gdouble, new_flags: [*c]GstSegmentFlags) void;
pub extern fn gst_event_new_instant_rate_sync_time(rate_multiplier: gdouble, running_time: GstClockTime, upstream_running_time: GstClockTime) [*c]GstEvent;
pub extern fn gst_event_parse_instant_rate_sync_time(event: [*c]GstEvent, rate_multiplier: [*c]gdouble, running_time: [*c]GstClockTime, upstream_running_time: [*c]GstClockTime) void;
pub const GstEvent_autoptr = [*c]GstEvent;
pub const GstEvent_listautoptr = [*c]GList;
pub const GstEvent_slistautoptr = [*c]GSList;
pub const GstEvent_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstEvent(arg__ptr: [*c]GstEvent) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_event_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GstEvent(arg__ptr: [*c][*c]GstEvent) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstEvent(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstEvent(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_event_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstEvent(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_event_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstEvent(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_event_unref)))));
    }
}
pub const struct__GstTaskPool = extern struct {
    object: GstObject,
    pool: [*c]GThreadPool,
    _gst_reserved: [4]gpointer,
};
pub const GstTaskPool = struct__GstTaskPool;
pub const GstTaskPoolFunction = ?fn (?*anyopaque) callconv(.C) void;
pub const struct__GstTaskPoolClass = extern struct {
    parent_class: GstObjectClass,
    prepare: ?fn ([*c]GstTaskPool, [*c][*c]GError) callconv(.C) void,
    cleanup: ?fn ([*c]GstTaskPool) callconv(.C) void,
    push: ?fn ([*c]GstTaskPool, GstTaskPoolFunction, gpointer, [*c][*c]GError) callconv(.C) gpointer,
    join: ?fn ([*c]GstTaskPool, gpointer) callconv(.C) void,
    dispose_handle: ?fn ([*c]GstTaskPool, gpointer) callconv(.C) void,
    _gst_reserved: [3]gpointer,
};
pub const GstTaskPoolClass = struct__GstTaskPoolClass;
pub extern fn gst_task_pool_get_type() GType;
pub extern fn gst_task_pool_new() [*c]GstTaskPool;
pub extern fn gst_task_pool_prepare(pool: [*c]GstTaskPool, @"error": [*c][*c]GError) void;
pub extern fn gst_task_pool_push(pool: [*c]GstTaskPool, func: GstTaskPoolFunction, user_data: gpointer, @"error": [*c][*c]GError) gpointer;
pub extern fn gst_task_pool_join(pool: [*c]GstTaskPool, id: gpointer) void;
pub extern fn gst_task_pool_dispose_handle(pool: [*c]GstTaskPool, id: gpointer) void;
pub extern fn gst_task_pool_cleanup(pool: [*c]GstTaskPool) void;
pub const GstTaskPool_autoptr = [*c]GstTaskPool;
pub const GstTaskPool_listautoptr = [*c]GList;
pub const GstTaskPool_slistautoptr = [*c]GSList;
pub const GstTaskPool_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstTaskPool(arg__ptr: [*c]GstTaskPool) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstTaskPool(arg__ptr: [*c][*c]GstTaskPool) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstTaskPool(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstTaskPool(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstTaskPool(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstTaskPool(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub const struct__GstSharedTaskPoolPrivate = opaque {};
pub const GstSharedTaskPoolPrivate = struct__GstSharedTaskPoolPrivate;
pub const struct__GstSharedTaskPool = extern struct {
    parent: GstTaskPool,
    priv: ?*GstSharedTaskPoolPrivate,
    _gst_reserved: [4]gpointer,
};
pub const GstSharedTaskPool = struct__GstSharedTaskPool;
pub const struct__GstSharedTaskPoolClass = extern struct {
    parent_class: GstTaskPoolClass,
    _gst_reserved: [4]gpointer,
};
pub const GstSharedTaskPoolClass = struct__GstSharedTaskPoolClass;
pub extern fn gst_shared_task_pool_get_type() GType;
pub extern fn gst_shared_task_pool_set_max_threads(pool: [*c]GstSharedTaskPool, max_threads: guint) void;
pub extern fn gst_shared_task_pool_get_max_threads(pool: [*c]GstSharedTaskPool) guint;
pub extern fn gst_shared_task_pool_new() [*c]GstTaskPool;
pub const struct__GstTaskClass = extern struct {
    parent_class: GstObjectClass,
    pool: [*c]GstTaskPool,
    _gst_reserved: [4]gpointer,
};
pub const GstTaskClass = struct__GstTaskClass;
pub const GST_TASK_STARTED: c_int = 0;
pub const GST_TASK_STOPPED: c_int = 1;
pub const GST_TASK_PAUSED: c_int = 2;
pub const GstTaskState = c_uint;
pub const GstTaskThreadFunc = ?fn ([*c]GstTask, [*c]GThread, gpointer) callconv(.C) void;
pub extern fn gst_task_cleanup_all() void;
pub extern fn gst_task_get_type() GType;
pub extern fn gst_task_new(func: GstTaskFunction, user_data: gpointer, notify: GDestroyNotify) [*c]GstTask;
pub extern fn gst_task_set_lock(task: [*c]GstTask, mutex: [*c]GRecMutex) void;
pub extern fn gst_task_get_pool(task: [*c]GstTask) [*c]GstTaskPool;
pub extern fn gst_task_set_pool(task: [*c]GstTask, pool: [*c]GstTaskPool) void;
pub extern fn gst_task_set_enter_callback(task: [*c]GstTask, enter_func: GstTaskThreadFunc, user_data: gpointer, notify: GDestroyNotify) void;
pub extern fn gst_task_set_leave_callback(task: [*c]GstTask, leave_func: GstTaskThreadFunc, user_data: gpointer, notify: GDestroyNotify) void;
pub extern fn gst_task_get_state(task: [*c]GstTask) GstTaskState;
pub extern fn gst_task_set_state(task: [*c]GstTask, state: GstTaskState) gboolean;
pub extern fn gst_task_start(task: [*c]GstTask) gboolean;
pub extern fn gst_task_stop(task: [*c]GstTask) gboolean;
pub extern fn gst_task_pause(task: [*c]GstTask) gboolean;
pub extern fn gst_task_resume(task: [*c]GstTask) gboolean;
pub extern fn gst_task_join(task: [*c]GstTask) gboolean;
pub const GstTask_autoptr = [*c]GstTask;
pub const GstTask_listautoptr = [*c]GList;
pub const GstTask_slistautoptr = [*c]GSList;
pub const GstTask_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstTask(arg__ptr: [*c]GstTask) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstTask(arg__ptr: [*c][*c]GstTask) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstTask(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstTask(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstTask(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstTask(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub const GST_PAD_ALWAYS: c_int = 0;
pub const GST_PAD_SOMETIMES: c_int = 1;
pub const GST_PAD_REQUEST: c_int = 2;
pub const GstPadPresence = c_uint;
pub const GST_PAD_TEMPLATE_FLAG_LAST: c_int = 256;
pub const GstPadTemplateFlags = c_uint;
pub extern fn gst_pad_template_get_type() GType;
pub extern fn gst_static_pad_template_get_type() GType;
pub extern fn gst_pad_template_new(name_template: [*c]const gchar, direction: GstPadDirection, presence: GstPadPresence, caps: [*c]GstCaps) [*c]GstPadTemplate;
pub extern fn gst_pad_template_new_with_gtype(name_template: [*c]const gchar, direction: GstPadDirection, presence: GstPadPresence, caps: [*c]GstCaps, pad_type: GType) [*c]GstPadTemplate;
pub extern fn gst_static_pad_template_get(pad_template: [*c]GstStaticPadTemplate) [*c]GstPadTemplate;
pub extern fn gst_pad_template_new_from_static_pad_template_with_gtype(pad_template: [*c]GstStaticPadTemplate, pad_type: GType) [*c]GstPadTemplate;
pub extern fn gst_static_pad_template_get_caps(templ: [*c]GstStaticPadTemplate) [*c]GstCaps;
pub extern fn gst_pad_template_get_caps(templ: [*c]GstPadTemplate) [*c]GstCaps;
pub extern fn gst_pad_template_set_documentation_caps(templ: [*c]GstPadTemplate, caps: [*c]GstCaps) void;
pub extern fn gst_pad_template_get_documentation_caps(templ: [*c]GstPadTemplate) [*c]GstCaps;
pub extern fn gst_pad_template_pad_created(templ: [*c]GstPadTemplate, pad: ?*GstPad) void;
pub const GstPadTemplate_autoptr = [*c]GstPadTemplate;
pub const GstPadTemplate_listautoptr = [*c]GList;
pub const GstPadTemplate_slistautoptr = [*c]GSList;
pub const GstPadTemplate_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstPadTemplate(arg__ptr: [*c]GstPadTemplate) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstPadTemplate(arg__ptr: [*c][*c]GstPadTemplate) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstPadTemplate(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstPadTemplate(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstPadTemplate(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstPadTemplate(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub const GST_PAD_LINK_OK: c_int = 0;
pub const GST_PAD_LINK_WRONG_HIERARCHY: c_int = -1;
pub const GST_PAD_LINK_WAS_LINKED: c_int = -2;
pub const GST_PAD_LINK_WRONG_DIRECTION: c_int = -3;
pub const GST_PAD_LINK_NOFORMAT: c_int = -4;
pub const GST_PAD_LINK_NOSCHED: c_int = -5;
pub const GST_PAD_LINK_REFUSED: c_int = -6;
pub const GstPadLinkReturn = c_int;
pub const GST_FLOW_CUSTOM_SUCCESS_2: c_int = 102;
pub const GST_FLOW_CUSTOM_SUCCESS_1: c_int = 101;
pub const GST_FLOW_CUSTOM_SUCCESS: c_int = 100;
pub const GST_FLOW_OK: c_int = 0;
pub const GST_FLOW_NOT_LINKED: c_int = -1;
pub const GST_FLOW_FLUSHING: c_int = -2;
pub const GST_FLOW_EOS: c_int = -3;
pub const GST_FLOW_NOT_NEGOTIATED: c_int = -4;
pub const GST_FLOW_ERROR: c_int = -5;
pub const GST_FLOW_NOT_SUPPORTED: c_int = -6;
pub const GST_FLOW_CUSTOM_ERROR: c_int = -100;
pub const GST_FLOW_CUSTOM_ERROR_1: c_int = -101;
pub const GST_FLOW_CUSTOM_ERROR_2: c_int = -102;
pub const GstFlowReturn = c_int;
pub extern fn gst_flow_get_name(ret: GstFlowReturn) [*c]const gchar;
pub extern fn gst_flow_to_quark(ret: GstFlowReturn) GQuark;
pub extern fn gst_pad_link_get_name(ret: GstPadLinkReturn) [*c]const gchar;
pub const GST_PAD_LINK_CHECK_NOTHING: c_int = 0;
pub const GST_PAD_LINK_CHECK_HIERARCHY: c_int = 1;
pub const GST_PAD_LINK_CHECK_TEMPLATE_CAPS: c_int = 2;
pub const GST_PAD_LINK_CHECK_CAPS: c_int = 4;
pub const GST_PAD_LINK_CHECK_NO_RECONFIGURE: c_int = 8;
pub const GST_PAD_LINK_CHECK_DEFAULT: c_int = 5;
pub const GstPadLinkCheck = c_uint;
pub const GstPadForwardFunction = ?fn (?*GstPad, gpointer) callconv(.C) gboolean;
pub const GST_PAD_PROBE_TYPE_INVALID: c_int = 0;
pub const GST_PAD_PROBE_TYPE_IDLE: c_int = 1;
pub const GST_PAD_PROBE_TYPE_BLOCK: c_int = 2;
pub const GST_PAD_PROBE_TYPE_BUFFER: c_int = 16;
pub const GST_PAD_PROBE_TYPE_BUFFER_LIST: c_int = 32;
pub const GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM: c_int = 64;
pub const GST_PAD_PROBE_TYPE_EVENT_UPSTREAM: c_int = 128;
pub const GST_PAD_PROBE_TYPE_EVENT_FLUSH: c_int = 256;
pub const GST_PAD_PROBE_TYPE_QUERY_DOWNSTREAM: c_int = 512;
pub const GST_PAD_PROBE_TYPE_QUERY_UPSTREAM: c_int = 1024;
pub const GST_PAD_PROBE_TYPE_PUSH: c_int = 4096;
pub const GST_PAD_PROBE_TYPE_PULL: c_int = 8192;
pub const GST_PAD_PROBE_TYPE_BLOCKING: c_int = 3;
pub const GST_PAD_PROBE_TYPE_DATA_DOWNSTREAM: c_int = 112;
pub const GST_PAD_PROBE_TYPE_DATA_UPSTREAM: c_int = 128;
pub const GST_PAD_PROBE_TYPE_DATA_BOTH: c_int = 240;
pub const GST_PAD_PROBE_TYPE_BLOCK_DOWNSTREAM: c_int = 114;
pub const GST_PAD_PROBE_TYPE_BLOCK_UPSTREAM: c_int = 130;
pub const GST_PAD_PROBE_TYPE_EVENT_BOTH: c_int = 192;
pub const GST_PAD_PROBE_TYPE_QUERY_BOTH: c_int = 1536;
pub const GST_PAD_PROBE_TYPE_ALL_BOTH: c_int = 1776;
pub const GST_PAD_PROBE_TYPE_SCHEDULING: c_int = 12288;
pub const GstPadProbeType = c_uint;
pub const GST_PAD_PROBE_DROP: c_int = 0;
pub const GST_PAD_PROBE_OK: c_int = 1;
pub const GST_PAD_PROBE_REMOVE: c_int = 2;
pub const GST_PAD_PROBE_PASS: c_int = 3;
pub const GST_PAD_PROBE_HANDLED: c_int = 4;
pub const GstPadProbeReturn = c_uint;
pub extern fn gst_pad_probe_info_get_event(info: [*c]GstPadProbeInfo) [*c]GstEvent;
pub extern fn gst_pad_probe_info_get_query(info: [*c]GstPadProbeInfo) [*c]GstQuery;
pub extern fn gst_pad_probe_info_get_buffer(info: [*c]GstPadProbeInfo) [*c]GstBuffer;
pub extern fn gst_pad_probe_info_get_buffer_list(info: [*c]GstPadProbeInfo) ?*GstBufferList;
pub const GstPadProbeCallback = ?fn (?*GstPad, [*c]GstPadProbeInfo, gpointer) callconv(.C) GstPadProbeReturn;
pub const GstPadStickyEventsForeachFunction = ?fn (?*GstPad, [*c][*c]GstEvent, gpointer) callconv(.C) gboolean;
pub const GST_PAD_FLAG_BLOCKED: c_int = 16;
pub const GST_PAD_FLAG_FLUSHING: c_int = 32;
pub const GST_PAD_FLAG_EOS: c_int = 64;
pub const GST_PAD_FLAG_BLOCKING: c_int = 128;
pub const GST_PAD_FLAG_NEED_PARENT: c_int = 256;
pub const GST_PAD_FLAG_NEED_RECONFIGURE: c_int = 512;
pub const GST_PAD_FLAG_PENDING_EVENTS: c_int = 1024;
pub const GST_PAD_FLAG_FIXED_CAPS: c_int = 2048;
pub const GST_PAD_FLAG_PROXY_CAPS: c_int = 4096;
pub const GST_PAD_FLAG_PROXY_ALLOCATION: c_int = 8192;
pub const GST_PAD_FLAG_PROXY_SCHEDULING: c_int = 16384;
pub const GST_PAD_FLAG_ACCEPT_INTERSECT: c_int = 32768;
pub const GST_PAD_FLAG_ACCEPT_TEMPLATE: c_int = 65536;
pub const GST_PAD_FLAG_LAST: c_int = 1048576;
pub const GstPadFlags = c_uint;
pub extern fn gst_pad_get_type() GType;
pub extern fn gst_pad_new(name: [*c]const gchar, direction: GstPadDirection) ?*GstPad;
pub extern fn gst_pad_new_from_template(templ: [*c]GstPadTemplate, name: [*c]const gchar) ?*GstPad;
pub extern fn gst_pad_new_from_static_template(templ: [*c]GstStaticPadTemplate, name: [*c]const gchar) ?*GstPad;
pub extern fn gst_pad_get_direction(pad: ?*GstPad) GstPadDirection;
pub extern fn gst_pad_set_active(pad: ?*GstPad, active: gboolean) gboolean;
pub extern fn gst_pad_is_active(pad: ?*GstPad) gboolean;
pub extern fn gst_pad_activate_mode(pad: ?*GstPad, mode: GstPadMode, active: gboolean) gboolean;
pub extern fn gst_pad_add_probe(pad: ?*GstPad, mask: GstPadProbeType, callback: GstPadProbeCallback, user_data: gpointer, destroy_data: GDestroyNotify) gulong;
pub extern fn gst_pad_remove_probe(pad: ?*GstPad, id: gulong) void;
pub extern fn gst_pad_is_blocked(pad: ?*GstPad) gboolean;
pub extern fn gst_pad_is_blocking(pad: ?*GstPad) gboolean;
pub extern fn gst_pad_mark_reconfigure(pad: ?*GstPad) void;
pub extern fn gst_pad_needs_reconfigure(pad: ?*GstPad) gboolean;
pub extern fn gst_pad_check_reconfigure(pad: ?*GstPad) gboolean;
pub extern fn gst_pad_set_element_private(pad: ?*GstPad, priv: gpointer) void;
pub extern fn gst_pad_get_element_private(pad: ?*GstPad) gpointer;
pub extern fn gst_pad_get_pad_template(pad: ?*GstPad) [*c]GstPadTemplate;
pub extern fn gst_pad_store_sticky_event(pad: ?*GstPad, event: [*c]GstEvent) GstFlowReturn;
pub extern fn gst_pad_get_sticky_event(pad: ?*GstPad, event_type: GstEventType, idx: guint) [*c]GstEvent;
pub extern fn gst_pad_sticky_events_foreach(pad: ?*GstPad, foreach_func: GstPadStickyEventsForeachFunction, user_data: gpointer) void;
pub extern fn gst_pad_set_activate_function_full(pad: ?*GstPad, activate: GstPadActivateFunction, user_data: gpointer, notify: GDestroyNotify) void;
pub extern fn gst_pad_set_activatemode_function_full(pad: ?*GstPad, activatemode: GstPadActivateModeFunction, user_data: gpointer, notify: GDestroyNotify) void;
pub extern fn gst_pad_set_chain_function_full(pad: ?*GstPad, chain: GstPadChainFunction, user_data: gpointer, notify: GDestroyNotify) void;
pub extern fn gst_pad_set_chain_list_function_full(pad: ?*GstPad, chainlist: GstPadChainListFunction, user_data: gpointer, notify: GDestroyNotify) void;
pub extern fn gst_pad_set_getrange_function_full(pad: ?*GstPad, get: GstPadGetRangeFunction, user_data: gpointer, notify: GDestroyNotify) void;
pub extern fn gst_pad_set_event_function_full(pad: ?*GstPad, event: GstPadEventFunction, user_data: gpointer, notify: GDestroyNotify) void;
pub extern fn gst_pad_set_event_full_function_full(pad: ?*GstPad, event: GstPadEventFullFunction, user_data: gpointer, notify: GDestroyNotify) void;
pub extern fn gst_pad_set_link_function_full(pad: ?*GstPad, link: GstPadLinkFunction, user_data: gpointer, notify: GDestroyNotify) void;
pub extern fn gst_pad_set_unlink_function_full(pad: ?*GstPad, unlink: GstPadUnlinkFunction, user_data: gpointer, notify: GDestroyNotify) void;
pub extern fn gst_pad_can_link(srcpad: ?*GstPad, sinkpad: ?*GstPad) gboolean;
pub extern fn gst_pad_link(srcpad: ?*GstPad, sinkpad: ?*GstPad) GstPadLinkReturn;
pub extern fn gst_pad_link_full(srcpad: ?*GstPad, sinkpad: ?*GstPad, flags: GstPadLinkCheck) GstPadLinkReturn;
pub extern fn gst_pad_unlink(srcpad: ?*GstPad, sinkpad: ?*GstPad) gboolean;
pub extern fn gst_pad_is_linked(pad: ?*GstPad) gboolean;
pub extern fn gst_pad_get_peer(pad: ?*GstPad) ?*GstPad;
pub extern fn gst_pad_get_pad_template_caps(pad: ?*GstPad) [*c]GstCaps;
pub extern fn gst_pad_get_current_caps(pad: ?*GstPad) [*c]GstCaps;
pub extern fn gst_pad_has_current_caps(pad: ?*GstPad) gboolean;
pub extern fn gst_pad_get_allowed_caps(pad: ?*GstPad) [*c]GstCaps;
pub extern fn gst_pad_get_offset(pad: ?*GstPad) gint64;
pub extern fn gst_pad_set_offset(pad: ?*GstPad, offset: gint64) void;
pub extern fn gst_pad_push(pad: ?*GstPad, buffer: [*c]GstBuffer) GstFlowReturn;
pub extern fn gst_pad_push_list(pad: ?*GstPad, list: ?*GstBufferList) GstFlowReturn;
pub extern fn gst_pad_pull_range(pad: ?*GstPad, offset: guint64, size: guint, buffer: [*c][*c]GstBuffer) GstFlowReturn;
pub extern fn gst_pad_push_event(pad: ?*GstPad, event: [*c]GstEvent) gboolean;
pub extern fn gst_pad_event_default(pad: ?*GstPad, parent: [*c]GstObject, event: [*c]GstEvent) gboolean;
pub extern fn gst_pad_get_last_flow_return(pad: ?*GstPad) GstFlowReturn;
pub extern fn gst_pad_chain(pad: ?*GstPad, buffer: [*c]GstBuffer) GstFlowReturn;
pub extern fn gst_pad_chain_list(pad: ?*GstPad, list: ?*GstBufferList) GstFlowReturn;
pub extern fn gst_pad_get_range(pad: ?*GstPad, offset: guint64, size: guint, buffer: [*c][*c]GstBuffer) GstFlowReturn;
pub extern fn gst_pad_send_event(pad: ?*GstPad, event: [*c]GstEvent) gboolean;
pub extern fn gst_pad_start_task(pad: ?*GstPad, func: GstTaskFunction, user_data: gpointer, notify: GDestroyNotify) gboolean;
pub extern fn gst_pad_pause_task(pad: ?*GstPad) gboolean;
pub extern fn gst_pad_stop_task(pad: ?*GstPad) gboolean;
pub extern fn gst_pad_get_task_state(pad: ?*GstPad) GstTaskState;
pub extern fn gst_pad_set_iterate_internal_links_function_full(pad: ?*GstPad, iterintlink: GstPadIterIntLinkFunction, user_data: gpointer, notify: GDestroyNotify) void;
pub extern fn gst_pad_iterate_internal_links(pad: ?*GstPad) [*c]GstIterator;
pub extern fn gst_pad_iterate_internal_links_default(pad: ?*GstPad, parent: [*c]GstObject) [*c]GstIterator;
pub extern fn gst_pad_get_single_internal_link(pad: ?*GstPad) ?*GstPad;
pub extern fn gst_pad_query(pad: ?*GstPad, query: [*c]GstQuery) gboolean;
pub extern fn gst_pad_peer_query(pad: ?*GstPad, query: [*c]GstQuery) gboolean;
pub extern fn gst_pad_set_query_function_full(pad: ?*GstPad, query: GstPadQueryFunction, user_data: gpointer, notify: GDestroyNotify) void;
pub extern fn gst_pad_query_default(pad: ?*GstPad, parent: [*c]GstObject, query: [*c]GstQuery) gboolean;
pub extern fn gst_pad_forward(pad: ?*GstPad, forward: GstPadForwardFunction, user_data: gpointer) gboolean;
pub const GstPad_autoptr = ?*GstPad;
pub const GstPad_listautoptr = [*c]GList;
pub const GstPad_slistautoptr = [*c]GSList;
pub const GstPad_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstPad(arg__ptr: ?*GstPad) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstPad(arg__ptr: [*c]?*GstPad) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstPad(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstPad(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstPad(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstPad(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub const struct__GstBusClass = extern struct {
    parent_class: GstObjectClass,
    message: ?fn ([*c]GstBus, [*c]GstMessage) callconv(.C) void,
    sync_message: ?fn ([*c]GstBus, [*c]GstMessage) callconv(.C) void,
    _gst_reserved: [4]gpointer,
};
pub const GstBusClass = struct__GstBusClass;
pub const GST_BUS_FLUSHING: c_int = 16;
pub const GST_BUS_FLAG_LAST: c_int = 32;
pub const GstBusFlags = c_uint;
pub const GST_BUS_DROP: c_int = 0;
pub const GST_BUS_PASS: c_int = 1;
pub const GST_BUS_ASYNC: c_int = 2;
pub const GstBusSyncReply = c_uint;
pub const GstBusSyncHandler = ?fn ([*c]GstBus, [*c]GstMessage, gpointer) callconv(.C) GstBusSyncReply;
pub const GstBusFunc = ?fn ([*c]GstBus, [*c]GstMessage, gpointer) callconv(.C) gboolean;
pub extern fn gst_bus_get_type() GType;
pub extern fn gst_bus_new() [*c]GstBus;
pub extern fn gst_bus_post(bus: [*c]GstBus, message: [*c]GstMessage) gboolean;
pub extern fn gst_bus_have_pending(bus: [*c]GstBus) gboolean;
pub extern fn gst_bus_peek(bus: [*c]GstBus) [*c]GstMessage;
pub extern fn gst_bus_pop(bus: [*c]GstBus) [*c]GstMessage;
pub extern fn gst_bus_pop_filtered(bus: [*c]GstBus, types: GstMessageType) [*c]GstMessage;
pub extern fn gst_bus_timed_pop(bus: [*c]GstBus, timeout: GstClockTime) [*c]GstMessage;
pub extern fn gst_bus_timed_pop_filtered(bus: [*c]GstBus, timeout: GstClockTime, types: GstMessageType) [*c]GstMessage;
pub extern fn gst_bus_set_flushing(bus: [*c]GstBus, flushing: gboolean) void;
pub extern fn gst_bus_set_sync_handler(bus: [*c]GstBus, func: GstBusSyncHandler, user_data: gpointer, notify: GDestroyNotify) void;
pub extern fn gst_bus_get_pollfd(bus: [*c]GstBus, fd: [*c]GPollFD) void;
pub extern fn gst_bus_create_watch(bus: [*c]GstBus) [*c]GSource;
pub extern fn gst_bus_add_watch_full(bus: [*c]GstBus, priority: gint, func: GstBusFunc, user_data: gpointer, notify: GDestroyNotify) guint;
pub extern fn gst_bus_add_watch(bus: [*c]GstBus, func: GstBusFunc, user_data: gpointer) guint;
pub extern fn gst_bus_remove_watch(bus: [*c]GstBus) gboolean;
pub extern fn gst_bus_poll(bus: [*c]GstBus, events: GstMessageType, timeout: GstClockTime) [*c]GstMessage;
pub extern fn gst_bus_async_signal_func(bus: [*c]GstBus, message: [*c]GstMessage, data: gpointer) gboolean;
pub extern fn gst_bus_sync_signal_handler(bus: [*c]GstBus, message: [*c]GstMessage, data: gpointer) GstBusSyncReply;
pub extern fn gst_bus_add_signal_watch(bus: [*c]GstBus) void;
pub extern fn gst_bus_add_signal_watch_full(bus: [*c]GstBus, priority: gint) void;
pub extern fn gst_bus_remove_signal_watch(bus: [*c]GstBus) void;
pub extern fn gst_bus_enable_sync_message_emission(bus: [*c]GstBus) void;
pub extern fn gst_bus_disable_sync_message_emission(bus: [*c]GstBus) void;
pub const GstBus_autoptr = [*c]GstBus;
pub const GstBus_listautoptr = [*c]GList;
pub const GstBus_slistautoptr = [*c]GSList;
pub const GstBus_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstBus(arg__ptr: [*c]GstBus) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstBus(arg__ptr: [*c][*c]GstBus) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstBus(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstBus(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstBus(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstBus(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub const struct__GstElementFactoryClass = opaque {};
pub const GstElementFactoryClass = struct__GstElementFactoryClass;
pub const struct__GstPlugin = opaque {};
pub const GstPlugin = struct__GstPlugin;
pub const struct__GstPluginClass = opaque {};
pub const GstPluginClass = struct__GstPluginClass;
pub const GstPluginInitFunc = ?fn (?*GstPlugin) callconv(.C) gboolean;
pub const struct__GstPluginDesc = extern struct {
    major_version: gint,
    minor_version: gint,
    name: [*c]const gchar,
    description: [*c]const gchar,
    plugin_init: GstPluginInitFunc,
    version: [*c]const gchar,
    license: [*c]const gchar,
    source: [*c]const gchar,
    package: [*c]const gchar,
    origin: [*c]const gchar,
    release_datetime: [*c]const gchar,
    _gst_reserved: [4]gpointer,
};
pub const GstPluginDesc = struct__GstPluginDesc;
pub extern fn gst_plugin_error_quark() GQuark;
pub const GST_PLUGIN_ERROR_MODULE: c_int = 0;
pub const GST_PLUGIN_ERROR_DEPENDENCIES: c_int = 1;
pub const GST_PLUGIN_ERROR_NAME_MISMATCH: c_int = 2;
pub const GstPluginError = c_uint;
pub const GST_PLUGIN_FLAG_CACHED: c_int = 16;
pub const GST_PLUGIN_FLAG_BLACKLISTED: c_int = 32;
pub const GstPluginFlags = c_uint;
pub const GST_PLUGIN_DEPENDENCY_FLAG_NONE: c_int = 0;
pub const GST_PLUGIN_DEPENDENCY_FLAG_RECURSE: c_int = 1;
pub const GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_DEFAULT_ONLY: c_int = 2;
pub const GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_SUFFIX: c_int = 4;
pub const GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_PREFIX: c_int = 8;
pub const GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_RELATIVE_TO_EXE: c_int = 16;
pub const GstPluginDependencyFlags = c_uint;
pub const GstPluginInitFullFunc = ?fn (?*GstPlugin, gpointer) callconv(.C) gboolean;
pub const GstPluginFilter = ?fn (?*GstPlugin, gpointer) callconv(.C) gboolean;
pub extern fn gst_plugin_get_type() GType;
pub extern fn gst_plugin_register_static(major_version: gint, minor_version: gint, name: [*c]const gchar, description: [*c]const gchar, init_func: GstPluginInitFunc, version: [*c]const gchar, license: [*c]const gchar, source: [*c]const gchar, package: [*c]const gchar, origin: [*c]const gchar) gboolean;
pub extern fn gst_plugin_register_static_full(major_version: gint, minor_version: gint, name: [*c]const gchar, description: [*c]const gchar, init_full_func: GstPluginInitFullFunc, version: [*c]const gchar, license: [*c]const gchar, source: [*c]const gchar, package: [*c]const gchar, origin: [*c]const gchar, user_data: gpointer) gboolean;
pub extern fn gst_plugin_get_name(plugin: ?*GstPlugin) [*c]const gchar;
pub extern fn gst_plugin_get_description(plugin: ?*GstPlugin) [*c]const gchar;
pub extern fn gst_plugin_get_filename(plugin: ?*GstPlugin) [*c]const gchar;
pub extern fn gst_plugin_get_version(plugin: ?*GstPlugin) [*c]const gchar;
pub extern fn gst_plugin_get_license(plugin: ?*GstPlugin) [*c]const gchar;
pub extern fn gst_plugin_get_source(plugin: ?*GstPlugin) [*c]const gchar;
pub extern fn gst_plugin_get_package(plugin: ?*GstPlugin) [*c]const gchar;
pub extern fn gst_plugin_get_origin(plugin: ?*GstPlugin) [*c]const gchar;
pub extern fn gst_plugin_get_release_date_string(plugin: ?*GstPlugin) [*c]const gchar;
pub extern fn gst_plugin_get_cache_data(plugin: ?*GstPlugin) [*c]const GstStructure;
pub extern fn gst_plugin_set_cache_data(plugin: ?*GstPlugin, cache_data: [*c]GstStructure) void;
pub extern fn gst_plugin_is_loaded(plugin: ?*GstPlugin) gboolean;
pub extern fn gst_plugin_load_file(filename: [*c]const gchar, @"error": [*c][*c]GError) ?*GstPlugin;
pub extern fn gst_plugin_load(plugin: ?*GstPlugin) ?*GstPlugin;
pub extern fn gst_plugin_load_by_name(name: [*c]const gchar) ?*GstPlugin;
pub extern fn gst_plugin_add_dependency(plugin: ?*GstPlugin, env_vars: [*c][*c]const gchar, paths: [*c][*c]const gchar, names: [*c][*c]const gchar, flags: GstPluginDependencyFlags) void;
pub extern fn gst_plugin_add_dependency_simple(plugin: ?*GstPlugin, env_vars: [*c]const gchar, paths: [*c]const gchar, names: [*c]const gchar, flags: GstPluginDependencyFlags) void;
pub extern fn gst_plugin_list_free(list: [*c]GList) void;
pub const GstPlugin_autoptr = ?*GstPlugin;
pub const GstPlugin_listautoptr = [*c]GList;
pub const GstPlugin_slistautoptr = [*c]GSList;
pub const GstPlugin_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstPlugin(arg__ptr: ?*GstPlugin) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstPlugin(arg__ptr: [*c]?*GstPlugin) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstPlugin(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstPlugin(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstPlugin(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstPlugin(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub const struct__GstPluginFeature = opaque {};
pub const GstPluginFeature = struct__GstPluginFeature;
pub const struct__GstPluginFeatureClass = opaque {};
pub const GstPluginFeatureClass = struct__GstPluginFeatureClass;
pub const GST_RANK_NONE: c_int = 0;
pub const GST_RANK_MARGINAL: c_int = 64;
pub const GST_RANK_SECONDARY: c_int = 128;
pub const GST_RANK_PRIMARY: c_int = 256;
pub const GstRank = c_uint;
pub const GstPluginFeatureFilter = ?fn (?*GstPluginFeature, gpointer) callconv(.C) gboolean;
pub extern fn gst_plugin_feature_get_type() GType;
pub extern fn gst_plugin_feature_load(feature: ?*GstPluginFeature) ?*GstPluginFeature;
pub extern fn gst_plugin_feature_set_rank(feature: ?*GstPluginFeature, rank: guint) void;
pub extern fn gst_plugin_feature_get_rank(feature: ?*GstPluginFeature) guint;
pub extern fn gst_plugin_feature_get_plugin(feature: ?*GstPluginFeature) ?*GstPlugin;
pub extern fn gst_plugin_feature_get_plugin_name(feature: ?*GstPluginFeature) [*c]const gchar;
pub extern fn gst_plugin_feature_list_free(list: [*c]GList) void;
pub extern fn gst_plugin_feature_list_copy(list: [*c]GList) [*c]GList;
pub extern fn gst_plugin_feature_list_debug(list: [*c]GList) void;
pub extern fn gst_plugin_feature_check_version(feature: ?*GstPluginFeature, min_major: guint, min_minor: guint, min_micro: guint) gboolean;
pub extern fn gst_plugin_feature_rank_compare_func(p1: gconstpointer, p2: gconstpointer) gint;
pub const GstPluginFeature_autoptr = ?*GstPluginFeature;
pub const GstPluginFeature_listautoptr = [*c]GList;
pub const GstPluginFeature_slistautoptr = [*c]GSList;
pub const GstPluginFeature_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstPluginFeature(arg__ptr: ?*GstPluginFeature) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstPluginFeature(arg__ptr: [*c]?*GstPluginFeature) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstPluginFeature(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstPluginFeature(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstPluginFeature(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstPluginFeature(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub extern fn gst_uri_error_quark() GQuark;
pub const GST_URI_ERROR_UNSUPPORTED_PROTOCOL: c_int = 0;
pub const GST_URI_ERROR_BAD_URI: c_int = 1;
pub const GST_URI_ERROR_BAD_STATE: c_int = 2;
pub const GST_URI_ERROR_BAD_REFERENCE: c_int = 3;
pub const GstURIError = c_uint;
pub const GST_URI_UNKNOWN: c_int = 0;
pub const GST_URI_SINK: c_int = 1;
pub const GST_URI_SRC: c_int = 2;
pub const GstURIType = c_uint;
pub const struct__GstURIHandler = opaque {};
pub const GstURIHandler = struct__GstURIHandler;
pub const struct__GstURIHandlerInterface = extern struct {
    parent: GTypeInterface,
    get_type: ?fn (GType) callconv(.C) GstURIType,
    get_protocols: ?fn (GType) callconv(.C) [*c]const [*c]const gchar,
    get_uri: ?fn (?*GstURIHandler) callconv(.C) [*c]gchar,
    set_uri: ?fn (?*GstURIHandler, [*c]const gchar, [*c][*c]GError) callconv(.C) gboolean,
};
pub const GstURIHandlerInterface = struct__GstURIHandlerInterface;
pub extern fn gst_uri_protocol_is_valid(protocol: [*c]const gchar) gboolean;
pub extern fn gst_uri_protocol_is_supported(@"type": GstURIType, protocol: [*c]const gchar) gboolean;
pub extern fn gst_uri_is_valid(uri: [*c]const gchar) gboolean;
pub extern fn gst_uri_get_protocol(uri: [*c]const gchar) [*c]gchar;
pub extern fn gst_uri_has_protocol(uri: [*c]const gchar, protocol: [*c]const gchar) gboolean;
pub extern fn gst_uri_get_location(uri: [*c]const gchar) [*c]gchar;
pub extern fn gst_uri_construct(protocol: [*c]const gchar, location: [*c]const gchar) [*c]gchar;
pub extern fn gst_filename_to_uri(filename: [*c]const gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn gst_element_make_from_uri(@"type": GstURIType, uri: [*c]const gchar, elementname: [*c]const gchar, @"error": [*c][*c]GError) [*c]GstElement;
pub extern fn gst_uri_handler_get_type() GType;
pub extern fn gst_uri_handler_get_uri_type(handler: ?*GstURIHandler) GstURIType;
pub extern fn gst_uri_handler_get_protocols(handler: ?*GstURIHandler) [*c]const [*c]const gchar;
pub extern fn gst_uri_handler_get_uri(handler: ?*GstURIHandler) [*c]gchar;
pub extern fn gst_uri_handler_set_uri(handler: ?*GstURIHandler, uri: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub const struct__GstUri = opaque {};
pub const GstUri = struct__GstUri;
pub extern fn gst_uri_get_type() GType;
pub extern fn gst_uri_new(scheme: [*c]const gchar, userinfo: [*c]const gchar, host: [*c]const gchar, port: guint, path: [*c]const gchar, query: [*c]const gchar, fragment: [*c]const gchar) ?*GstUri;
pub extern fn gst_uri_new_with_base(base: ?*GstUri, scheme: [*c]const gchar, userinfo: [*c]const gchar, host: [*c]const gchar, port: guint, path: [*c]const gchar, query: [*c]const gchar, fragment: [*c]const gchar) ?*GstUri;
pub extern fn gst_uri_from_string(uri: [*c]const gchar) ?*GstUri;
pub extern fn gst_uri_from_string_escaped(uri: [*c]const gchar) ?*GstUri;
pub extern fn gst_uri_from_string_with_base(base: ?*GstUri, uri: [*c]const gchar) ?*GstUri;
pub extern fn gst_uri_equal(first: ?*const GstUri, second: ?*const GstUri) gboolean;
pub extern fn gst_uri_join(base_uri: ?*GstUri, ref_uri: ?*GstUri) ?*GstUri;
pub extern fn gst_uri_join_strings(base_uri: [*c]const gchar, ref_uri: [*c]const gchar) [*c]gchar;
pub extern fn gst_uri_is_writable(uri: ?*const GstUri) gboolean;
pub extern fn gst_uri_make_writable(uri: ?*GstUri) ?*GstUri;
pub extern fn gst_uri_to_string(uri: ?*const GstUri) [*c]gchar;
pub extern fn gst_uri_is_normalized(uri: ?*const GstUri) gboolean;
pub extern fn gst_uri_normalize(uri: ?*GstUri) gboolean;
pub extern fn gst_uri_get_scheme(uri: ?*const GstUri) [*c]const gchar;
pub extern fn gst_uri_set_scheme(uri: ?*GstUri, scheme: [*c]const gchar) gboolean;
pub extern fn gst_uri_get_userinfo(uri: ?*const GstUri) [*c]const gchar;
pub extern fn gst_uri_set_userinfo(uri: ?*GstUri, userinfo: [*c]const gchar) gboolean;
pub extern fn gst_uri_get_host(uri: ?*const GstUri) [*c]const gchar;
pub extern fn gst_uri_set_host(uri: ?*GstUri, host: [*c]const gchar) gboolean;
pub extern fn gst_uri_get_port(uri: ?*const GstUri) guint;
pub extern fn gst_uri_set_port(uri: ?*GstUri, port: guint) gboolean;
pub extern fn gst_uri_get_path(uri: ?*const GstUri) [*c]gchar;
pub extern fn gst_uri_set_path(uri: ?*GstUri, path: [*c]const gchar) gboolean;
pub extern fn gst_uri_get_path_string(uri: ?*const GstUri) [*c]gchar;
pub extern fn gst_uri_set_path_string(uri: ?*GstUri, path: [*c]const gchar) gboolean;
pub extern fn gst_uri_get_path_segments(uri: ?*const GstUri) [*c]GList;
pub extern fn gst_uri_set_path_segments(uri: ?*GstUri, path_segments: [*c]GList) gboolean;
pub extern fn gst_uri_append_path(uri: ?*GstUri, relative_path: [*c]const gchar) gboolean;
pub extern fn gst_uri_append_path_segment(uri: ?*GstUri, path_segment: [*c]const gchar) gboolean;
pub extern fn gst_uri_get_query_string(uri: ?*const GstUri) [*c]gchar;
pub extern fn gst_uri_set_query_string(uri: ?*GstUri, query: [*c]const gchar) gboolean;
pub extern fn gst_uri_get_query_table(uri: ?*const GstUri) ?*GHashTable;
pub extern fn gst_uri_set_query_table(uri: ?*GstUri, query_table: ?*GHashTable) gboolean;
pub extern fn gst_uri_set_query_value(uri: ?*GstUri, query_key: [*c]const gchar, query_value: [*c]const gchar) gboolean;
pub extern fn gst_uri_remove_query_key(uri: ?*GstUri, query_key: [*c]const gchar) gboolean;
pub extern fn gst_uri_query_has_key(uri: ?*const GstUri, query_key: [*c]const gchar) gboolean;
pub extern fn gst_uri_get_query_value(uri: ?*const GstUri, query_key: [*c]const gchar) [*c]const gchar;
pub extern fn gst_uri_get_query_keys(uri: ?*const GstUri) [*c]GList;
pub extern fn gst_uri_get_fragment(uri: ?*const GstUri) [*c]const gchar;
pub extern fn gst_uri_set_fragment(uri: ?*GstUri, fragment: [*c]const gchar) gboolean;
pub extern fn gst_uri_get_media_fragment_table(uri: ?*const GstUri) ?*GHashTable;
pub fn gst_uri_copy(arg_uri: ?*const GstUri) callconv(.C) ?*GstUri {
    var uri = arg_uri;
    return @ptrCast(?*GstUri, gst_mini_object_copy(@ptrCast([*c]const GstMiniObject, @alignCast(@import("std").meta.alignment([*c]const GstMiniObject), uri))));
}
pub fn gst_uri_ref(arg_uri: ?*GstUri) callconv(.C) ?*GstUri {
    var uri = arg_uri;
    return @ptrCast(?*GstUri, gst_mini_object_ref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), uri))));
}
pub fn gst_uri_unref(arg_uri: ?*GstUri) callconv(.C) void {
    var uri = arg_uri;
    gst_mini_object_unref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), uri)));
} // /usr/include/glib-2.0/glib/gmacros.h:820:31: warning: ignoring StaticAssert declaration
// /usr/include/glib-2.0/glib/gmem.h:133:9: warning: unsupported bool expression type
// /usr/include/gstreamer-1.0/gst/gsturi.h:374:1: warning: unable to translate function, demoted to extern
pub extern fn gst_clear_uri(arg_uri_ptr: [*c]?*GstUri) callconv(.C) void;
pub const GstUri_autoptr = ?*GstUri;
pub const GstUri_listautoptr = [*c]GList;
pub const GstUri_slistautoptr = [*c]GSList;
pub const GstUri_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstUri(arg__ptr: ?*GstUri) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_uri_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GstUri(arg__ptr: [*c]?*GstUri) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstUri(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstUri(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_uri_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstUri(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_uri_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstUri(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_uri_unref)))));
    }
}
pub extern fn gst_element_factory_get_type() GType;
pub extern fn gst_element_factory_find(name: [*c]const gchar) ?*GstElementFactory;
pub extern fn gst_element_factory_get_element_type(factory: ?*GstElementFactory) GType;
pub extern fn gst_element_factory_get_metadata(factory: ?*GstElementFactory, key: [*c]const gchar) [*c]const gchar;
pub extern fn gst_element_factory_get_metadata_keys(factory: ?*GstElementFactory) [*c][*c]gchar;
pub extern fn gst_element_factory_get_num_pad_templates(factory: ?*GstElementFactory) guint;
pub extern fn gst_element_factory_get_static_pad_templates(factory: ?*GstElementFactory) [*c]const GList;
pub extern fn gst_element_factory_get_uri_type(factory: ?*GstElementFactory) GstURIType;
pub extern fn gst_element_factory_get_uri_protocols(factory: ?*GstElementFactory) [*c]const [*c]const gchar;
pub extern fn gst_element_factory_has_interface(factory: ?*GstElementFactory, interfacename: [*c]const gchar) gboolean;
pub extern fn gst_element_factory_create(factory: ?*GstElementFactory, name: [*c]const gchar) [*c]GstElement;
pub extern fn gst_element_factory_create_full(factory: ?*GstElementFactory, first: [*c]const gchar, ...) [*c]GstElement;
pub extern fn gst_element_factory_create_valist(factory: ?*GstElementFactory, first: [*c]const gchar, properties: va_list) [*c]GstElement;
pub extern fn gst_element_factory_create_with_properties(factory: ?*GstElementFactory, n: guint, names: [*c][*c]const gchar, values: [*c]const GValue) [*c]GstElement;
pub extern fn gst_element_factory_make(factoryname: [*c]const gchar, name: [*c]const gchar) [*c]GstElement;
pub extern fn gst_element_factory_make_full(factoryname: [*c]const gchar, first: [*c]const gchar, ...) [*c]GstElement;
pub extern fn gst_element_factory_make_valist(factoryname: [*c]const gchar, first: [*c]const gchar, properties: va_list) [*c]GstElement;
pub extern fn gst_element_factory_make_with_properties(factoryname: [*c]const gchar, n: guint, names: [*c][*c]const gchar, values: [*c]const GValue) [*c]GstElement;
pub extern fn gst_element_register(plugin: ?*GstPlugin, name: [*c]const gchar, rank: guint, @"type": GType) gboolean;
pub extern fn gst_element_type_set_skip_documentation(@"type": GType) void;
pub extern fn gst_element_factory_get_skip_documentation(factory: ?*GstElementFactory) gboolean;
pub const GstElementFactoryListType = guint64;
pub extern fn gst_element_factory_list_is_type(factory: ?*GstElementFactory, @"type": GstElementFactoryListType) gboolean;
pub extern fn gst_element_factory_list_get_elements(@"type": GstElementFactoryListType, minrank: GstRank) [*c]GList;
pub extern fn gst_element_factory_list_filter(list: [*c]GList, caps: [*c]const GstCaps, direction: GstPadDirection, subsetonly: gboolean) [*c]GList;
pub const GstElementFactory_autoptr = ?*GstElementFactory;
pub const GstElementFactory_listautoptr = [*c]GList;
pub const GstElementFactory_slistautoptr = [*c]GSList;
pub const GstElementFactory_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstElementFactory(arg__ptr: ?*GstElementFactory) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstElementFactory(arg__ptr: [*c]?*GstElementFactory) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstElementFactory(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstElementFactory(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstElementFactory(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstElementFactory(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub const GST_STATE_CHANGE_NULL_TO_READY: c_int = 10;
pub const GST_STATE_CHANGE_READY_TO_PAUSED: c_int = 19;
pub const GST_STATE_CHANGE_PAUSED_TO_PLAYING: c_int = 28;
pub const GST_STATE_CHANGE_PLAYING_TO_PAUSED: c_int = 35;
pub const GST_STATE_CHANGE_PAUSED_TO_READY: c_int = 26;
pub const GST_STATE_CHANGE_READY_TO_NULL: c_int = 17;
pub const GST_STATE_CHANGE_NULL_TO_NULL: c_int = 9;
pub const GST_STATE_CHANGE_READY_TO_READY: c_int = 18;
pub const GST_STATE_CHANGE_PAUSED_TO_PAUSED: c_int = 27;
pub const GST_STATE_CHANGE_PLAYING_TO_PLAYING: c_int = 36;
pub const GstStateChange = c_uint;
pub const GST_ELEMENT_FLAG_LOCKED_STATE: c_int = 16;
pub const GST_ELEMENT_FLAG_SINK: c_int = 32;
pub const GST_ELEMENT_FLAG_SOURCE: c_int = 64;
pub const GST_ELEMENT_FLAG_PROVIDE_CLOCK: c_int = 128;
pub const GST_ELEMENT_FLAG_REQUIRE_CLOCK: c_int = 256;
pub const GST_ELEMENT_FLAG_INDEXABLE: c_int = 512;
pub const GST_ELEMENT_FLAG_LAST: c_int = 16384;
pub const GstElementFlags = c_uint;
pub extern fn gst_make_element_message_details(name: [*c]const u8, ...) [*c]GstStructure;
pub extern fn gst_element_class_add_pad_template(klass: [*c]GstElementClass, templ: [*c]GstPadTemplate) void;
pub extern fn gst_element_class_add_static_pad_template(klass: [*c]GstElementClass, static_templ: [*c]GstStaticPadTemplate) void;
pub extern fn gst_element_class_add_static_pad_template_with_gtype(klass: [*c]GstElementClass, static_templ: [*c]GstStaticPadTemplate, pad_type: GType) void;
pub extern fn gst_element_class_get_pad_template(element_class: [*c]GstElementClass, name: [*c]const gchar) [*c]GstPadTemplate;
pub extern fn gst_element_class_get_pad_template_list(element_class: [*c]GstElementClass) [*c]GList;
pub extern fn gst_element_class_set_metadata(klass: [*c]GstElementClass, longname: [*c]const gchar, classification: [*c]const gchar, description: [*c]const gchar, author: [*c]const gchar) void;
pub extern fn gst_element_class_set_static_metadata(klass: [*c]GstElementClass, longname: [*c]const gchar, classification: [*c]const gchar, description: [*c]const gchar, author: [*c]const gchar) void;
pub extern fn gst_element_class_add_metadata(klass: [*c]GstElementClass, key: [*c]const gchar, value: [*c]const gchar) void;
pub extern fn gst_element_class_add_static_metadata(klass: [*c]GstElementClass, key: [*c]const gchar, value: [*c]const gchar) void;
pub extern fn gst_element_class_get_metadata(klass: [*c]GstElementClass, key: [*c]const gchar) [*c]const gchar;
pub extern fn gst_element_get_type() GType;
pub extern fn gst_element_provide_clock(element: [*c]GstElement) [*c]GstClock;
pub extern fn gst_element_get_clock(element: [*c]GstElement) [*c]GstClock;
pub extern fn gst_element_set_clock(element: [*c]GstElement, clock: [*c]GstClock) gboolean;
pub extern fn gst_element_set_base_time(element: [*c]GstElement, time: GstClockTime) void;
pub extern fn gst_element_get_base_time(element: [*c]GstElement) GstClockTime;
pub extern fn gst_element_set_start_time(element: [*c]GstElement, time: GstClockTime) void;
pub extern fn gst_element_get_start_time(element: [*c]GstElement) GstClockTime;
pub extern fn gst_element_get_current_running_time(element: [*c]GstElement) GstClockTime;
pub extern fn gst_element_get_current_clock_time(element: [*c]GstElement) GstClockTime;
pub extern fn gst_element_set_bus(element: [*c]GstElement, bus: [*c]GstBus) void;
pub extern fn gst_element_get_bus(element: [*c]GstElement) [*c]GstBus;
pub extern fn gst_element_set_context(element: [*c]GstElement, context: ?*GstContext) void;
pub extern fn gst_element_get_contexts(element: [*c]GstElement) [*c]GList;
pub extern fn gst_element_get_context(element: [*c]GstElement, context_type: [*c]const gchar) ?*GstContext;
pub extern fn gst_element_get_context_unlocked(element: [*c]GstElement, context_type: [*c]const gchar) ?*GstContext;
pub extern fn gst_element_add_pad(element: [*c]GstElement, pad: ?*GstPad) gboolean;
pub extern fn gst_element_remove_pad(element: [*c]GstElement, pad: ?*GstPad) gboolean;
pub extern fn gst_element_no_more_pads(element: [*c]GstElement) void;
pub extern fn gst_element_get_static_pad(element: [*c]GstElement, name: [*c]const gchar) ?*GstPad;
pub extern fn gst_element_get_request_pad(element: [*c]GstElement, name: [*c]const gchar) ?*GstPad;
pub extern fn gst_element_request_pad_simple(element: [*c]GstElement, name: [*c]const gchar) ?*GstPad;
pub extern fn gst_element_request_pad(element: [*c]GstElement, templ: [*c]GstPadTemplate, name: [*c]const gchar, caps: [*c]const GstCaps) ?*GstPad;
pub extern fn gst_element_release_request_pad(element: [*c]GstElement, pad: ?*GstPad) void;
pub extern fn gst_element_iterate_pads(element: [*c]GstElement) [*c]GstIterator;
pub extern fn gst_element_iterate_src_pads(element: [*c]GstElement) [*c]GstIterator;
pub extern fn gst_element_iterate_sink_pads(element: [*c]GstElement) [*c]GstIterator;
pub const GstElementForeachPadFunc = ?fn ([*c]GstElement, ?*GstPad, gpointer) callconv(.C) gboolean;
pub extern fn gst_element_foreach_sink_pad(element: [*c]GstElement, func: GstElementForeachPadFunc, user_data: gpointer) gboolean;
pub extern fn gst_element_foreach_src_pad(element: [*c]GstElement, func: GstElementForeachPadFunc, user_data: gpointer) gboolean;
pub extern fn gst_element_foreach_pad(element: [*c]GstElement, func: GstElementForeachPadFunc, user_data: gpointer) gboolean;
pub extern fn gst_element_send_event(element: [*c]GstElement, event: [*c]GstEvent) gboolean;
pub extern fn gst_element_seek(element: [*c]GstElement, rate: gdouble, format: GstFormat, flags: GstSeekFlags, start_type: GstSeekType, start: gint64, stop_type: GstSeekType, stop: gint64) gboolean;
pub extern fn gst_element_query(element: [*c]GstElement, query: [*c]GstQuery) gboolean;
pub extern fn gst_element_post_message(element: [*c]GstElement, message: [*c]GstMessage) gboolean;
pub extern fn _gst_element_error_printf(format: [*c]const gchar, ...) [*c]gchar;
pub extern fn gst_element_message_full(element: [*c]GstElement, @"type": GstMessageType, domain: GQuark, code: gint, text: [*c]gchar, debug: [*c]gchar, file: [*c]const gchar, function: [*c]const gchar, line: gint) void;
pub extern fn gst_element_message_full_with_details(element: [*c]GstElement, @"type": GstMessageType, domain: GQuark, code: gint, text: [*c]gchar, debug: [*c]gchar, file: [*c]const gchar, function: [*c]const gchar, line: gint, structure: [*c]GstStructure) void;
pub extern fn gst_element_is_locked_state(element: [*c]GstElement) gboolean;
pub extern fn gst_element_set_locked_state(element: [*c]GstElement, locked_state: gboolean) gboolean;
pub extern fn gst_element_sync_state_with_parent(element: [*c]GstElement) gboolean;
pub extern fn gst_element_get_state(element: [*c]GstElement, state: [*c]GstState, pending: [*c]GstState, timeout: GstClockTime) GstStateChangeReturn;
pub extern fn gst_element_set_state(element: [*c]GstElement, state: GstState) GstStateChangeReturn;
pub extern fn gst_element_abort_state(element: [*c]GstElement) void;
pub extern fn gst_element_change_state(element: [*c]GstElement, transition: GstStateChange) GstStateChangeReturn;
pub extern fn gst_element_continue_state(element: [*c]GstElement, ret: GstStateChangeReturn) GstStateChangeReturn;
pub extern fn gst_element_lost_state(element: [*c]GstElement) void;
pub const GstElementCallAsyncFunc = ?fn ([*c]GstElement, gpointer) callconv(.C) void;
pub extern fn gst_element_call_async(element: [*c]GstElement, func: GstElementCallAsyncFunc, user_data: gpointer, destroy_notify: GDestroyNotify) void;
pub extern fn gst_element_get_factory(element: [*c]GstElement) ?*GstElementFactory;
pub extern fn gst_element_add_property_notify_watch(element: [*c]GstElement, property_name: [*c]const gchar, include_value: gboolean) gulong;
pub extern fn gst_element_add_property_deep_notify_watch(element: [*c]GstElement, property_name: [*c]const gchar, include_value: gboolean) gulong;
pub extern fn gst_element_remove_property_notify_watch(element: [*c]GstElement, watch_id: gulong) void;
pub extern fn gst_element_get_pad_template(element: [*c]GstElement, name: [*c]const gchar) [*c]GstPadTemplate;
pub extern fn gst_element_get_pad_template_list(element: [*c]GstElement) [*c]GList;
pub extern fn gst_element_get_metadata(element: [*c]GstElement, key: [*c]const gchar) [*c]const gchar;
pub const GstElement_autoptr = [*c]GstElement;
pub const GstElement_listautoptr = [*c]GList;
pub const GstElement_slistautoptr = [*c]GSList;
pub const GstElement_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstElement(arg__ptr: [*c]GstElement) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstElement(arg__ptr: [*c][*c]GstElement) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstElement(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstElement(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstElement(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstElement(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub const GST_BIN_FLAG_NO_RESYNC: c_int = 16384;
pub const GST_BIN_FLAG_STREAMS_AWARE: c_int = 32768;
pub const GST_BIN_FLAG_LAST: c_int = 524288;
pub const GstBinFlags = c_uint;
pub const struct__GstBinPrivate = opaque {};
pub const GstBinPrivate = struct__GstBinPrivate;
pub const struct__GstBin = extern struct {
    element: GstElement,
    numchildren: gint,
    children: [*c]GList,
    children_cookie: guint32,
    child_bus: [*c]GstBus,
    messages: [*c]GList,
    polling: gboolean,
    state_dirty: gboolean,
    clock_dirty: gboolean,
    provided_clock: [*c]GstClock,
    clock_provider: [*c]GstElement,
    priv: ?*GstBinPrivate,
    _gst_reserved: [4]gpointer,
};
pub const GstBin = struct__GstBin;
pub const struct__GstBinClass = extern struct {
    parent_class: GstElementClass,
    pool: [*c]GThreadPool,
    element_added: ?fn ([*c]GstBin, [*c]GstElement) callconv(.C) void,
    element_removed: ?fn ([*c]GstBin, [*c]GstElement) callconv(.C) void,
    add_element: ?fn ([*c]GstBin, [*c]GstElement) callconv(.C) gboolean,
    remove_element: ?fn ([*c]GstBin, [*c]GstElement) callconv(.C) gboolean,
    handle_message: ?fn ([*c]GstBin, [*c]GstMessage) callconv(.C) void,
    do_latency: ?fn ([*c]GstBin) callconv(.C) gboolean,
    deep_element_added: ?fn ([*c]GstBin, [*c]GstBin, [*c]GstElement) callconv(.C) void,
    deep_element_removed: ?fn ([*c]GstBin, [*c]GstBin, [*c]GstElement) callconv(.C) void,
    _gst_reserved: [2]gpointer,
};
pub const GstBinClass = struct__GstBinClass;
pub extern fn gst_bin_get_type() GType;
pub extern fn gst_bin_new(name: [*c]const gchar) [*c]GstElement;
pub extern fn gst_bin_add(bin: [*c]GstBin, element: [*c]GstElement) gboolean;
pub extern fn gst_bin_remove(bin: [*c]GstBin, element: [*c]GstElement) gboolean;
pub extern fn gst_bin_get_by_name(bin: [*c]GstBin, name: [*c]const gchar) [*c]GstElement;
pub extern fn gst_bin_get_by_name_recurse_up(bin: [*c]GstBin, name: [*c]const gchar) [*c]GstElement;
pub extern fn gst_bin_get_by_interface(bin: [*c]GstBin, iface: GType) [*c]GstElement;
pub extern fn gst_bin_iterate_elements(bin: [*c]GstBin) [*c]GstIterator;
pub extern fn gst_bin_iterate_sorted(bin: [*c]GstBin) [*c]GstIterator;
pub extern fn gst_bin_iterate_recurse(bin: [*c]GstBin) [*c]GstIterator;
pub extern fn gst_bin_iterate_sinks(bin: [*c]GstBin) [*c]GstIterator;
pub extern fn gst_bin_iterate_sources(bin: [*c]GstBin) [*c]GstIterator;
pub extern fn gst_bin_iterate_all_by_interface(bin: [*c]GstBin, iface: GType) [*c]GstIterator;
pub extern fn gst_bin_iterate_all_by_element_factory_name(bin: [*c]GstBin, factory_name: [*c]const gchar) [*c]GstIterator;
pub extern fn gst_bin_recalculate_latency(bin: [*c]GstBin) gboolean;
pub extern fn gst_bin_set_suppressed_flags(bin: [*c]GstBin, flags: GstElementFlags) void;
pub extern fn gst_bin_get_suppressed_flags(bin: [*c]GstBin) GstElementFlags;
pub const GstBin_autoptr = [*c]GstBin;
pub const GstBin_listautoptr = [*c]GList;
pub const GstBin_slistautoptr = [*c]GSList;
pub const GstBin_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstBin(arg__ptr: [*c]GstBin) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstBin(arg__ptr: [*c][*c]GstBin) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstBin(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstBin(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstBin(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstBin(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub const struct__GstBufferPoolAcquireParams = extern struct {
    format: GstFormat,
    start: gint64,
    stop: gint64,
    flags: GstBufferPoolAcquireFlags,
    _gst_reserved: [4]gpointer,
};
pub const GstBufferPoolAcquireParams = struct__GstBufferPoolAcquireParams;
pub const struct__GstBufferPoolClass = extern struct {
    object_class: GstObjectClass,
    get_options: ?fn ([*c]GstBufferPool) callconv(.C) [*c][*c]const gchar,
    set_config: ?fn ([*c]GstBufferPool, [*c]GstStructure) callconv(.C) gboolean,
    start: ?fn ([*c]GstBufferPool) callconv(.C) gboolean,
    stop: ?fn ([*c]GstBufferPool) callconv(.C) gboolean,
    acquire_buffer: ?fn ([*c]GstBufferPool, [*c][*c]GstBuffer, [*c]GstBufferPoolAcquireParams) callconv(.C) GstFlowReturn,
    alloc_buffer: ?fn ([*c]GstBufferPool, [*c][*c]GstBuffer, [*c]GstBufferPoolAcquireParams) callconv(.C) GstFlowReturn,
    reset_buffer: ?fn ([*c]GstBufferPool, [*c]GstBuffer) callconv(.C) void,
    release_buffer: ?fn ([*c]GstBufferPool, [*c]GstBuffer) callconv(.C) void,
    free_buffer: ?fn ([*c]GstBufferPool, [*c]GstBuffer) callconv(.C) void,
    flush_start: ?fn ([*c]GstBufferPool) callconv(.C) void,
    flush_stop: ?fn ([*c]GstBufferPool) callconv(.C) void,
    _gst_reserved: [2]gpointer,
};
pub const GstBufferPoolClass = struct__GstBufferPoolClass;
pub const GST_BUFFER_POOL_ACQUIRE_FLAG_NONE: c_int = 0;
pub const GST_BUFFER_POOL_ACQUIRE_FLAG_KEY_UNIT: c_int = 1;
pub const GST_BUFFER_POOL_ACQUIRE_FLAG_DONTWAIT: c_int = 2;
pub const GST_BUFFER_POOL_ACQUIRE_FLAG_DISCONT: c_int = 4;
pub const GST_BUFFER_POOL_ACQUIRE_FLAG_LAST: c_int = 65536;
pub const GstBufferPoolAcquireFlags = c_uint;
pub extern fn gst_buffer_pool_get_type() GType;
pub extern fn gst_buffer_pool_new() [*c]GstBufferPool;
pub extern fn gst_buffer_pool_set_active(pool: [*c]GstBufferPool, active: gboolean) gboolean;
pub extern fn gst_buffer_pool_is_active(pool: [*c]GstBufferPool) gboolean;
pub extern fn gst_buffer_pool_set_config(pool: [*c]GstBufferPool, config: [*c]GstStructure) gboolean;
pub extern fn gst_buffer_pool_get_config(pool: [*c]GstBufferPool) [*c]GstStructure;
pub extern fn gst_buffer_pool_get_options(pool: [*c]GstBufferPool) [*c][*c]const gchar;
pub extern fn gst_buffer_pool_has_option(pool: [*c]GstBufferPool, option: [*c]const gchar) gboolean;
pub extern fn gst_buffer_pool_set_flushing(pool: [*c]GstBufferPool, flushing: gboolean) void;
pub extern fn gst_buffer_pool_config_set_params(config: [*c]GstStructure, caps: [*c]GstCaps, size: guint, min_buffers: guint, max_buffers: guint) void;
pub extern fn gst_buffer_pool_config_get_params(config: [*c]GstStructure, caps: [*c][*c]GstCaps, size: [*c]guint, min_buffers: [*c]guint, max_buffers: [*c]guint) gboolean;
pub extern fn gst_buffer_pool_config_set_allocator(config: [*c]GstStructure, allocator: [*c]GstAllocator, params: [*c]const GstAllocationParams) void;
pub extern fn gst_buffer_pool_config_get_allocator(config: [*c]GstStructure, allocator: [*c][*c]GstAllocator, params: [*c]GstAllocationParams) gboolean;
pub extern fn gst_buffer_pool_config_n_options(config: [*c]GstStructure) guint;
pub extern fn gst_buffer_pool_config_add_option(config: [*c]GstStructure, option: [*c]const gchar) void;
pub extern fn gst_buffer_pool_config_get_option(config: [*c]GstStructure, index: guint) [*c]const gchar;
pub extern fn gst_buffer_pool_config_has_option(config: [*c]GstStructure, option: [*c]const gchar) gboolean;
pub extern fn gst_buffer_pool_config_validate_params(config: [*c]GstStructure, caps: [*c]GstCaps, size: guint, min_buffers: guint, max_buffers: guint) gboolean;
pub extern fn gst_buffer_pool_acquire_buffer(pool: [*c]GstBufferPool, buffer: [*c][*c]GstBuffer, params: [*c]GstBufferPoolAcquireParams) GstFlowReturn;
pub extern fn gst_buffer_pool_release_buffer(pool: [*c]GstBufferPool, buffer: [*c]GstBuffer) void;
pub const struct__GstChildProxy = opaque {};
pub const GstChildProxy = struct__GstChildProxy;
pub const struct__GstChildProxyInterface = extern struct {
    parent: GTypeInterface,
    get_child_by_name: ?fn (?*GstChildProxy, [*c]const gchar) callconv(.C) [*c]GObject,
    get_child_by_index: ?fn (?*GstChildProxy, guint) callconv(.C) [*c]GObject,
    get_children_count: ?fn (?*GstChildProxy) callconv(.C) guint,
    child_added: ?fn (?*GstChildProxy, [*c]GObject, [*c]const gchar) callconv(.C) void,
    child_removed: ?fn (?*GstChildProxy, [*c]GObject, [*c]const gchar) callconv(.C) void,
    _gst_reserved: [4]gpointer,
};
pub const GstChildProxyInterface = struct__GstChildProxyInterface;
pub extern fn gst_child_proxy_get_type() GType;
pub extern fn gst_child_proxy_get_child_by_name(parent: ?*GstChildProxy, name: [*c]const gchar) [*c]GObject;
pub extern fn gst_child_proxy_get_children_count(parent: ?*GstChildProxy) guint;
pub extern fn gst_child_proxy_get_child_by_index(parent: ?*GstChildProxy, index: guint) [*c]GObject;
pub extern fn gst_child_proxy_lookup(object: ?*GstChildProxy, name: [*c]const gchar, target: [*c][*c]GObject, pspec: [*c][*c]GParamSpec) gboolean;
pub extern fn gst_child_proxy_get_property(object: ?*GstChildProxy, name: [*c]const gchar, value: [*c]GValue) void;
pub extern fn gst_child_proxy_get_valist(object: ?*GstChildProxy, first_property_name: [*c]const gchar, var_args: va_list) void;
pub extern fn gst_child_proxy_get(object: ?*GstChildProxy, first_property_name: [*c]const gchar, ...) void;
pub extern fn gst_child_proxy_set_property(object: ?*GstChildProxy, name: [*c]const gchar, value: [*c]const GValue) void;
pub extern fn gst_child_proxy_set_valist(object: ?*GstChildProxy, first_property_name: [*c]const gchar, var_args: va_list) void;
pub extern fn gst_child_proxy_set(object: ?*GstChildProxy, first_property_name: [*c]const gchar, ...) void;
pub extern fn gst_child_proxy_child_added(parent: ?*GstChildProxy, child: [*c]GObject, name: [*c]const gchar) void;
pub extern fn gst_child_proxy_child_removed(parent: ?*GstChildProxy, child: [*c]GObject, name: [*c]const gchar) void;
pub const GST_DEBUG_GRAPH_SHOW_MEDIA_TYPE: c_int = 1;
pub const GST_DEBUG_GRAPH_SHOW_CAPS_DETAILS: c_int = 2;
pub const GST_DEBUG_GRAPH_SHOW_NON_DEFAULT_PARAMS: c_int = 4;
pub const GST_DEBUG_GRAPH_SHOW_STATES: c_int = 8;
pub const GST_DEBUG_GRAPH_SHOW_FULL_PARAMS: c_int = 16;
pub const GST_DEBUG_GRAPH_SHOW_ALL: c_int = 15;
pub const GST_DEBUG_GRAPH_SHOW_VERBOSE: c_int = -1;
pub const GstDebugGraphDetails = c_int;
pub extern fn gst_debug_bin_to_dot_data(bin: [*c]GstBin, details: GstDebugGraphDetails) [*c]gchar;
pub extern fn gst_debug_bin_to_dot_file(bin: [*c]GstBin, details: GstDebugGraphDetails, file_name: [*c]const gchar) void;
pub extern fn gst_debug_bin_to_dot_file_with_ts(bin: [*c]GstBin, details: GstDebugGraphDetails, file_name: [*c]const gchar) void;
pub const struct__GstDeviceProviderPrivate = opaque {};
pub const GstDeviceProviderPrivate = struct__GstDeviceProviderPrivate;
pub const struct__GstDeviceProvider = extern struct {
    parent: GstObject,
    devices: [*c]GList,
    priv: ?*GstDeviceProviderPrivate,
    _gst_reserved: [4]gpointer,
};
pub const GstDeviceProvider = struct__GstDeviceProvider;
pub const struct__GstDeviceProviderFactory = opaque {};
pub const GstDeviceProviderFactory = struct__GstDeviceProviderFactory;
pub const struct__GstDeviceProviderClass = extern struct {
    parent_class: GstObjectClass,
    factory: ?*GstDeviceProviderFactory,
    probe: ?fn ([*c]GstDeviceProvider) callconv(.C) [*c]GList,
    start: ?fn ([*c]GstDeviceProvider) callconv(.C) gboolean,
    stop: ?fn ([*c]GstDeviceProvider) callconv(.C) void,
    metadata: gpointer,
    _gst_reserved: [4]gpointer,
};
pub const GstDeviceProviderClass = struct__GstDeviceProviderClass;
pub const struct__GstDeviceProviderFactoryClass = opaque {};
pub const GstDeviceProviderFactoryClass = struct__GstDeviceProviderFactoryClass;
pub extern fn gst_device_provider_factory_get_type() GType;
pub extern fn gst_device_provider_factory_find(name: [*c]const gchar) ?*GstDeviceProviderFactory;
pub extern fn gst_device_provider_factory_get_device_provider_type(factory: ?*GstDeviceProviderFactory) GType;
pub extern fn gst_device_provider_factory_get_metadata(factory: ?*GstDeviceProviderFactory, key: [*c]const gchar) [*c]const gchar;
pub extern fn gst_device_provider_factory_get_metadata_keys(factory: ?*GstDeviceProviderFactory) [*c][*c]gchar;
pub extern fn gst_device_provider_factory_get(factory: ?*GstDeviceProviderFactory) [*c]GstDeviceProvider;
pub extern fn gst_device_provider_factory_get_by_name(factoryname: [*c]const gchar) [*c]GstDeviceProvider;
pub extern fn gst_device_provider_register(plugin: ?*GstPlugin, name: [*c]const gchar, rank: guint, @"type": GType) gboolean;
pub extern fn gst_device_provider_factory_has_classesv(factory: ?*GstDeviceProviderFactory, classes: [*c][*c]gchar) gboolean;
pub extern fn gst_device_provider_factory_has_classes(factory: ?*GstDeviceProviderFactory, classes: [*c]const gchar) gboolean;
pub extern fn gst_device_provider_factory_list_get_device_providers(minrank: GstRank) [*c]GList;
pub const GstDeviceProviderFactory_autoptr = ?*GstDeviceProviderFactory;
pub const GstDeviceProviderFactory_listautoptr = [*c]GList;
pub const GstDeviceProviderFactory_slistautoptr = [*c]GSList;
pub const GstDeviceProviderFactory_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstDeviceProviderFactory(arg__ptr: ?*GstDeviceProviderFactory) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstDeviceProviderFactory(arg__ptr: [*c]?*GstDeviceProviderFactory) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstDeviceProviderFactory(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstDeviceProviderFactory(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstDeviceProviderFactory(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstDeviceProviderFactory(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub extern fn gst_device_provider_get_type() GType;
pub extern fn gst_device_provider_get_devices(provider: [*c]GstDeviceProvider) [*c]GList;
pub extern fn gst_device_provider_start(provider: [*c]GstDeviceProvider) gboolean;
pub extern fn gst_device_provider_stop(provider: [*c]GstDeviceProvider) void;
pub extern fn gst_device_provider_can_monitor(provider: [*c]GstDeviceProvider) gboolean;
pub extern fn gst_device_provider_get_bus(provider: [*c]GstDeviceProvider) [*c]GstBus;
pub extern fn gst_device_provider_device_add(provider: [*c]GstDeviceProvider, device: [*c]GstDevice) void;
pub extern fn gst_device_provider_device_remove(provider: [*c]GstDeviceProvider, device: [*c]GstDevice) void;
pub extern fn gst_device_provider_get_hidden_providers(provider: [*c]GstDeviceProvider) [*c][*c]gchar;
pub extern fn gst_device_provider_hide_provider(provider: [*c]GstDeviceProvider, name: [*c]const gchar) void;
pub extern fn gst_device_provider_unhide_provider(provider: [*c]GstDeviceProvider, name: [*c]const gchar) void;
pub extern fn gst_device_provider_get_metadata(provider: [*c]GstDeviceProvider, key: [*c]const gchar) [*c]const gchar;
pub extern fn gst_device_provider_is_started(provider: [*c]GstDeviceProvider) gboolean;
pub extern fn gst_device_provider_class_set_metadata(klass: [*c]GstDeviceProviderClass, longname: [*c]const gchar, classification: [*c]const gchar, description: [*c]const gchar, author: [*c]const gchar) void;
pub extern fn gst_device_provider_class_set_static_metadata(klass: [*c]GstDeviceProviderClass, longname: [*c]const gchar, classification: [*c]const gchar, description: [*c]const gchar, author: [*c]const gchar) void;
pub extern fn gst_device_provider_class_add_metadata(klass: [*c]GstDeviceProviderClass, key: [*c]const gchar, value: [*c]const gchar) void;
pub extern fn gst_device_provider_class_add_static_metadata(klass: [*c]GstDeviceProviderClass, key: [*c]const gchar, value: [*c]const gchar) void;
pub extern fn gst_device_provider_class_get_metadata(klass: [*c]GstDeviceProviderClass, key: [*c]const gchar) [*c]const gchar;
pub extern fn gst_device_provider_device_changed(provider: [*c]GstDeviceProvider, device: [*c]GstDevice, changed_device: [*c]GstDevice) void;
pub extern fn gst_device_provider_get_factory(provider: [*c]GstDeviceProvider) ?*GstDeviceProviderFactory;
pub const GstDeviceProvider_autoptr = [*c]GstDeviceProvider;
pub const GstDeviceProvider_listautoptr = [*c]GList;
pub const GstDeviceProvider_slistautoptr = [*c]GSList;
pub const GstDeviceProvider_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstDeviceProvider(arg__ptr: [*c]GstDeviceProvider) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstDeviceProvider(arg__ptr: [*c][*c]GstDeviceProvider) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstDeviceProvider(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstDeviceProvider(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstDeviceProvider(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstDeviceProvider(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub const struct__GstDeviceMonitorPrivate = opaque {};
pub const GstDeviceMonitorPrivate = struct__GstDeviceMonitorPrivate;
pub const struct__GstDeviceMonitor = extern struct {
    parent: GstObject,
    priv: ?*GstDeviceMonitorPrivate,
    _gst_reserved: [4]gpointer,
};
pub const GstDeviceMonitor = struct__GstDeviceMonitor;
pub const struct__GstDeviceMonitorClass = extern struct {
    parent_class: GstObjectClass,
    _gst_reserved: [4]gpointer,
};
pub const GstDeviceMonitorClass = struct__GstDeviceMonitorClass;
pub extern fn gst_device_monitor_get_type() GType;
pub extern fn gst_device_monitor_new() [*c]GstDeviceMonitor;
pub extern fn gst_device_monitor_get_bus(monitor: [*c]GstDeviceMonitor) [*c]GstBus;
pub extern fn gst_device_monitor_get_devices(monitor: [*c]GstDeviceMonitor) [*c]GList;
pub extern fn gst_device_monitor_start(monitor: [*c]GstDeviceMonitor) gboolean;
pub extern fn gst_device_monitor_stop(monitor: [*c]GstDeviceMonitor) void;
pub extern fn gst_device_monitor_add_filter(monitor: [*c]GstDeviceMonitor, classes: [*c]const gchar, caps: [*c]GstCaps) guint;
pub extern fn gst_device_monitor_remove_filter(monitor: [*c]GstDeviceMonitor, filter_id: guint) gboolean;
pub extern fn gst_device_monitor_get_providers(monitor: [*c]GstDeviceMonitor) [*c][*c]gchar;
pub extern fn gst_device_monitor_set_show_all_devices(monitor: [*c]GstDeviceMonitor, show_all: gboolean) void;
pub extern fn gst_device_monitor_get_show_all_devices(monitor: [*c]GstDeviceMonitor) gboolean;
pub const GstDeviceMonitor_autoptr = [*c]GstDeviceMonitor;
pub const GstDeviceMonitor_listautoptr = [*c]GList;
pub const GstDeviceMonitor_slistautoptr = [*c]GSList;
pub const GstDeviceMonitor_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstDeviceMonitor(arg__ptr: [*c]GstDeviceMonitor) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstDeviceMonitor(arg__ptr: [*c][*c]GstDeviceMonitor) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstDeviceMonitor(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstDeviceMonitor(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstDeviceMonitor(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstDeviceMonitor(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub const struct__GstDynamicTypeFactory = opaque {};
pub const GstDynamicTypeFactory = struct__GstDynamicTypeFactory;
pub const struct__GstDynamicTypeFactoryClass = opaque {};
pub const GstDynamicTypeFactoryClass = struct__GstDynamicTypeFactoryClass;
pub extern fn gst_dynamic_type_factory_get_type() GType;
pub extern fn gst_dynamic_type_factory_load(factoryname: [*c]const gchar) GType;
pub extern fn gst_dynamic_type_register(plugin: ?*GstPlugin, @"type": GType) gboolean;
pub const GST_CORE_ERROR_FAILED: c_int = 1;
pub const GST_CORE_ERROR_TOO_LAZY: c_int = 2;
pub const GST_CORE_ERROR_NOT_IMPLEMENTED: c_int = 3;
pub const GST_CORE_ERROR_STATE_CHANGE: c_int = 4;
pub const GST_CORE_ERROR_PAD: c_int = 5;
pub const GST_CORE_ERROR_THREAD: c_int = 6;
pub const GST_CORE_ERROR_NEGOTIATION: c_int = 7;
pub const GST_CORE_ERROR_EVENT: c_int = 8;
pub const GST_CORE_ERROR_SEEK: c_int = 9;
pub const GST_CORE_ERROR_CAPS: c_int = 10;
pub const GST_CORE_ERROR_TAG: c_int = 11;
pub const GST_CORE_ERROR_MISSING_PLUGIN: c_int = 12;
pub const GST_CORE_ERROR_CLOCK: c_int = 13;
pub const GST_CORE_ERROR_DISABLED: c_int = 14;
pub const GST_CORE_ERROR_NUM_ERRORS: c_int = 15;
pub const GstCoreError = c_uint;
pub const GST_LIBRARY_ERROR_FAILED: c_int = 1;
pub const GST_LIBRARY_ERROR_TOO_LAZY: c_int = 2;
pub const GST_LIBRARY_ERROR_INIT: c_int = 3;
pub const GST_LIBRARY_ERROR_SHUTDOWN: c_int = 4;
pub const GST_LIBRARY_ERROR_SETTINGS: c_int = 5;
pub const GST_LIBRARY_ERROR_ENCODE: c_int = 6;
pub const GST_LIBRARY_ERROR_NUM_ERRORS: c_int = 7;
pub const GstLibraryError = c_uint;
pub const GST_RESOURCE_ERROR_FAILED: c_int = 1;
pub const GST_RESOURCE_ERROR_TOO_LAZY: c_int = 2;
pub const GST_RESOURCE_ERROR_NOT_FOUND: c_int = 3;
pub const GST_RESOURCE_ERROR_BUSY: c_int = 4;
pub const GST_RESOURCE_ERROR_OPEN_READ: c_int = 5;
pub const GST_RESOURCE_ERROR_OPEN_WRITE: c_int = 6;
pub const GST_RESOURCE_ERROR_OPEN_READ_WRITE: c_int = 7;
pub const GST_RESOURCE_ERROR_CLOSE: c_int = 8;
pub const GST_RESOURCE_ERROR_READ: c_int = 9;
pub const GST_RESOURCE_ERROR_WRITE: c_int = 10;
pub const GST_RESOURCE_ERROR_SEEK: c_int = 11;
pub const GST_RESOURCE_ERROR_SYNC: c_int = 12;
pub const GST_RESOURCE_ERROR_SETTINGS: c_int = 13;
pub const GST_RESOURCE_ERROR_NO_SPACE_LEFT: c_int = 14;
pub const GST_RESOURCE_ERROR_NOT_AUTHORIZED: c_int = 15;
pub const GST_RESOURCE_ERROR_NUM_ERRORS: c_int = 16;
pub const GstResourceError = c_uint;
pub const GST_STREAM_ERROR_FAILED: c_int = 1;
pub const GST_STREAM_ERROR_TOO_LAZY: c_int = 2;
pub const GST_STREAM_ERROR_NOT_IMPLEMENTED: c_int = 3;
pub const GST_STREAM_ERROR_TYPE_NOT_FOUND: c_int = 4;
pub const GST_STREAM_ERROR_WRONG_TYPE: c_int = 5;
pub const GST_STREAM_ERROR_CODEC_NOT_FOUND: c_int = 6;
pub const GST_STREAM_ERROR_DECODE: c_int = 7;
pub const GST_STREAM_ERROR_ENCODE: c_int = 8;
pub const GST_STREAM_ERROR_DEMUX: c_int = 9;
pub const GST_STREAM_ERROR_MUX: c_int = 10;
pub const GST_STREAM_ERROR_FORMAT: c_int = 11;
pub const GST_STREAM_ERROR_DECRYPT: c_int = 12;
pub const GST_STREAM_ERROR_DECRYPT_NOKEY: c_int = 13;
pub const GST_STREAM_ERROR_NUM_ERRORS: c_int = 14;
pub const GstStreamError = c_uint;
pub extern fn gst_error_get_message(domain: GQuark, code: gint) [*c]gchar;
pub extern fn gst_stream_error_quark() GQuark;
pub extern fn gst_core_error_quark() GQuark;
pub extern fn gst_resource_error_quark() GQuark;
pub extern fn gst_library_error_quark() GQuark;
pub const struct__GstProxyPadPrivate = opaque {};
pub const GstProxyPadPrivate = struct__GstProxyPadPrivate;
pub const struct__GstProxyPad = extern struct {
    pad: GstPad,
    priv: ?*GstProxyPadPrivate,
};
pub const GstProxyPad = struct__GstProxyPad;
pub const struct__GstProxyPadClass = extern struct {
    parent_class: GstPadClass,
    _gst_reserved: [1]gpointer,
};
pub const GstProxyPadClass = struct__GstProxyPadClass;
pub extern fn gst_proxy_pad_get_type() GType;
pub extern fn gst_proxy_pad_get_internal(pad: ?*GstProxyPad) ?*GstProxyPad;
pub extern fn gst_proxy_pad_iterate_internal_links_default(pad: ?*GstPad, parent: [*c]GstObject) [*c]GstIterator;
pub extern fn gst_proxy_pad_chain_default(pad: ?*GstPad, parent: [*c]GstObject, buffer: [*c]GstBuffer) GstFlowReturn;
pub extern fn gst_proxy_pad_chain_list_default(pad: ?*GstPad, parent: [*c]GstObject, list: ?*GstBufferList) GstFlowReturn;
pub extern fn gst_proxy_pad_getrange_default(pad: ?*GstPad, parent: [*c]GstObject, offset: guint64, size: guint, buffer: [*c][*c]GstBuffer) GstFlowReturn;
pub const struct__GstGhostPadPrivate = opaque {};
pub const GstGhostPadPrivate = struct__GstGhostPadPrivate;
pub const struct__GstGhostPad = extern struct {
    pad: GstProxyPad,
    priv: ?*GstGhostPadPrivate,
};
pub const GstGhostPad = struct__GstGhostPad;
pub const struct__GstGhostPadClass = extern struct {
    parent_class: GstProxyPadClass,
    _gst_reserved: [4]gpointer,
};
pub const GstGhostPadClass = struct__GstGhostPadClass;
pub extern fn gst_ghost_pad_get_type() GType;
pub extern fn gst_ghost_pad_new(name: [*c]const gchar, target: ?*GstPad) ?*GstPad;
pub extern fn gst_ghost_pad_new_no_target(name: [*c]const gchar, dir: GstPadDirection) ?*GstPad;
pub extern fn gst_ghost_pad_new_from_template(name: [*c]const gchar, target: ?*GstPad, templ: [*c]GstPadTemplate) ?*GstPad;
pub extern fn gst_ghost_pad_new_no_target_from_template(name: [*c]const gchar, templ: [*c]GstPadTemplate) ?*GstPad;
pub extern fn gst_ghost_pad_get_target(gpad: ?*GstGhostPad) ?*GstPad;
pub extern fn gst_ghost_pad_set_target(gpad: ?*GstGhostPad, newtarget: ?*GstPad) gboolean;
pub extern fn gst_ghost_pad_construct(gpad: ?*GstGhostPad) gboolean;
pub extern fn gst_ghost_pad_activate_mode_default(pad: ?*GstPad, parent: [*c]GstObject, mode: GstPadMode, active: gboolean) gboolean;
pub extern fn gst_ghost_pad_internal_activate_mode_default(pad: ?*GstPad, parent: [*c]GstObject, mode: GstPadMode, active: gboolean) gboolean;
pub const GstGhostPad_autoptr = ?*GstGhostPad;
pub const GstGhostPad_listautoptr = [*c]GList;
pub const GstGhostPad_slistautoptr = [*c]GSList;
pub const GstGhostPad_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstGhostPad(arg__ptr: ?*GstGhostPad) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstGhostPad(arg__ptr: [*c]?*GstGhostPad) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstGhostPad(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstGhostPad(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstGhostPad(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstGhostPad(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub const GstProxyPad_autoptr = ?*GstProxyPad;
pub const GstProxyPad_listautoptr = [*c]GList;
pub const GstProxyPad_slistautoptr = [*c]GSList;
pub const GstProxyPad_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstProxyPad(arg__ptr: ?*GstProxyPad) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstProxyPad(arg__ptr: [*c]?*GstProxyPad) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstProxyPad(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstProxyPad(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstProxyPad(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstProxyPad(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub const GST_LEVEL_NONE: c_int = 0;
pub const GST_LEVEL_ERROR: c_int = 1;
pub const GST_LEVEL_WARNING: c_int = 2;
pub const GST_LEVEL_FIXME: c_int = 3;
pub const GST_LEVEL_INFO: c_int = 4;
pub const GST_LEVEL_DEBUG: c_int = 5;
pub const GST_LEVEL_LOG: c_int = 6;
pub const GST_LEVEL_TRACE: c_int = 7;
pub const GST_LEVEL_MEMDUMP: c_int = 9;
pub const GST_LEVEL_COUNT: c_int = 10;
pub const GstDebugLevel = c_uint;
pub const GST_DEBUG_FG_BLACK: c_int = 0;
pub const GST_DEBUG_FG_RED: c_int = 1;
pub const GST_DEBUG_FG_GREEN: c_int = 2;
pub const GST_DEBUG_FG_YELLOW: c_int = 3;
pub const GST_DEBUG_FG_BLUE: c_int = 4;
pub const GST_DEBUG_FG_MAGENTA: c_int = 5;
pub const GST_DEBUG_FG_CYAN: c_int = 6;
pub const GST_DEBUG_FG_WHITE: c_int = 7;
pub const GST_DEBUG_BG_BLACK: c_int = 0;
pub const GST_DEBUG_BG_RED: c_int = 16;
pub const GST_DEBUG_BG_GREEN: c_int = 32;
pub const GST_DEBUG_BG_YELLOW: c_int = 48;
pub const GST_DEBUG_BG_BLUE: c_int = 64;
pub const GST_DEBUG_BG_MAGENTA: c_int = 80;
pub const GST_DEBUG_BG_CYAN: c_int = 96;
pub const GST_DEBUG_BG_WHITE: c_int = 112;
pub const GST_DEBUG_BOLD: c_int = 256;
pub const GST_DEBUG_UNDERLINE: c_int = 512;
pub const GstDebugColorFlags = c_uint;
pub const GST_STACK_TRACE_SHOW_NONE: c_int = 0;
pub const GST_STACK_TRACE_SHOW_FULL: c_int = 1;
pub const GstStackTraceFlags = c_uint;
pub const GST_DEBUG_COLOR_MODE_OFF: c_int = 0;
pub const GST_DEBUG_COLOR_MODE_ON: c_int = 1;
pub const GST_DEBUG_COLOR_MODE_UNIX: c_int = 2;
pub const GstDebugColorMode = c_uint;
pub const struct__GstDebugCategory = extern struct {
    threshold: gint,
    color: guint,
    name: [*c]const gchar,
    description: [*c]const gchar,
};
pub const GstDebugCategory = struct__GstDebugCategory;
pub const struct__GstDebugMessage = opaque {};
pub const GstDebugMessage = struct__GstDebugMessage;
pub const GstLogFunction = ?fn ([*c]GstDebugCategory, GstDebugLevel, [*c]const gchar, [*c]const gchar, gint, [*c]GObject, ?*GstDebugMessage, gpointer) callconv(.C) void;
pub extern fn gst_debug_log(category: [*c]GstDebugCategory, level: GstDebugLevel, file: [*c]const gchar, function: [*c]const gchar, line: gint, object: [*c]GObject, format: [*c]const gchar, ...) void;
pub extern fn gst_debug_log_valist(category: [*c]GstDebugCategory, level: GstDebugLevel, file: [*c]const gchar, function: [*c]const gchar, line: gint, object: [*c]GObject, format: [*c]const gchar, args: va_list) void;
pub extern fn gst_debug_log_literal(category: [*c]GstDebugCategory, level: GstDebugLevel, file: [*c]const gchar, function: [*c]const gchar, line: gint, object: [*c]GObject, message_string: [*c]const gchar) void;
pub extern fn _gst_debug_category_new(name: [*c]const gchar, color: guint, description: [*c]const gchar) [*c]GstDebugCategory;
pub extern fn _gst_debug_get_category(name: [*c]const gchar) [*c]GstDebugCategory;
pub extern fn _gst_debug_dump_mem(cat: [*c]GstDebugCategory, file: [*c]const gchar, func: [*c]const gchar, line: gint, obj: [*c]GObject, msg: [*c]const gchar, data: [*c]const guint8, length: guint) void;
pub const GstDebugFuncPtr = ?fn () callconv(.C) void;
pub extern fn _gst_debug_register_funcptr(func: GstDebugFuncPtr, ptrname: [*c]const gchar) void;
pub extern fn _gst_debug_nameof_funcptr(func: GstDebugFuncPtr) [*c]const gchar;
pub extern fn gst_debug_message_get(message: ?*GstDebugMessage) [*c]const gchar;
pub extern fn gst_debug_log_get_line(category: [*c]GstDebugCategory, level: GstDebugLevel, file: [*c]const gchar, function: [*c]const gchar, line: gint, object: [*c]GObject, message: ?*GstDebugMessage) [*c]gchar;
pub extern fn gst_debug_log_default(category: [*c]GstDebugCategory, level: GstDebugLevel, file: [*c]const gchar, function: [*c]const gchar, line: gint, object: [*c]GObject, message: ?*GstDebugMessage, user_data: gpointer) void;
pub extern fn gst_debug_level_get_name(level: GstDebugLevel) [*c]const gchar;
pub extern fn gst_debug_add_log_function(func: GstLogFunction, user_data: gpointer, notify: GDestroyNotify) void;
pub extern fn gst_debug_remove_log_function(func: GstLogFunction) guint;
pub extern fn gst_debug_remove_log_function_by_data(data: gpointer) guint;
pub extern fn gst_debug_set_active(active: gboolean) void;
pub extern fn gst_debug_is_active() gboolean;
pub extern fn gst_debug_set_colored(colored: gboolean) void;
pub extern fn gst_debug_set_color_mode(mode: GstDebugColorMode) void;
pub extern fn gst_debug_set_color_mode_from_string(mode: [*c]const gchar) void;
pub extern fn gst_debug_is_colored() gboolean;
pub extern fn gst_debug_get_color_mode() GstDebugColorMode;
pub extern fn gst_debug_set_default_threshold(level: GstDebugLevel) void;
pub extern fn gst_debug_get_default_threshold() GstDebugLevel;
pub extern fn gst_debug_set_threshold_for_name(name: [*c]const gchar, level: GstDebugLevel) void;
pub extern fn gst_debug_set_threshold_from_string(list: [*c]const gchar, reset: gboolean) void;
pub extern fn gst_debug_unset_threshold_for_name(name: [*c]const gchar) void;
pub extern fn gst_debug_category_free(category: [*c]GstDebugCategory) void;
pub extern fn gst_debug_category_set_threshold(category: [*c]GstDebugCategory, level: GstDebugLevel) void;
pub extern fn gst_debug_category_reset_threshold(category: [*c]GstDebugCategory) void;
pub extern fn gst_debug_category_get_threshold(category: [*c]GstDebugCategory) GstDebugLevel;
pub extern fn gst_debug_category_get_name(category: [*c]GstDebugCategory) [*c]const gchar;
pub extern fn gst_debug_category_get_color(category: [*c]GstDebugCategory) guint;
pub extern fn gst_debug_category_get_description(category: [*c]GstDebugCategory) [*c]const gchar;
pub extern fn gst_debug_get_all_categories() [*c]GSList;
pub extern fn gst_debug_construct_term_color(colorinfo: guint) [*c]gchar;
pub extern fn gst_debug_construct_win_color(colorinfo: guint) gint;
pub extern fn gst_info_vasprintf(result: [*c][*c]gchar, format: [*c]const gchar, args: va_list) gint;
pub extern fn gst_info_strdup_vprintf(format: [*c]const gchar, args: va_list) [*c]gchar;
pub extern fn gst_info_strdup_printf(format: [*c]const gchar, ...) [*c]gchar;
pub extern fn gst_print(format: [*c]const gchar, ...) void;
pub extern fn gst_println(format: [*c]const gchar, ...) void;
pub extern fn gst_printerr(format: [*c]const gchar, ...) void;
pub extern fn gst_printerrln(format: [*c]const gchar, ...) void;
pub extern var GST_CAT_DEFAULT: [*c]GstDebugCategory;
pub extern var _gst_debug_enabled: gboolean;
pub extern var _gst_debug_min: GstDebugLevel;
pub extern fn gst_debug_print_stack_trace() void;
pub extern fn gst_debug_get_stack_trace(flags: GstStackTraceFlags) [*c]gchar;
pub extern fn gst_debug_add_ring_buffer_logger(max_size_per_thread: guint, thread_timeout: guint) void;
pub extern fn gst_debug_remove_ring_buffer_logger() void;
pub extern fn gst_debug_ring_buffer_logger_get_logs() [*c][*c]gchar;
pub extern var _gst_int_range_type: GType;
pub extern var _gst_int64_range_type: GType;
pub extern var _gst_double_range_type: GType;
pub extern var _gst_fraction_range_type: GType;
pub extern var _gst_value_list_type: GType;
pub extern var _gst_value_array_type: GType;
pub extern var _gst_fraction_type: GType;
pub extern var _gst_bitmask_type: GType;
pub extern var _gst_flagset_type: GType;
pub const GstValueCompareFunc = ?fn ([*c]const GValue, [*c]const GValue) callconv(.C) gint;
pub const GstValueSerializeFunc = ?fn ([*c]const GValue) callconv(.C) [*c]gchar;
pub const GstValueDeserializeFunc = ?fn ([*c]GValue, [*c]const gchar) callconv(.C) gboolean;
pub const GstValueDeserializeWithPSpecFunc = ?fn ([*c]GValue, [*c]const gchar, [*c]GParamSpec) callconv(.C) gboolean;
pub const struct__GstValueTable = extern struct {
    type: GType,
    compare: GstValueCompareFunc,
    serialize: GstValueSerializeFunc,
    deserialize: GstValueDeserializeFunc,
    deserialize_with_pspec: GstValueDeserializeWithPSpecFunc,
    _gst_reserved: [3]gpointer,
};
pub const GstValueTable = struct__GstValueTable;
pub extern fn gst_int_range_get_type() GType;
pub extern fn gst_int64_range_get_type() GType;
pub extern fn gst_double_range_get_type() GType;
pub extern fn gst_fraction_range_get_type() GType;
pub extern fn gst_fraction_get_type() GType;
pub extern fn gst_value_list_get_type() GType;
pub extern fn gst_value_array_get_type() GType;
pub extern fn gst_bitmask_get_type() GType;
pub extern fn gst_flagset_get_type() GType;
pub extern fn gst_g_thread_get_type() GType;
pub extern fn gst_value_register(table: [*c]const GstValueTable) void;
pub extern fn gst_value_init_and_copy(dest: [*c]GValue, src: [*c]const GValue) void;
pub extern fn gst_value_serialize(value: [*c]const GValue) [*c]gchar;
pub extern fn gst_value_deserialize(dest: [*c]GValue, src: [*c]const gchar) gboolean;
pub extern fn gst_value_deserialize_with_pspec(dest: [*c]GValue, src: [*c]const gchar, pspec: [*c]GParamSpec) gboolean;
pub extern fn gst_value_list_append_value(value: [*c]GValue, append_value: [*c]const GValue) void;
pub extern fn gst_value_list_append_and_take_value(value: [*c]GValue, append_value: [*c]GValue) void;
pub extern fn gst_value_list_prepend_value(value: [*c]GValue, prepend_value: [*c]const GValue) void;
pub extern fn gst_value_list_concat(dest: [*c]GValue, value1: [*c]const GValue, value2: [*c]const GValue) void;
pub extern fn gst_value_list_merge(dest: [*c]GValue, value1: [*c]const GValue, value2: [*c]const GValue) void;
pub extern fn gst_value_list_get_size(value: [*c]const GValue) guint;
pub extern fn gst_value_list_get_value(value: [*c]const GValue, index: guint) [*c]const GValue;
pub extern fn gst_value_list_init(value: [*c]GValue, prealloc: guint) [*c]GValue;
pub extern fn gst_value_array_append_value(value: [*c]GValue, append_value: [*c]const GValue) void;
pub extern fn gst_value_array_append_and_take_value(value: [*c]GValue, append_value: [*c]GValue) void;
pub extern fn gst_value_array_prepend_value(value: [*c]GValue, prepend_value: [*c]const GValue) void;
pub extern fn gst_value_array_get_size(value: [*c]const GValue) guint;
pub extern fn gst_value_array_get_value(value: [*c]const GValue, index: guint) [*c]const GValue;
pub extern fn gst_value_array_init(value: [*c]GValue, prealloc: guint) [*c]GValue;
pub extern fn gst_value_set_int_range(value: [*c]GValue, start: gint, end: gint) void;
pub extern fn gst_value_set_int_range_step(value: [*c]GValue, start: gint, end: gint, step: gint) void;
pub extern fn gst_value_get_int_range_min(value: [*c]const GValue) gint;
pub extern fn gst_value_get_int_range_max(value: [*c]const GValue) gint;
pub extern fn gst_value_get_int_range_step(value: [*c]const GValue) gint;
pub extern fn gst_value_set_int64_range(value: [*c]GValue, start: gint64, end: gint64) void;
pub extern fn gst_value_set_int64_range_step(value: [*c]GValue, start: gint64, end: gint64, step: gint64) void;
pub extern fn gst_value_get_int64_range_min(value: [*c]const GValue) gint64;
pub extern fn gst_value_get_int64_range_max(value: [*c]const GValue) gint64;
pub extern fn gst_value_get_int64_range_step(value: [*c]const GValue) gint64;
pub extern fn gst_value_set_double_range(value: [*c]GValue, start: gdouble, end: gdouble) void;
pub extern fn gst_value_get_double_range_min(value: [*c]const GValue) gdouble;
pub extern fn gst_value_get_double_range_max(value: [*c]const GValue) gdouble;
pub extern fn gst_value_get_caps(value: [*c]const GValue) [*c]const GstCaps;
pub extern fn gst_value_set_caps(value: [*c]GValue, caps: [*c]const GstCaps) void;
pub extern fn gst_value_get_structure(value: [*c]const GValue) [*c]const GstStructure;
pub extern fn gst_value_set_structure(value: [*c]GValue, structure: [*c]const GstStructure) void;
pub extern fn gst_value_get_caps_features(value: [*c]const GValue) ?*const GstCapsFeatures;
pub extern fn gst_value_set_caps_features(value: [*c]GValue, features: ?*const GstCapsFeatures) void;
pub extern fn gst_value_set_fraction(value: [*c]GValue, numerator: gint, denominator: gint) void;
pub extern fn gst_value_get_fraction_numerator(value: [*c]const GValue) gint;
pub extern fn gst_value_get_fraction_denominator(value: [*c]const GValue) gint;
pub extern fn gst_value_fraction_multiply(product: [*c]GValue, factor1: [*c]const GValue, factor2: [*c]const GValue) gboolean;
pub extern fn gst_value_fraction_subtract(dest: [*c]GValue, minuend: [*c]const GValue, subtrahend: [*c]const GValue) gboolean;
pub extern fn gst_value_set_fraction_range(value: [*c]GValue, start: [*c]const GValue, end: [*c]const GValue) void;
pub extern fn gst_value_set_fraction_range_full(value: [*c]GValue, numerator_start: gint, denominator_start: gint, numerator_end: gint, denominator_end: gint) void;
pub extern fn gst_value_get_fraction_range_min(value: [*c]const GValue) [*c]const GValue;
pub extern fn gst_value_get_fraction_range_max(value: [*c]const GValue) [*c]const GValue;
pub extern fn gst_value_get_bitmask(value: [*c]const GValue) guint64;
pub extern fn gst_value_set_bitmask(value: [*c]GValue, bitmask: guint64) void;
pub extern fn gst_value_set_flagset(value: [*c]GValue, flags: guint, mask: guint) void;
pub extern fn gst_value_get_flagset_flags(value: [*c]const GValue) guint;
pub extern fn gst_value_get_flagset_mask(value: [*c]const GValue) guint;
pub extern fn gst_value_compare(value1: [*c]const GValue, value2: [*c]const GValue) gint;
pub extern fn gst_value_can_compare(value1: [*c]const GValue, value2: [*c]const GValue) gboolean;
pub extern fn gst_value_is_subset(value1: [*c]const GValue, value2: [*c]const GValue) gboolean;
pub extern fn gst_value_union(dest: [*c]GValue, value1: [*c]const GValue, value2: [*c]const GValue) gboolean;
pub extern fn gst_value_can_union(value1: [*c]const GValue, value2: [*c]const GValue) gboolean;
pub extern fn gst_value_intersect(dest: [*c]GValue, value1: [*c]const GValue, value2: [*c]const GValue) gboolean;
pub extern fn gst_value_can_intersect(value1: [*c]const GValue, value2: [*c]const GValue) gboolean;
pub extern fn gst_value_subtract(dest: [*c]GValue, minuend: [*c]const GValue, subtrahend: [*c]const GValue) gboolean;
pub extern fn gst_value_can_subtract(minuend: [*c]const GValue, subtrahend: [*c]const GValue) gboolean;
pub extern fn gst_value_is_fixed(value: [*c]const GValue) gboolean;
pub extern fn gst_value_fixate(dest: [*c]GValue, src: [*c]const GValue) gboolean;
pub extern fn gst_flagset_register(flags_type: GType) GType;
pub extern fn gst_param_spec_fraction_get_type() GType;
pub extern fn gst_param_spec_array_get_type() GType;
pub const struct__GstParamSpecFraction = extern struct {
    parent_instance: GParamSpec,
    min_num: gint,
    min_den: gint,
    max_num: gint,
    max_den: gint,
    def_num: gint,
    def_den: gint,
};
pub const GstParamSpecFraction = struct__GstParamSpecFraction;
pub const struct__GstParamSpecArray = extern struct {
    parent_instance: GParamSpec,
    element_spec: [*c]GParamSpec,
};
pub const GstParamSpecArray = struct__GstParamSpecArray;
pub extern fn gst_param_spec_fraction(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, min_num: gint, min_denom: gint, max_num: gint, max_denom: gint, default_num: gint, default_denom: gint, flags: GParamFlags) [*c]GParamSpec;
pub extern fn gst_param_spec_array(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, element_spec: [*c]GParamSpec, flags: GParamFlags) [*c]GParamSpec;
pub const struct__GstPipelinePrivate = opaque {};
pub const GstPipelinePrivate = struct__GstPipelinePrivate;
pub const struct__GstPipeline = extern struct {
    bin: GstBin,
    fixed_clock: [*c]GstClock,
    stream_time: GstClockTime,
    delay: GstClockTime,
    priv: ?*GstPipelinePrivate,
    _gst_reserved: [4]gpointer,
};
pub const GstPipeline = struct__GstPipeline;
pub const struct__GstPipelineClass = extern struct {
    parent_class: GstBinClass,
    _gst_reserved: [4]gpointer,
};
pub const GstPipelineClass = struct__GstPipelineClass;
pub const GST_PIPELINE_FLAG_FIXED_CLOCK: c_int = 524288;
pub const GST_PIPELINE_FLAG_LAST: c_int = 8388608;
pub const GstPipelineFlags = c_uint;
pub extern fn gst_pipeline_get_type() GType;
pub extern fn gst_pipeline_new(name: [*c]const gchar) [*c]GstElement;
pub extern fn gst_pipeline_get_bus(pipeline: [*c]GstPipeline) [*c]GstBus;
pub extern fn gst_pipeline_use_clock(pipeline: [*c]GstPipeline, clock: [*c]GstClock) void;
pub extern fn gst_pipeline_set_clock(pipeline: [*c]GstPipeline, clock: [*c]GstClock) gboolean;
pub extern fn gst_pipeline_get_clock(pipeline: [*c]GstPipeline) [*c]GstClock;
pub extern fn gst_pipeline_get_pipeline_clock(pipeline: [*c]GstPipeline) [*c]GstClock;
pub extern fn gst_pipeline_auto_clock(pipeline: [*c]GstPipeline) void;
pub extern fn gst_pipeline_set_delay(pipeline: [*c]GstPipeline, delay: GstClockTime) void;
pub extern fn gst_pipeline_get_delay(pipeline: [*c]GstPipeline) GstClockTime;
pub extern fn gst_pipeline_set_latency(pipeline: [*c]GstPipeline, latency: GstClockTime) void;
pub extern fn gst_pipeline_get_latency(pipeline: [*c]GstPipeline) GstClockTime;
pub extern fn gst_pipeline_set_auto_flush_bus(pipeline: [*c]GstPipeline, auto_flush: gboolean) void;
pub extern fn gst_pipeline_get_auto_flush_bus(pipeline: [*c]GstPipeline) gboolean;
pub const GstPipeline_autoptr = [*c]GstPipeline;
pub const GstPipeline_listautoptr = [*c]GList;
pub const GstPipeline_slistautoptr = [*c]GSList;
pub const GstPipeline_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstPipeline(arg__ptr: [*c]GstPipeline) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstPipeline(arg__ptr: [*c][*c]GstPipeline) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstPipeline(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstPipeline(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstPipeline(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstPipeline(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub const struct__GstPoll = opaque {};
pub const GstPoll = struct__GstPoll;
pub const GstPollFD = extern struct {
    fd: c_int,
    idx: gint,
};
pub extern fn gst_poll_new(controllable: gboolean) ?*GstPoll;
pub extern fn gst_poll_new_timer() ?*GstPoll;
pub extern fn gst_poll_free(set: ?*GstPoll) void;
pub extern fn gst_poll_get_read_gpollfd(set: ?*GstPoll, fd: [*c]GPollFD) void;
pub extern fn gst_poll_fd_init(fd: [*c]GstPollFD) void;
pub extern fn gst_poll_add_fd(set: ?*GstPoll, fd: [*c]GstPollFD) gboolean;
pub extern fn gst_poll_remove_fd(set: ?*GstPoll, fd: [*c]GstPollFD) gboolean;
pub extern fn gst_poll_fd_ctl_write(set: ?*GstPoll, fd: [*c]GstPollFD, active: gboolean) gboolean;
pub extern fn gst_poll_fd_ctl_read(set: ?*GstPoll, fd: [*c]GstPollFD, active: gboolean) gboolean;
pub extern fn gst_poll_fd_ctl_pri(set: ?*GstPoll, fd: [*c]GstPollFD, active: gboolean) gboolean;
pub extern fn gst_poll_fd_ignored(set: ?*GstPoll, fd: [*c]GstPollFD) void;
pub extern fn gst_poll_fd_has_closed(set: ?*const GstPoll, fd: [*c]GstPollFD) gboolean;
pub extern fn gst_poll_fd_has_error(set: ?*const GstPoll, fd: [*c]GstPollFD) gboolean;
pub extern fn gst_poll_fd_can_read(set: ?*const GstPoll, fd: [*c]GstPollFD) gboolean;
pub extern fn gst_poll_fd_can_write(set: ?*const GstPoll, fd: [*c]GstPollFD) gboolean;
pub extern fn gst_poll_fd_has_pri(set: ?*const GstPoll, fd: [*c]GstPollFD) gboolean;
pub extern fn gst_poll_wait(set: ?*GstPoll, timeout: GstClockTime) gint;
pub extern fn gst_poll_set_controllable(set: ?*GstPoll, controllable: gboolean) gboolean;
pub extern fn gst_poll_restart(set: ?*GstPoll) void;
pub extern fn gst_poll_set_flushing(set: ?*GstPoll, flushing: gboolean) void;
pub extern fn gst_poll_write_control(set: ?*GstPoll) gboolean;
pub extern fn gst_poll_read_control(set: ?*GstPoll) gboolean;
pub const struct__GstPreset = opaque {};
pub const GstPreset = struct__GstPreset;
pub const struct__GstPresetInterface = extern struct {
    parent: GTypeInterface,
    get_preset_names: ?fn (?*GstPreset) callconv(.C) [*c][*c]gchar,
    get_property_names: ?fn (?*GstPreset) callconv(.C) [*c][*c]gchar,
    load_preset: ?fn (?*GstPreset, [*c]const gchar) callconv(.C) gboolean,
    save_preset: ?fn (?*GstPreset, [*c]const gchar) callconv(.C) gboolean,
    rename_preset: ?fn (?*GstPreset, [*c]const gchar, [*c]const gchar) callconv(.C) gboolean,
    delete_preset: ?fn (?*GstPreset, [*c]const gchar) callconv(.C) gboolean,
    set_meta: ?fn (?*GstPreset, [*c]const gchar, [*c]const gchar, [*c]const gchar) callconv(.C) gboolean,
    get_meta: ?fn (?*GstPreset, [*c]const gchar, [*c]const gchar, [*c][*c]gchar) callconv(.C) gboolean,
    _gst_reserved: [4]gpointer,
};
pub const GstPresetInterface = struct__GstPresetInterface;
pub extern fn gst_preset_get_type() GType;
pub extern fn gst_preset_get_preset_names(preset: ?*GstPreset) [*c][*c]gchar;
pub extern fn gst_preset_get_property_names(preset: ?*GstPreset) [*c][*c]gchar;
pub extern fn gst_preset_load_preset(preset: ?*GstPreset, name: [*c]const gchar) gboolean;
pub extern fn gst_preset_save_preset(preset: ?*GstPreset, name: [*c]const gchar) gboolean;
pub extern fn gst_preset_rename_preset(preset: ?*GstPreset, old_name: [*c]const gchar, new_name: [*c]const gchar) gboolean;
pub extern fn gst_preset_delete_preset(preset: ?*GstPreset, name: [*c]const gchar) gboolean;
pub extern fn gst_preset_set_meta(preset: ?*GstPreset, name: [*c]const gchar, tag: [*c]const gchar, value: [*c]const gchar) gboolean;
pub extern fn gst_preset_get_meta(preset: ?*GstPreset, name: [*c]const gchar, tag: [*c]const gchar, value: [*c][*c]gchar) gboolean;
pub extern fn gst_preset_set_app_dir(app_dir: [*c]const gchar) gboolean;
pub extern fn gst_preset_get_app_dir() [*c]const gchar;
pub extern fn gst_preset_is_editable(preset: ?*GstPreset) gboolean;
pub const struct__GstProtectionMeta = extern struct {
    meta: GstMeta,
    info: [*c]GstStructure,
};
pub const GstProtectionMeta = struct__GstProtectionMeta;
pub extern fn gst_protection_meta_api_get_type() GType;
pub extern fn gst_protection_meta_get_info() [*c]const GstMetaInfo;
pub extern fn gst_buffer_add_protection_meta(buffer: [*c]GstBuffer, info: [*c]GstStructure) [*c]GstProtectionMeta;
pub extern fn gst_protection_select_system(system_identifiers: [*c][*c]const gchar) [*c]const gchar;
pub extern fn gst_protection_filter_systems_by_available_decryptors(system_identifiers: [*c][*c]const gchar) [*c][*c]gchar;
pub const struct__GstRegistryPrivate = opaque {};
pub const GstRegistryPrivate = struct__GstRegistryPrivate;
pub const struct__GstRegistry = extern struct {
    object: GstObject,
    priv: ?*GstRegistryPrivate,
};
pub const GstRegistry = struct__GstRegistry;
pub const struct__GstRegistryClass = extern struct {
    parent_class: GstObjectClass,
};
pub const GstRegistryClass = struct__GstRegistryClass;
pub extern fn gst_registry_get_type() GType;
pub extern fn gst_registry_get() [*c]GstRegistry;
pub extern fn gst_registry_scan_path(registry: [*c]GstRegistry, path: [*c]const gchar) gboolean;
pub extern fn gst_registry_add_plugin(registry: [*c]GstRegistry, plugin: ?*GstPlugin) gboolean;
pub extern fn gst_registry_remove_plugin(registry: [*c]GstRegistry, plugin: ?*GstPlugin) void;
pub extern fn gst_registry_add_feature(registry: [*c]GstRegistry, feature: ?*GstPluginFeature) gboolean;
pub extern fn gst_registry_remove_feature(registry: [*c]GstRegistry, feature: ?*GstPluginFeature) void;
pub extern fn gst_registry_get_plugin_list(registry: [*c]GstRegistry) [*c]GList;
pub extern fn gst_registry_plugin_filter(registry: [*c]GstRegistry, filter: GstPluginFilter, first: gboolean, user_data: gpointer) [*c]GList;
pub extern fn gst_registry_feature_filter(registry: [*c]GstRegistry, filter: GstPluginFeatureFilter, first: gboolean, user_data: gpointer) [*c]GList;
pub extern fn gst_registry_get_feature_list(registry: [*c]GstRegistry, @"type": GType) [*c]GList;
pub extern fn gst_registry_get_feature_list_by_plugin(registry: [*c]GstRegistry, name: [*c]const gchar) [*c]GList;
pub extern fn gst_registry_get_feature_list_cookie(registry: [*c]GstRegistry) guint32;
pub extern fn gst_registry_find_plugin(registry: [*c]GstRegistry, name: [*c]const gchar) ?*GstPlugin;
pub extern fn gst_registry_find_feature(registry: [*c]GstRegistry, name: [*c]const gchar, @"type": GType) ?*GstPluginFeature;
pub extern fn gst_registry_lookup(registry: [*c]GstRegistry, filename: [*c]const u8) ?*GstPlugin;
pub extern fn gst_registry_lookup_feature(registry: [*c]GstRegistry, name: [*c]const u8) ?*GstPluginFeature;
pub extern fn gst_registry_check_feature_version(registry: [*c]GstRegistry, feature_name: [*c]const gchar, min_major: guint, min_minor: guint, min_micro: guint) gboolean;
pub const GstRegistry_autoptr = [*c]GstRegistry;
pub const GstRegistry_listautoptr = [*c]GList;
pub const GstRegistry_slistautoptr = [*c]GSList;
pub const GstRegistry_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstRegistry(arg__ptr: [*c]GstRegistry) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstRegistry(arg__ptr: [*c][*c]GstRegistry) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstRegistry(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstRegistry(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstRegistry(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstRegistry(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub extern fn gst_promise_get_type() GType;
pub const struct__GstPromise = extern struct {
    parent: GstMiniObject,
};
pub const GstPromise = struct__GstPromise;
pub const GST_PROMISE_RESULT_PENDING: c_int = 0;
pub const GST_PROMISE_RESULT_INTERRUPTED: c_int = 1;
pub const GST_PROMISE_RESULT_REPLIED: c_int = 2;
pub const GST_PROMISE_RESULT_EXPIRED: c_int = 3;
pub const GstPromiseResult = c_uint;
pub const GstPromiseChangeFunc = ?fn ([*c]GstPromise, gpointer) callconv(.C) void;
pub extern fn gst_promise_new() [*c]GstPromise;
pub extern fn gst_promise_new_with_change_func(func: GstPromiseChangeFunc, user_data: gpointer, notify: GDestroyNotify) [*c]GstPromise;
pub extern fn gst_promise_wait(promise: [*c]GstPromise) GstPromiseResult;
pub extern fn gst_promise_reply(promise: [*c]GstPromise, s: [*c]GstStructure) void;
pub extern fn gst_promise_interrupt(promise: [*c]GstPromise) void;
pub extern fn gst_promise_expire(promise: [*c]GstPromise) void;
pub extern fn gst_promise_get_reply(promise: [*c]GstPromise) [*c]const GstStructure;
pub fn gst_promise_ref(arg_promise: [*c]GstPromise) callconv(.C) [*c]GstPromise {
    var promise = arg_promise;
    return @ptrCast([*c]GstPromise, @alignCast(@import("std").meta.alignment([*c]GstPromise), gst_mini_object_ref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), promise)))));
}
pub fn gst_promise_unref(arg_promise: [*c]GstPromise) callconv(.C) void {
    var promise = arg_promise;
    gst_mini_object_unref(@ptrCast([*c]GstMiniObject, @alignCast(@import("std").meta.alignment([*c]GstMiniObject), promise)));
}
pub const GstPromise_autoptr = [*c]GstPromise;
pub const GstPromise_listautoptr = [*c]GList;
pub const GstPromise_slistautoptr = [*c]GSList;
pub const GstPromise_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstPromise(arg__ptr: [*c]GstPromise) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_promise_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GstPromise(arg__ptr: [*c][*c]GstPromise) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstPromise(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstPromise(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_promise_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstPromise(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_promise_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstPromise(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_promise_unref)))));
    }
}
pub const struct__GstSystemClockPrivate = opaque {};
pub const GstSystemClockPrivate = struct__GstSystemClockPrivate;
pub const struct__GstSystemClock = extern struct {
    clock: GstClock,
    priv: ?*GstSystemClockPrivate,
    _gst_reserved: [4]gpointer,
};
pub const GstSystemClock = struct__GstSystemClock;
pub const struct__GstSystemClockClass = extern struct {
    parent_class: GstClockClass,
    _gst_reserved: [4]gpointer,
};
pub const GstSystemClockClass = struct__GstSystemClockClass;
pub const GST_CLOCK_TYPE_REALTIME: c_int = 0;
pub const GST_CLOCK_TYPE_MONOTONIC: c_int = 1;
pub const GST_CLOCK_TYPE_OTHER: c_int = 2;
pub const GST_CLOCK_TYPE_TAI: c_int = 3;
pub const GstClockType = c_uint;
pub extern fn gst_system_clock_get_type() GType;
pub extern fn gst_system_clock_obtain() [*c]GstClock;
pub extern fn gst_system_clock_set_default(new_clock: [*c]GstClock) void;
pub const GstSystemClock_autoptr = [*c]GstSystemClock;
pub const GstSystemClock_listautoptr = [*c]GList;
pub const GstSystemClock_slistautoptr = [*c]GSList;
pub const GstSystemClock_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstSystemClock(arg__ptr: [*c]GstSystemClock) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstSystemClock(arg__ptr: [*c][*c]GstSystemClock) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstSystemClock(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstSystemClock(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstSystemClock(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstSystemClock(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub const struct__GstTagSetter = opaque {};
pub const GstTagSetter = struct__GstTagSetter;
pub const struct__GstTagSetterInterface = extern struct {
    g_iface: GTypeInterface,
};
pub const GstTagSetterInterface = struct__GstTagSetterInterface;
pub extern fn gst_tag_setter_get_type() GType;
pub extern fn gst_tag_setter_reset_tags(setter: ?*GstTagSetter) void;
pub extern fn gst_tag_setter_merge_tags(setter: ?*GstTagSetter, list: [*c]const GstTagList, mode: GstTagMergeMode) void;
pub extern fn gst_tag_setter_add_tags(setter: ?*GstTagSetter, mode: GstTagMergeMode, tag: [*c]const gchar, ...) void;
pub extern fn gst_tag_setter_add_tag_values(setter: ?*GstTagSetter, mode: GstTagMergeMode, tag: [*c]const gchar, ...) void;
pub extern fn gst_tag_setter_add_tag_valist(setter: ?*GstTagSetter, mode: GstTagMergeMode, tag: [*c]const gchar, var_args: va_list) void;
pub extern fn gst_tag_setter_add_tag_valist_values(setter: ?*GstTagSetter, mode: GstTagMergeMode, tag: [*c]const gchar, var_args: va_list) void;
pub extern fn gst_tag_setter_add_tag_value(setter: ?*GstTagSetter, mode: GstTagMergeMode, tag: [*c]const gchar, value: [*c]const GValue) void;
pub extern fn gst_tag_setter_get_tag_list(setter: ?*GstTagSetter) [*c]const GstTagList;
pub extern fn gst_tag_setter_set_tag_merge_mode(setter: ?*GstTagSetter, mode: GstTagMergeMode) void;
pub extern fn gst_tag_setter_get_tag_merge_mode(setter: ?*GstTagSetter) GstTagMergeMode;
pub const struct__GstTocSetter = opaque {};
pub const GstTocSetter = struct__GstTocSetter;
pub const struct__GstTocSetterInterface = extern struct {
    g_iface: GTypeInterface,
};
pub const GstTocSetterInterface = struct__GstTocSetterInterface;
pub extern fn gst_toc_setter_get_type() GType;
pub extern fn gst_toc_setter_reset(setter: ?*GstTocSetter) void;
pub extern fn gst_toc_setter_get_toc(setter: ?*GstTocSetter) ?*GstToc;
pub extern fn gst_toc_setter_set_toc(setter: ?*GstTocSetter, toc: ?*GstToc) void;
pub const struct__GstTracerPrivate = opaque {};
pub const GstTracerPrivate = struct__GstTracerPrivate;
pub const struct__GstTracer = extern struct {
    parent: GstObject,
    priv: ?*GstTracerPrivate,
    _gst_reserved: [4]gpointer,
};
pub const GstTracer = struct__GstTracer;
pub const struct__GstTracerClass = extern struct {
    parent_class: GstObjectClass,
    _gst_reserved: [4]gpointer,
};
pub const GstTracerClass = struct__GstTracerClass;
pub extern fn gst_tracer_get_type() GType;
pub extern fn gst_tracing_register_hook(tracer: [*c]GstTracer, detail: [*c]const gchar, func: GCallback) void;
pub extern fn gst_tracer_register(plugin: ?*GstPlugin, name: [*c]const gchar, @"type": GType) gboolean;
pub extern fn gst_tracing_get_active_tracers() [*c]GList;
pub const GstTracer_autoptr = [*c]GstTracer;
pub const GstTracer_listautoptr = [*c]GList;
pub const GstTracer_slistautoptr = [*c]GSList;
pub const GstTracer_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstTracer(arg__ptr: [*c]GstTracer) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstTracer(arg__ptr: [*c][*c]GstTracer) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstTracer(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstTracer(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstTracer(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstTracer(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub const struct__GstTracerFactory = opaque {};
pub const GstTracerFactory = struct__GstTracerFactory;
pub const struct__GstTracerFactoryClass = opaque {};
pub const GstTracerFactoryClass = struct__GstTracerFactoryClass;
pub extern fn gst_tracer_factory_get_type() GType;
pub extern fn gst_tracer_factory_get_list() [*c]GList;
pub extern fn gst_tracer_factory_get_tracer_type(factory: ?*GstTracerFactory) GType;
pub const GstTracerFactory_autoptr = ?*GstTracerFactory;
pub const GstTracerFactory_listautoptr = [*c]GList;
pub const GstTracerFactory_slistautoptr = [*c]GSList;
pub const GstTracerFactory_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstTracerFactory(arg__ptr: ?*GstTracerFactory) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstTracerFactory(arg__ptr: [*c]?*GstTracerFactory) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstTracerFactory(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstTracerFactory(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstTracerFactory(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstTracerFactory(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub const struct__GstTracerRecord = opaque {};
pub const GstTracerRecord = struct__GstTracerRecord;
pub const struct__GstTracerRecordClass = opaque {};
pub const GstTracerRecordClass = struct__GstTracerRecordClass;
pub extern fn gst_tracer_record_get_type() GType;
pub const GstTracerRecord_autoptr = ?*GstTracerRecord;
pub const GstTracerRecord_listautoptr = [*c]GList;
pub const GstTracerRecord_slistautoptr = [*c]GSList;
pub const GstTracerRecord_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstTracerRecord(arg__ptr: ?*GstTracerRecord) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstTracerRecord(arg__ptr: [*c]?*GstTracerRecord) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstTracerRecord(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstTracerRecord(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstTracerRecord(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstTracerRecord(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub const GST_TRACER_VALUE_SCOPE_PROCESS: c_int = 0;
pub const GST_TRACER_VALUE_SCOPE_THREAD: c_int = 1;
pub const GST_TRACER_VALUE_SCOPE_ELEMENT: c_int = 2;
pub const GST_TRACER_VALUE_SCOPE_PAD: c_int = 3;
pub const GstTracerValueScope = c_uint;
pub const GST_TRACER_VALUE_FLAGS_NONE: c_int = 0;
pub const GST_TRACER_VALUE_FLAGS_OPTIONAL: c_int = 1;
pub const GST_TRACER_VALUE_FLAGS_AGGREGATED: c_int = 2;
pub const GstTracerValueFlags = c_uint;
pub extern fn gst_tracer_record_new(name: [*c]const gchar, firstfield: [*c]const gchar, ...) ?*GstTracerRecord;
pub extern fn gst_tracer_record_log(self: ?*GstTracerRecord, ...) void;
pub const struct__GstTypeFind = extern struct {
    peek: ?fn (gpointer, gint64, guint) callconv(.C) [*c]const guint8,
    suggest: ?fn (gpointer, guint, [*c]GstCaps) callconv(.C) void,
    data: gpointer,
    get_length: ?fn (gpointer) callconv(.C) guint64,
    _gst_reserved: [4]gpointer,
};
pub const GstTypeFind = struct__GstTypeFind;
pub const GstTypeFindFunction = ?fn ([*c]GstTypeFind, gpointer) callconv(.C) void;
pub const GST_TYPE_FIND_NONE: c_int = 0;
pub const GST_TYPE_FIND_MINIMUM: c_int = 1;
pub const GST_TYPE_FIND_POSSIBLE: c_int = 50;
pub const GST_TYPE_FIND_LIKELY: c_int = 80;
pub const GST_TYPE_FIND_NEARLY_CERTAIN: c_int = 99;
pub const GST_TYPE_FIND_MAXIMUM: c_int = 100;
pub const GstTypeFindProbability = c_uint;
pub extern fn gst_type_find_get_type() GType;
pub extern fn gst_type_find_peek(find: [*c]GstTypeFind, offset: gint64, size: guint) [*c]const guint8;
pub extern fn gst_type_find_suggest(find: [*c]GstTypeFind, probability: guint, caps: [*c]GstCaps) void;
pub extern fn gst_type_find_suggest_empty_simple(find: [*c]GstTypeFind, probability: guint, media_type: [*c]const u8) void;
pub extern fn gst_type_find_suggest_simple(find: [*c]GstTypeFind, probability: guint, media_type: [*c]const u8, fieldname: [*c]const u8, ...) void;
pub extern fn gst_type_find_get_length(find: [*c]GstTypeFind) guint64;
pub extern fn gst_type_find_register(plugin: ?*GstPlugin, name: [*c]const gchar, rank: guint, func: GstTypeFindFunction, extensions: [*c]const gchar, possible_caps: [*c]GstCaps, data: gpointer, data_notify: GDestroyNotify) gboolean;
pub const struct__GstTypeFindFactory = opaque {};
pub const GstTypeFindFactory = struct__GstTypeFindFactory;
pub const struct__GstTypeFindFactoryClass = opaque {};
pub const GstTypeFindFactoryClass = struct__GstTypeFindFactoryClass;
pub extern fn gst_type_find_factory_get_type() GType;
pub extern fn gst_type_find_factory_get_list() [*c]GList;
pub extern fn gst_type_find_factory_get_extensions(factory: ?*GstTypeFindFactory) [*c]const [*c]const gchar;
pub extern fn gst_type_find_factory_get_caps(factory: ?*GstTypeFindFactory) [*c]GstCaps;
pub extern fn gst_type_find_factory_has_function(factory: ?*GstTypeFindFactory) gboolean;
pub extern fn gst_type_find_factory_call_function(factory: ?*GstTypeFindFactory, find: [*c]GstTypeFind) void;
pub const GstTypeFindFactory_autoptr = ?*GstTypeFindFactory;
pub const GstTypeFindFactory_listautoptr = [*c]GList;
pub const GstTypeFindFactory_slistautoptr = [*c]GSList;
pub const GstTypeFindFactory_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstTypeFindFactory(arg__ptr: ?*GstTypeFindFactory) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_object_unref(@ptrCast(gpointer, _ptr));
    }
}
pub fn glib_autoptr_cleanup_GstTypeFindFactory(arg__ptr: [*c]?*GstTypeFindFactory) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstTypeFindFactory(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstTypeFindFactory(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GstTypeFindFactory(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GstTypeFindFactory(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_object_unref)))));
    }
}
pub extern fn gst_parse_error_quark() GQuark;
pub const GST_PARSE_ERROR_SYNTAX: c_int = 0;
pub const GST_PARSE_ERROR_NO_SUCH_ELEMENT: c_int = 1;
pub const GST_PARSE_ERROR_NO_SUCH_PROPERTY: c_int = 2;
pub const GST_PARSE_ERROR_LINK: c_int = 3;
pub const GST_PARSE_ERROR_COULD_NOT_SET_PROPERTY: c_int = 4;
pub const GST_PARSE_ERROR_EMPTY_BIN: c_int = 5;
pub const GST_PARSE_ERROR_EMPTY: c_int = 6;
pub const GST_PARSE_ERROR_DELAYED_LINK: c_int = 7;
pub const GstParseError = c_uint;
pub const GST_PARSE_FLAG_NONE: c_int = 0;
pub const GST_PARSE_FLAG_FATAL_ERRORS: c_int = 1;
pub const GST_PARSE_FLAG_NO_SINGLE_ELEMENT_BINS: c_int = 2;
pub const GST_PARSE_FLAG_PLACE_IN_BIN: c_int = 4;
pub const GstParseFlags = c_uint;
pub const struct__GstParseContext = opaque {};
pub const GstParseContext = struct__GstParseContext;
pub extern fn gst_parse_context_get_type() GType;
pub extern fn gst_parse_context_new() ?*GstParseContext;
pub extern fn gst_parse_context_get_missing_elements(context: ?*GstParseContext) [*c][*c]gchar;
pub extern fn gst_parse_context_free(context: ?*GstParseContext) void;
pub extern fn gst_parse_context_copy(context: ?*const GstParseContext) ?*GstParseContext;
pub extern fn gst_parse_launch(pipeline_description: [*c]const gchar, @"error": [*c][*c]GError) [*c]GstElement;
pub extern fn gst_parse_launchv(argv: [*c][*c]const gchar, @"error": [*c][*c]GError) [*c]GstElement;
pub extern fn gst_parse_launch_full(pipeline_description: [*c]const gchar, context: ?*GstParseContext, flags: GstParseFlags, @"error": [*c][*c]GError) [*c]GstElement;
pub extern fn gst_parse_launchv_full(argv: [*c][*c]const gchar, context: ?*GstParseContext, flags: GstParseFlags, @"error": [*c][*c]GError) [*c]GstElement;
pub const GstParseContext_autoptr = ?*GstParseContext;
pub const GstParseContext_listautoptr = [*c]GList;
pub const GstParseContext_slistautoptr = [*c]GSList;
pub const GstParseContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GstParseContext(arg__ptr: ?*GstParseContext) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gst_parse_context_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GstParseContext(arg__ptr: [*c]?*GstParseContext) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GstParseContext(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GstParseContext(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_parse_context_free)))));
}
pub fn glib_slistautoptr_cleanup_GstParseContext(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_parse_context_free)))));
}
pub fn glib_queueautoptr_cleanup_GstParseContext(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @ptrCast(GDestroyNotify, @alignCast(@import("std").meta.alignment(GDestroyNotify), @ptrCast(?fn () callconv(.C) void, @alignCast(@import("std").meta.alignment(?fn () callconv(.C) void), gst_parse_context_free)))));
    }
}
pub extern fn gst_util_set_value_from_string(value: [*c]GValue, value_str: [*c]const gchar) void;
pub extern fn gst_util_set_object_arg(object: [*c]GObject, name: [*c]const gchar, value: [*c]const gchar) void;
pub extern fn gst_util_set_object_array(object: [*c]GObject, name: [*c]const gchar, array: [*c]const GValueArray) gboolean;
pub extern fn gst_util_get_object_array(object: [*c]GObject, name: [*c]const gchar, array: [*c][*c]GValueArray) gboolean;
pub extern fn gst_util_dump_mem(mem: [*c]const guchar, size: guint) void;
pub extern fn gst_util_dump_buffer(buf: [*c]GstBuffer) void;
pub extern fn gst_util_gdouble_to_guint64(value: gdouble) guint64;
pub extern fn gst_util_guint64_to_gdouble(value: guint64) gdouble;
pub extern fn gst_util_uint64_scale(val: guint64, num: guint64, denom: guint64) guint64;
pub extern fn gst_util_uint64_scale_round(val: guint64, num: guint64, denom: guint64) guint64;
pub extern fn gst_util_uint64_scale_ceil(val: guint64, num: guint64, denom: guint64) guint64;
pub extern fn gst_util_uint64_scale_int(val: guint64, num: gint, denom: gint) guint64;
pub extern fn gst_util_uint64_scale_int_round(val: guint64, num: gint, denom: gint) guint64;
pub extern fn gst_util_uint64_scale_int_ceil(val: guint64, num: gint, denom: gint) guint64;
pub extern fn gst_util_seqnum_next() guint32;
pub extern fn gst_util_seqnum_compare(s1: guint32, s2: guint32) gint32;
pub extern fn gst_util_group_id_next() guint;
pub fn __gst_slow_read64_be(arg_data: [*c]const guint8) callconv(.C) guint64 {
    var data = arg_data;
    return (((((((@bitCast(guint64, @as(c_ulong, data[@intCast(c_uint, @as(c_int, 0))])) << @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 56))) | (@bitCast(guint64, @as(c_ulong, data[@intCast(c_uint, @as(c_int, 1))])) << @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 48)))) | (@bitCast(guint64, @as(c_ulong, data[@intCast(c_uint, @as(c_int, 2))])) << @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 40)))) | (@bitCast(guint64, @as(c_ulong, data[@intCast(c_uint, @as(c_int, 3))])) << @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 32)))) | (@bitCast(guint64, @as(c_ulong, data[@intCast(c_uint, @as(c_int, 4))])) << @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 24)))) | (@bitCast(guint64, @as(c_ulong, data[@intCast(c_uint, @as(c_int, 5))])) << @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 16)))) | (@bitCast(guint64, @as(c_ulong, data[@intCast(c_uint, @as(c_int, 6))])) << @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 8)))) | (@bitCast(guint64, @as(c_ulong, data[@intCast(c_uint, @as(c_int, 7))])) << @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 0)));
}
pub fn __gst_slow_read64_le(arg_data: [*c]const guint8) callconv(.C) guint64 {
    var data = arg_data;
    return (((((((@bitCast(guint64, @as(c_ulong, data[@intCast(c_uint, @as(c_int, 7))])) << @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 56))) | (@bitCast(guint64, @as(c_ulong, data[@intCast(c_uint, @as(c_int, 6))])) << @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 48)))) | (@bitCast(guint64, @as(c_ulong, data[@intCast(c_uint, @as(c_int, 5))])) << @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 40)))) | (@bitCast(guint64, @as(c_ulong, data[@intCast(c_uint, @as(c_int, 4))])) << @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 32)))) | (@bitCast(guint64, @as(c_ulong, data[@intCast(c_uint, @as(c_int, 3))])) << @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 24)))) | (@bitCast(guint64, @as(c_ulong, data[@intCast(c_uint, @as(c_int, 2))])) << @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 16)))) | (@bitCast(guint64, @as(c_ulong, data[@intCast(c_uint, @as(c_int, 1))])) << @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 8)))) | (@bitCast(guint64, @as(c_ulong, data[@intCast(c_uint, @as(c_int, 0))])) << @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 0)));
}
pub fn __gst_slow_read32_be(arg_data: [*c]const guint8) callconv(.C) guint32 {
    var data = arg_data;
    return (((@bitCast(guint32, @as(c_uint, data[@intCast(c_uint, @as(c_int, 0))])) << @intCast(@import("std").math.Log2Int(guint32), @as(c_int, 24))) | (@bitCast(guint32, @as(c_uint, data[@intCast(c_uint, @as(c_int, 1))])) << @intCast(@import("std").math.Log2Int(guint32), @as(c_int, 16)))) | (@bitCast(guint32, @as(c_uint, data[@intCast(c_uint, @as(c_int, 2))])) << @intCast(@import("std").math.Log2Int(guint32), @as(c_int, 8)))) | (@bitCast(guint32, @as(c_uint, data[@intCast(c_uint, @as(c_int, 3))])) << @intCast(@import("std").math.Log2Int(guint32), @as(c_int, 0)));
}
pub fn __gst_slow_read32_le(arg_data: [*c]const guint8) callconv(.C) guint32 {
    var data = arg_data;
    return (((@bitCast(guint32, @as(c_uint, data[@intCast(c_uint, @as(c_int, 3))])) << @intCast(@import("std").math.Log2Int(guint32), @as(c_int, 24))) | (@bitCast(guint32, @as(c_uint, data[@intCast(c_uint, @as(c_int, 2))])) << @intCast(@import("std").math.Log2Int(guint32), @as(c_int, 16)))) | (@bitCast(guint32, @as(c_uint, data[@intCast(c_uint, @as(c_int, 1))])) << @intCast(@import("std").math.Log2Int(guint32), @as(c_int, 8)))) | (@bitCast(guint32, @as(c_uint, data[@intCast(c_uint, @as(c_int, 0))])) << @intCast(@import("std").math.Log2Int(guint32), @as(c_int, 0)));
}
pub fn __gst_slow_read24_be(arg_data: [*c]const guint8) callconv(.C) guint32 {
    var data = arg_data;
    return ((@bitCast(guint32, @as(c_uint, data[@intCast(c_uint, @as(c_int, 0))])) << @intCast(@import("std").math.Log2Int(guint32), @as(c_int, 16))) | (@bitCast(guint32, @as(c_uint, data[@intCast(c_uint, @as(c_int, 1))])) << @intCast(@import("std").math.Log2Int(guint32), @as(c_int, 8)))) | (@bitCast(guint32, @as(c_uint, data[@intCast(c_uint, @as(c_int, 2))])) << @intCast(@import("std").math.Log2Int(guint32), @as(c_int, 0)));
}
pub fn __gst_slow_read24_le(arg_data: [*c]const guint8) callconv(.C) guint32 {
    var data = arg_data;
    return ((@bitCast(guint32, @as(c_uint, data[@intCast(c_uint, @as(c_int, 2))])) << @intCast(@import("std").math.Log2Int(guint32), @as(c_int, 16))) | (@bitCast(guint32, @as(c_uint, data[@intCast(c_uint, @as(c_int, 1))])) << @intCast(@import("std").math.Log2Int(guint32), @as(c_int, 8)))) | (@bitCast(guint32, @as(c_uint, data[@intCast(c_uint, @as(c_int, 0))])) << @intCast(@import("std").math.Log2Int(guint32), @as(c_int, 0)));
}
pub fn __gst_slow_read16_be(arg_data: [*c]const guint8) callconv(.C) guint16 {
    var data = arg_data;
    return @bitCast(guint16, @truncate(c_short, (@bitCast(c_int, @as(c_uint, @bitCast(guint16, @as(c_ushort, data[@intCast(c_uint, @as(c_int, 0))])))) << @intCast(@import("std").math.Log2Int(c_int), @as(c_int, 8))) | (@bitCast(c_int, @as(c_uint, @bitCast(guint16, @as(c_ushort, data[@intCast(c_uint, @as(c_int, 1))])))) << @intCast(@import("std").math.Log2Int(c_int), @as(c_int, 0)))));
}
pub fn __gst_slow_read16_le(arg_data: [*c]const guint8) callconv(.C) guint16 {
    var data = arg_data;
    return @bitCast(guint16, @truncate(c_short, (@bitCast(c_int, @as(c_uint, @bitCast(guint16, @as(c_ushort, data[@intCast(c_uint, @as(c_int, 1))])))) << @intCast(@import("std").math.Log2Int(c_int), @as(c_int, 8))) | (@bitCast(c_int, @as(c_uint, @bitCast(guint16, @as(c_ushort, data[@intCast(c_uint, @as(c_int, 0))])))) << @intCast(@import("std").math.Log2Int(c_int), @as(c_int, 0)))));
}
pub fn GFLOAT_SWAP_LE_BE(arg_in: gfloat) callconv(.C) gfloat {
    var in = arg_in;
    const union_unnamed_55 = extern union {
        i: guint32,
        f: gfloat,
    };
    _ = union_unnamed_55;
    var u: union_unnamed_55 = undefined;
    u.f = in;
    u.i = @bitCast(guint32, ((((u.i & @bitCast(guint32, @as(c_uint, 255))) << @intCast(@import("std").math.Log2Int(c_uint), 24)) | ((u.i & @bitCast(guint32, @as(c_uint, 65280))) << @intCast(@import("std").math.Log2Int(c_uint), 8))) | ((u.i & @bitCast(guint32, @as(c_uint, 16711680))) >> @intCast(@import("std").math.Log2Int(c_uint), 8))) | ((u.i & @bitCast(guint32, @as(c_uint, 4278190080))) >> @intCast(@import("std").math.Log2Int(c_uint), 24)));
    return u.f;
}
pub fn GDOUBLE_SWAP_LE_BE(arg_in: gdouble) callconv(.C) gdouble {
    var in = arg_in;
    const union_unnamed_56 = extern union {
        i: guint64,
        d: gdouble,
    };
    _ = union_unnamed_56;
    var u: union_unnamed_56 = undefined;
    u.d = in;
    u.i = @bitCast(guint64, ((((((((u.i & @bitCast(guint64, @as(c_ulong, 255))) << @intCast(@import("std").math.Log2Int(c_ulong), 56)) | ((u.i & @bitCast(guint64, @as(c_ulong, 65280))) << @intCast(@import("std").math.Log2Int(c_ulong), 40))) | ((u.i & @bitCast(guint64, @as(c_ulong, 16711680))) << @intCast(@import("std").math.Log2Int(c_ulong), 24))) | ((u.i & @bitCast(guint64, @as(c_ulong, 4278190080))) << @intCast(@import("std").math.Log2Int(c_ulong), 8))) | ((u.i & @bitCast(guint64, @as(c_ulong, 1095216660480))) >> @intCast(@import("std").math.Log2Int(c_ulong), 8))) | ((u.i & @bitCast(guint64, @as(c_ulong, 280375465082880))) >> @intCast(@import("std").math.Log2Int(c_ulong), 24))) | ((u.i & @bitCast(guint64, @as(c_ulong, 71776119061217280))) >> @intCast(@import("std").math.Log2Int(c_ulong), 40))) | ((u.i & @bitCast(guint64, @as(c_ulong, 18374686479671623680))) >> @intCast(@import("std").math.Log2Int(c_ulong), 56)));
    return u.d;
}
pub fn GST_READ_FLOAT_LE(arg_data: [*c]const guint8) callconv(.C) gfloat {
    var data = arg_data;
    const union_unnamed_57 = extern union {
        i: guint32,
        f: gfloat,
    };
    _ = union_unnamed_57;
    var u: union_unnamed_57 = undefined;
    u.i = __gst_slow_read32_le(data);
    return u.f;
}
pub fn GST_READ_FLOAT_BE(arg_data: [*c]const guint8) callconv(.C) gfloat {
    var data = arg_data;
    const union_unnamed_58 = extern union {
        i: guint32,
        f: gfloat,
    };
    _ = union_unnamed_58;
    var u: union_unnamed_58 = undefined;
    u.i = __gst_slow_read32_be(data);
    return u.f;
}
pub fn GST_READ_DOUBLE_LE(arg_data: [*c]const guint8) callconv(.C) gdouble {
    var data = arg_data;
    const union_unnamed_59 = extern union {
        i: guint64,
        d: gdouble,
    };
    _ = union_unnamed_59;
    var u: union_unnamed_59 = undefined;
    u.i = __gst_slow_read64_le(data);
    return u.d;
}
pub fn GST_READ_DOUBLE_BE(arg_data: [*c]const guint8) callconv(.C) gdouble {
    var data = arg_data;
    const union_unnamed_60 = extern union {
        i: guint64,
        d: gdouble,
    };
    _ = union_unnamed_60;
    var u: union_unnamed_60 = undefined;
    u.i = __gst_slow_read64_be(data);
    return u.d;
}
pub fn GST_WRITE_FLOAT_LE(arg_data: [*c]guint8, arg_num: gfloat) callconv(.C) void {
    var data = arg_data;
    var num = arg_num;
    const union_unnamed_61 = extern union {
        i: guint32,
        f: gfloat,
    };
    _ = union_unnamed_61;
    var u: union_unnamed_61 = undefined;
    u.f = num;
    while (true) {
        var __put_data: gpointer = @ptrCast(gpointer, data);
        var __put_val: guint32 = u.i;
        _ = blk: {
            const tmp = @bitCast(guint8, @truncate(u8, (__put_val >> @intCast(@import("std").math.Log2Int(guint32), @as(c_int, 0))) & @bitCast(c_uint, @as(c_int, 255))));
            @ptrCast([*c]guint8, @alignCast(@import("std").meta.alignment([*c]guint8), __put_data))[@intCast(c_uint, @as(c_int, 0))] = tmp;
            break :blk tmp;
        };
        _ = blk: {
            const tmp = @bitCast(guint8, @truncate(u8, (__put_val >> @intCast(@import("std").math.Log2Int(guint32), @as(c_int, 8))) & @bitCast(c_uint, @as(c_int, 255))));
            @ptrCast([*c]guint8, @alignCast(@import("std").meta.alignment([*c]guint8), __put_data))[@intCast(c_uint, @as(c_int, 1))] = tmp;
            break :blk tmp;
        };
        _ = blk: {
            const tmp = @bitCast(guint8, @truncate(u8, (__put_val >> @intCast(@import("std").math.Log2Int(guint32), @as(c_int, 16))) & @bitCast(c_uint, @as(c_int, 255))));
            @ptrCast([*c]guint8, @alignCast(@import("std").meta.alignment([*c]guint8), __put_data))[@intCast(c_uint, @as(c_int, 2))] = tmp;
            break :blk tmp;
        };
        _ = blk: {
            const tmp = @bitCast(guint8, @truncate(u8, (__put_val >> @intCast(@import("std").math.Log2Int(guint32), @as(c_int, 24))) & @bitCast(c_uint, @as(c_int, 255))));
            @ptrCast([*c]guint8, @alignCast(@import("std").meta.alignment([*c]guint8), __put_data))[@intCast(c_uint, @as(c_int, 3))] = tmp;
            break :blk tmp;
        };
        if (!false) break;
    }
}
pub fn GST_WRITE_FLOAT_BE(arg_data: [*c]guint8, arg_num: gfloat) callconv(.C) void {
    var data = arg_data;
    var num = arg_num;
    const union_unnamed_62 = extern union {
        i: guint32,
        f: gfloat,
    };
    _ = union_unnamed_62;
    var u: union_unnamed_62 = undefined;
    u.f = num;
    while (true) {
        var __put_data: gpointer = @ptrCast(gpointer, data);
        var __put_val: guint32 = u.i;
        _ = blk: {
            const tmp = @bitCast(guint8, @truncate(u8, (__put_val >> @intCast(@import("std").math.Log2Int(guint32), @as(c_int, 24))) & @bitCast(c_uint, @as(c_int, 255))));
            @ptrCast([*c]guint8, @alignCast(@import("std").meta.alignment([*c]guint8), __put_data))[@intCast(c_uint, @as(c_int, 0))] = tmp;
            break :blk tmp;
        };
        _ = blk: {
            const tmp = @bitCast(guint8, @truncate(u8, (__put_val >> @intCast(@import("std").math.Log2Int(guint32), @as(c_int, 16))) & @bitCast(c_uint, @as(c_int, 255))));
            @ptrCast([*c]guint8, @alignCast(@import("std").meta.alignment([*c]guint8), __put_data))[@intCast(c_uint, @as(c_int, 1))] = tmp;
            break :blk tmp;
        };
        _ = blk: {
            const tmp = @bitCast(guint8, @truncate(u8, (__put_val >> @intCast(@import("std").math.Log2Int(guint32), @as(c_int, 8))) & @bitCast(c_uint, @as(c_int, 255))));
            @ptrCast([*c]guint8, @alignCast(@import("std").meta.alignment([*c]guint8), __put_data))[@intCast(c_uint, @as(c_int, 2))] = tmp;
            break :blk tmp;
        };
        _ = blk: {
            const tmp = @bitCast(guint8, @truncate(u8, (__put_val >> @intCast(@import("std").math.Log2Int(guint32), @as(c_int, 0))) & @bitCast(c_uint, @as(c_int, 255))));
            @ptrCast([*c]guint8, @alignCast(@import("std").meta.alignment([*c]guint8), __put_data))[@intCast(c_uint, @as(c_int, 3))] = tmp;
            break :blk tmp;
        };
        if (!false) break;
    }
}
pub fn GST_WRITE_DOUBLE_LE(arg_data: [*c]guint8, arg_num: gdouble) callconv(.C) void {
    var data = arg_data;
    var num = arg_num;
    const union_unnamed_63 = extern union {
        i: guint64,
        d: gdouble,
    };
    _ = union_unnamed_63;
    var u: union_unnamed_63 = undefined;
    u.d = num;
    while (true) {
        var __put_data: gpointer = @ptrCast(gpointer, data);
        var __put_val: guint64 = u.i;
        _ = blk: {
            const tmp = @bitCast(guint8, @truncate(u8, (__put_val >> @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 0))) & @bitCast(c_ulong, @as(c_long, @as(c_int, 255)))));
            @ptrCast([*c]guint8, @alignCast(@import("std").meta.alignment([*c]guint8), __put_data))[@intCast(c_uint, @as(c_int, 0))] = tmp;
            break :blk tmp;
        };
        _ = blk: {
            const tmp = @bitCast(guint8, @truncate(u8, (__put_val >> @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 8))) & @bitCast(c_ulong, @as(c_long, @as(c_int, 255)))));
            @ptrCast([*c]guint8, @alignCast(@import("std").meta.alignment([*c]guint8), __put_data))[@intCast(c_uint, @as(c_int, 1))] = tmp;
            break :blk tmp;
        };
        _ = blk: {
            const tmp = @bitCast(guint8, @truncate(u8, (__put_val >> @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 16))) & @bitCast(c_ulong, @as(c_long, @as(c_int, 255)))));
            @ptrCast([*c]guint8, @alignCast(@import("std").meta.alignment([*c]guint8), __put_data))[@intCast(c_uint, @as(c_int, 2))] = tmp;
            break :blk tmp;
        };
        _ = blk: {
            const tmp = @bitCast(guint8, @truncate(u8, (__put_val >> @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 24))) & @bitCast(c_ulong, @as(c_long, @as(c_int, 255)))));
            @ptrCast([*c]guint8, @alignCast(@import("std").meta.alignment([*c]guint8), __put_data))[@intCast(c_uint, @as(c_int, 3))] = tmp;
            break :blk tmp;
        };
        _ = blk: {
            const tmp = @bitCast(guint8, @truncate(u8, (__put_val >> @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 32))) & @bitCast(c_ulong, @as(c_long, @as(c_int, 255)))));
            @ptrCast([*c]guint8, @alignCast(@import("std").meta.alignment([*c]guint8), __put_data))[@intCast(c_uint, @as(c_int, 4))] = tmp;
            break :blk tmp;
        };
        _ = blk: {
            const tmp = @bitCast(guint8, @truncate(u8, (__put_val >> @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 40))) & @bitCast(c_ulong, @as(c_long, @as(c_int, 255)))));
            @ptrCast([*c]guint8, @alignCast(@import("std").meta.alignment([*c]guint8), __put_data))[@intCast(c_uint, @as(c_int, 5))] = tmp;
            break :blk tmp;
        };
        _ = blk: {
            const tmp = @bitCast(guint8, @truncate(u8, (__put_val >> @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 48))) & @bitCast(c_ulong, @as(c_long, @as(c_int, 255)))));
            @ptrCast([*c]guint8, @alignCast(@import("std").meta.alignment([*c]guint8), __put_data))[@intCast(c_uint, @as(c_int, 6))] = tmp;
            break :blk tmp;
        };
        _ = blk: {
            const tmp = @bitCast(guint8, @truncate(u8, (__put_val >> @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 56))) & @bitCast(c_ulong, @as(c_long, @as(c_int, 255)))));
            @ptrCast([*c]guint8, @alignCast(@import("std").meta.alignment([*c]guint8), __put_data))[@intCast(c_uint, @as(c_int, 7))] = tmp;
            break :blk tmp;
        };
        if (!false) break;
    }
}
pub fn GST_WRITE_DOUBLE_BE(arg_data: [*c]guint8, arg_num: gdouble) callconv(.C) void {
    var data = arg_data;
    var num = arg_num;
    const union_unnamed_64 = extern union {
        i: guint64,
        d: gdouble,
    };
    _ = union_unnamed_64;
    var u: union_unnamed_64 = undefined;
    u.d = num;
    while (true) {
        var __put_data: gpointer = @ptrCast(gpointer, data);
        var __put_val: guint64 = u.i;
        _ = blk: {
            const tmp = @bitCast(guint8, @truncate(u8, (__put_val >> @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 56))) & @bitCast(c_ulong, @as(c_long, @as(c_int, 255)))));
            @ptrCast([*c]guint8, @alignCast(@import("std").meta.alignment([*c]guint8), __put_data))[@intCast(c_uint, @as(c_int, 0))] = tmp;
            break :blk tmp;
        };
        _ = blk: {
            const tmp = @bitCast(guint8, @truncate(u8, (__put_val >> @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 48))) & @bitCast(c_ulong, @as(c_long, @as(c_int, 255)))));
            @ptrCast([*c]guint8, @alignCast(@import("std").meta.alignment([*c]guint8), __put_data))[@intCast(c_uint, @as(c_int, 1))] = tmp;
            break :blk tmp;
        };
        _ = blk: {
            const tmp = @bitCast(guint8, @truncate(u8, (__put_val >> @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 40))) & @bitCast(c_ulong, @as(c_long, @as(c_int, 255)))));
            @ptrCast([*c]guint8, @alignCast(@import("std").meta.alignment([*c]guint8), __put_data))[@intCast(c_uint, @as(c_int, 2))] = tmp;
            break :blk tmp;
        };
        _ = blk: {
            const tmp = @bitCast(guint8, @truncate(u8, (__put_val >> @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 32))) & @bitCast(c_ulong, @as(c_long, @as(c_int, 255)))));
            @ptrCast([*c]guint8, @alignCast(@import("std").meta.alignment([*c]guint8), __put_data))[@intCast(c_uint, @as(c_int, 3))] = tmp;
            break :blk tmp;
        };
        _ = blk: {
            const tmp = @bitCast(guint8, @truncate(u8, (__put_val >> @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 24))) & @bitCast(c_ulong, @as(c_long, @as(c_int, 255)))));
            @ptrCast([*c]guint8, @alignCast(@import("std").meta.alignment([*c]guint8), __put_data))[@intCast(c_uint, @as(c_int, 4))] = tmp;
            break :blk tmp;
        };
        _ = blk: {
            const tmp = @bitCast(guint8, @truncate(u8, (__put_val >> @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 16))) & @bitCast(c_ulong, @as(c_long, @as(c_int, 255)))));
            @ptrCast([*c]guint8, @alignCast(@import("std").meta.alignment([*c]guint8), __put_data))[@intCast(c_uint, @as(c_int, 5))] = tmp;
            break :blk tmp;
        };
        _ = blk: {
            const tmp = @bitCast(guint8, @truncate(u8, (__put_val >> @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 8))) & @bitCast(c_ulong, @as(c_long, @as(c_int, 255)))));
            @ptrCast([*c]guint8, @alignCast(@import("std").meta.alignment([*c]guint8), __put_data))[@intCast(c_uint, @as(c_int, 6))] = tmp;
            break :blk tmp;
        };
        _ = blk: {
            const tmp = @bitCast(guint8, @truncate(u8, (__put_val >> @intCast(@import("std").math.Log2Int(guint64), @as(c_int, 0))) & @bitCast(c_ulong, @as(c_long, @as(c_int, 255)))));
            @ptrCast([*c]guint8, @alignCast(@import("std").meta.alignment([*c]guint8), __put_data))[@intCast(c_uint, @as(c_int, 7))] = tmp;
            break :blk tmp;
        };
        if (!false) break;
    }
}
pub extern fn gst_object_default_error(source: [*c]GstObject, @"error": [*c]const GError, debug: [*c]const gchar) void;
pub extern fn gst_element_create_all_pads(element: [*c]GstElement) void;
pub extern fn gst_element_get_compatible_pad(element: [*c]GstElement, pad: ?*GstPad, caps: [*c]GstCaps) ?*GstPad;
pub extern fn gst_element_get_compatible_pad_template(element: [*c]GstElement, compattempl: [*c]GstPadTemplate) [*c]GstPadTemplate;
pub extern fn gst_element_state_get_name(state: GstState) [*c]const gchar;
pub extern fn gst_element_state_change_return_get_name(state_ret: GstStateChangeReturn) [*c]const gchar;
pub extern fn gst_state_change_get_name(transition: GstStateChange) [*c]const gchar;
pub extern fn gst_element_link(src: [*c]GstElement, dest: [*c]GstElement) gboolean;
pub extern fn gst_element_link_many(element_1: [*c]GstElement, element_2: [*c]GstElement, ...) gboolean;
pub extern fn gst_element_link_filtered(src: [*c]GstElement, dest: [*c]GstElement, filter: [*c]GstCaps) gboolean;
pub extern fn gst_element_unlink(src: [*c]GstElement, dest: [*c]GstElement) void;
pub extern fn gst_element_unlink_many(element_1: [*c]GstElement, element_2: [*c]GstElement, ...) void;
pub extern fn gst_element_link_pads(src: [*c]GstElement, srcpadname: [*c]const gchar, dest: [*c]GstElement, destpadname: [*c]const gchar) gboolean;
pub extern fn gst_element_link_pads_full(src: [*c]GstElement, srcpadname: [*c]const gchar, dest: [*c]GstElement, destpadname: [*c]const gchar, flags: GstPadLinkCheck) gboolean;
pub extern fn gst_element_unlink_pads(src: [*c]GstElement, srcpadname: [*c]const gchar, dest: [*c]GstElement, destpadname: [*c]const gchar) void;
pub extern fn gst_element_link_pads_filtered(src: [*c]GstElement, srcpadname: [*c]const gchar, dest: [*c]GstElement, destpadname: [*c]const gchar, filter: [*c]GstCaps) gboolean;
pub extern fn gst_element_seek_simple(element: [*c]GstElement, format: GstFormat, seek_flags: GstSeekFlags, seek_pos: gint64) gboolean;
pub extern fn gst_element_factory_can_sink_all_caps(factory: ?*GstElementFactory, caps: [*c]const GstCaps) gboolean;
pub extern fn gst_element_factory_can_src_all_caps(factory: ?*GstElementFactory, caps: [*c]const GstCaps) gboolean;
pub extern fn gst_element_factory_can_sink_any_caps(factory: ?*GstElementFactory, caps: [*c]const GstCaps) gboolean;
pub extern fn gst_element_factory_can_src_any_caps(factory: ?*GstElementFactory, caps: [*c]const GstCaps) gboolean;
pub extern fn gst_element_query_position(element: [*c]GstElement, format: GstFormat, cur: [*c]gint64) gboolean;
pub extern fn gst_element_query_duration(element: [*c]GstElement, format: GstFormat, duration: [*c]gint64) gboolean;
pub extern fn gst_element_query_convert(element: [*c]GstElement, src_format: GstFormat, src_val: gint64, dest_format: GstFormat, dest_val: [*c]gint64) gboolean;
pub extern fn gst_pad_use_fixed_caps(pad: ?*GstPad) void;
pub extern fn gst_pad_get_parent_element(pad: ?*GstPad) [*c]GstElement;
pub extern fn gst_pad_proxy_query_accept_caps(pad: ?*GstPad, query: [*c]GstQuery) gboolean;
pub extern fn gst_pad_proxy_query_caps(pad: ?*GstPad, query: [*c]GstQuery) gboolean;
pub extern fn gst_pad_query_position(pad: ?*GstPad, format: GstFormat, cur: [*c]gint64) gboolean;
pub extern fn gst_pad_query_duration(pad: ?*GstPad, format: GstFormat, duration: [*c]gint64) gboolean;
pub extern fn gst_pad_query_convert(pad: ?*GstPad, src_format: GstFormat, src_val: gint64, dest_format: GstFormat, dest_val: [*c]gint64) gboolean;
pub extern fn gst_pad_query_caps(pad: ?*GstPad, filter: [*c]GstCaps) [*c]GstCaps;
pub extern fn gst_pad_query_accept_caps(pad: ?*GstPad, caps: [*c]GstCaps) gboolean;
pub extern fn gst_pad_link_maybe_ghosting(src: ?*GstPad, sink: ?*GstPad) gboolean;
pub extern fn gst_pad_link_maybe_ghosting_full(src: ?*GstPad, sink: ?*GstPad, flags: GstPadLinkCheck) gboolean;
pub extern fn gst_pad_peer_query_position(pad: ?*GstPad, format: GstFormat, cur: [*c]gint64) gboolean;
pub extern fn gst_pad_peer_query_duration(pad: ?*GstPad, format: GstFormat, duration: [*c]gint64) gboolean;
pub extern fn gst_pad_peer_query_convert(pad: ?*GstPad, src_format: GstFormat, src_val: gint64, dest_format: GstFormat, dest_val: [*c]gint64) gboolean;
pub extern fn gst_pad_peer_query_caps(pad: ?*GstPad, filter: [*c]GstCaps) [*c]GstCaps;
pub extern fn gst_pad_peer_query_accept_caps(pad: ?*GstPad, caps: [*c]GstCaps) gboolean;
pub extern fn gst_pad_create_stream_id(pad: ?*GstPad, parent: [*c]GstElement, stream_id: [*c]const gchar) [*c]gchar;
pub extern fn gst_pad_create_stream_id_printf(pad: ?*GstPad, parent: [*c]GstElement, stream_id: [*c]const gchar, ...) [*c]gchar;
pub extern fn gst_pad_create_stream_id_printf_valist(pad: ?*GstPad, parent: [*c]GstElement, stream_id: [*c]const gchar, var_args: va_list) [*c]gchar;
pub extern fn gst_pad_get_stream_id(pad: ?*GstPad) [*c]gchar;
pub extern fn gst_pad_get_stream(pad: ?*GstPad) [*c]GstStream;
pub extern fn gst_bin_add_many(bin: [*c]GstBin, element_1: [*c]GstElement, ...) void;
pub extern fn gst_bin_remove_many(bin: [*c]GstBin, element_1: [*c]GstElement, ...) void;
pub extern fn gst_bin_find_unlinked_pad(bin: [*c]GstBin, direction: GstPadDirection) ?*GstPad;
pub extern fn gst_bin_sync_children_states(bin: [*c]GstBin) gboolean;
pub extern fn gst_parse_bin_from_description(bin_description: [*c]const gchar, ghost_unlinked_pads: gboolean, err: [*c][*c]GError) [*c]GstElement;
pub extern fn gst_parse_bin_from_description_full(bin_description: [*c]const gchar, ghost_unlinked_pads: gboolean, context: ?*GstParseContext, flags: GstParseFlags, err: [*c][*c]GError) [*c]GstElement;
pub extern fn gst_util_get_timestamp() GstClockTime;
pub const GST_SEARCH_MODE_EXACT: c_int = 0;
pub const GST_SEARCH_MODE_BEFORE: c_int = 1;
pub const GST_SEARCH_MODE_AFTER: c_int = 2;
pub const GstSearchMode = c_uint;
pub const GST_PLUGIN_API_FLAG_IGNORE_ENUM_MEMBERS: c_int = 1;
pub const GstPluginAPIFlags = c_uint;
pub extern fn gst_util_array_binary_search(array: gpointer, num_elements: guint, element_size: gsize, search_func: GCompareDataFunc, mode: GstSearchMode, search_data: gconstpointer, user_data: gpointer) gpointer;
pub extern fn gst_util_greatest_common_divisor(a: gint, b: gint) gint;
pub extern fn gst_util_greatest_common_divisor_int64(a: gint64, b: gint64) gint64;
pub extern fn gst_util_fraction_to_double(src_n: gint, src_d: gint, dest: [*c]gdouble) void;
pub extern fn gst_util_double_to_fraction(src: gdouble, dest_n: [*c]gint, dest_d: [*c]gint) void;
pub extern fn gst_util_fraction_multiply(a_n: gint, a_d: gint, b_n: gint, b_d: gint, res_n: [*c]gint, res_d: [*c]gint) gboolean;
pub extern fn gst_util_fraction_add(a_n: gint, a_d: gint, b_n: gint, b_d: gint, res_n: [*c]gint, res_d: [*c]gint) gboolean;
pub extern fn gst_util_fraction_compare(a_n: gint, a_d: gint, b_n: gint, b_d: gint) gint;
pub extern fn gst_calculate_linear_regression(xy: [*c]const GstClockTime, temp: [*c]GstClockTime, n: guint, m_num: [*c]GstClockTime, m_denom: [*c]GstClockTime, b: [*c]GstClockTime, xbase: [*c]GstClockTime, r_squared: [*c]gdouble) gboolean;
pub extern fn gst_type_mark_as_plugin_api(@"type": GType, flags: GstPluginAPIFlags) void;
pub extern fn gst_type_is_plugin_api(@"type": GType, flags: [*c]GstPluginAPIFlags) gboolean;
pub fn gst_pad_set_caps(arg_pad: ?*GstPad, arg_caps: [*c]GstCaps) callconv(.C) gboolean {
    var pad = arg_pad;
    var caps = arg_caps;
    var event: [*c]GstEvent = undefined;
    var res: gboolean = @boolToInt(!(@as(c_int, 0) != 0));
    while (true) {
        if ((blk: {
            var __inst: [*c]GTypeInstance = @ptrCast([*c]GTypeInstance, @alignCast(@import("std").meta.alignment([*c]GTypeInstance), pad));
            var __t: GType = gst_pad_get_type();
            var __r: gboolean = undefined;
            if (!(__inst != null)) {
                __r = @as(c_int, 0);
            } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
                __r = @boolToInt(!(@as(c_int, 0) != 0));
            } else {
                __r = g_type_check_instance_is_a(__inst, __t);
            }
            break :blk __r;
        }) != 0) {} else {
            g_return_if_fail_warning(@intToPtr([*c]gchar, @as(c_int, 0)), "gst_pad_set_caps", "GST_IS_PAD (pad)");
            return @as(c_int, 0);
        }
        if (!false) break;
    }
    while (true) {
        if ((caps != @ptrCast([*c]GstCaps, @alignCast(@import("std").meta.alignment([*c]GstCaps), @intToPtr(?*anyopaque, @as(c_int, 0))))) and (gst_caps_is_fixed(caps) != 0)) {} else {
            g_return_if_fail_warning(@intToPtr([*c]gchar, @as(c_int, 0)), "gst_pad_set_caps", "caps != NULL && gst_caps_is_fixed (caps)");
            return @as(c_int, 0);
        }
        if (!false) break;
    }
    event = gst_event_new_caps(caps);
    if (pad.*.direction == @bitCast(c_uint, GST_PAD_SRC)) {
        res = gst_pad_push_event(pad, event);
    } else {
        res = gst_pad_send_event(pad, event);
    }
    return res;
}
pub extern fn gst_init(argc: [*c]c_int, argv: [*c][*c][*c]u8) void;
pub extern fn gst_init_check(argc: [*c]c_int, argv: [*c][*c][*c]u8, @"error": [*c][*c]GError) gboolean;
pub extern fn gst_is_initialized() gboolean;
pub extern fn gst_init_get_option_group() ?*GOptionGroup;
pub extern fn gst_deinit() void;
pub extern fn gst_version(major: [*c]guint, minor: [*c]guint, micro: [*c]guint, nano: [*c]guint) void;
pub extern fn gst_version_string() [*c]gchar;
pub extern fn gst_segtrap_is_enabled() gboolean;
pub extern fn gst_segtrap_set_enabled(enabled: gboolean) void;
pub extern fn gst_registry_fork_is_enabled() gboolean;
pub extern fn gst_registry_fork_set_enabled(enabled: gboolean) void;
pub extern fn gst_update_registry() gboolean;
pub extern fn gst_get_main_executable_path() [*c]const gchar;

pub const __llvm__ = @as(c_int, 1);
pub const __clang__ = @as(c_int, 1);
pub const __clang_major__ = @as(c_int, 14);
pub const __clang_minor__ = @as(c_int, 0);
pub const __clang_patchlevel__ = @as(c_int, 6);
pub const __clang_version__ = "14.0.6 (git@github.com:ziglang/zig-bootstrap.git dbc902054739800b8c1656dc1fb29571bba074b9)";
pub const __GNUC__ = @as(c_int, 4);
pub const __GNUC_MINOR__ = @as(c_int, 2);
pub const __GNUC_PATCHLEVEL__ = @as(c_int, 1);
pub const __GXX_ABI_VERSION = @as(c_int, 1002);
pub const __ATOMIC_RELAXED = @as(c_int, 0);
pub const __ATOMIC_CONSUME = @as(c_int, 1);
pub const __ATOMIC_ACQUIRE = @as(c_int, 2);
pub const __ATOMIC_RELEASE = @as(c_int, 3);
pub const __ATOMIC_ACQ_REL = @as(c_int, 4);
pub const __ATOMIC_SEQ_CST = @as(c_int, 5);
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM = @as(c_int, 0);
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP = @as(c_int, 1);
pub const __OPENCL_MEMORY_SCOPE_DEVICE = @as(c_int, 2);
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES = @as(c_int, 3);
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP = @as(c_int, 4);
pub const __PRAGMA_REDEFINE_EXTNAME = @as(c_int, 1);
pub const __VERSION__ = "Clang 14.0.6 (git@github.com:ziglang/zig-bootstrap.git dbc902054739800b8c1656dc1fb29571bba074b9)";
pub const __OBJC_BOOL_IS_BOOL = @as(c_int, 0);
pub const __CONSTANT_CFSTRINGS__ = @as(c_int, 1);
pub const __clang_literal_encoding__ = "UTF-8";
pub const __clang_wide_literal_encoding__ = "UTF-32";
pub const __ORDER_LITTLE_ENDIAN__ = @as(c_int, 1234);
pub const __ORDER_BIG_ENDIAN__ = @as(c_int, 4321);
pub const __ORDER_PDP_ENDIAN__ = @as(c_int, 3412);
pub const __BYTE_ORDER__ = __ORDER_LITTLE_ENDIAN__;
pub const __LITTLE_ENDIAN__ = @as(c_int, 1);
pub const _LP64 = @as(c_int, 1);
pub const __LP64__ = @as(c_int, 1);
pub const __CHAR_BIT__ = @as(c_int, 8);
pub const __BOOL_WIDTH__ = @as(c_int, 8);
pub const __SHRT_WIDTH__ = @as(c_int, 16);
pub const __INT_WIDTH__ = @as(c_int, 32);
pub const __LONG_WIDTH__ = @as(c_int, 64);
pub const __LLONG_WIDTH__ = @as(c_int, 64);
pub const __BITINT_MAXWIDTH__ = @as(c_int, 128);
pub const __SCHAR_MAX__ = @as(c_int, 127);
pub const __SHRT_MAX__ = @as(c_int, 32767);
pub const __INT_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __LONG_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __LONG_LONG_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __WCHAR_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __WCHAR_WIDTH__ = @as(c_int, 32);
pub const __WINT_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __WINT_WIDTH__ = @as(c_int, 32);
pub const __INTMAX_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INTMAX_WIDTH__ = @as(c_int, 64);
pub const __SIZE_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __SIZE_WIDTH__ = @as(c_int, 64);
pub const __UINTMAX_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINTMAX_WIDTH__ = @as(c_int, 64);
pub const __PTRDIFF_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __PTRDIFF_WIDTH__ = @as(c_int, 64);
pub const __INTPTR_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INTPTR_WIDTH__ = @as(c_int, 64);
pub const __UINTPTR_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINTPTR_WIDTH__ = @as(c_int, 64);
pub const __SIZEOF_DOUBLE__ = @as(c_int, 8);
pub const __SIZEOF_FLOAT__ = @as(c_int, 4);
pub const __SIZEOF_INT__ = @as(c_int, 4);
pub const __SIZEOF_LONG__ = @as(c_int, 8);
pub const __SIZEOF_LONG_DOUBLE__ = @as(c_int, 16);
pub const __SIZEOF_LONG_LONG__ = @as(c_int, 8);
pub const __SIZEOF_POINTER__ = @as(c_int, 8);
pub const __SIZEOF_SHORT__ = @as(c_int, 2);
pub const __SIZEOF_PTRDIFF_T__ = @as(c_int, 8);
pub const __SIZEOF_SIZE_T__ = @as(c_int, 8);
pub const __SIZEOF_WCHAR_T__ = @as(c_int, 4);
pub const __SIZEOF_WINT_T__ = @as(c_int, 4);
pub const __SIZEOF_INT128__ = @as(c_int, 16);
pub const __INTMAX_TYPE__ = c_long;
pub const __INTMAX_FMTd__ = "ld";
pub const __INTMAX_FMTi__ = "li";
pub const __UINTMAX_TYPE__ = c_ulong;
pub const __UINTMAX_FMTo__ = "lo";
pub const __UINTMAX_FMTu__ = "lu";
pub const __UINTMAX_FMTx__ = "lx";
pub const __UINTMAX_FMTX__ = "lX";
pub const __PTRDIFF_TYPE__ = c_long;
pub const __PTRDIFF_FMTd__ = "ld";
pub const __PTRDIFF_FMTi__ = "li";
pub const __INTPTR_TYPE__ = c_long;
pub const __INTPTR_FMTd__ = "ld";
pub const __INTPTR_FMTi__ = "li";
pub const __SIZE_TYPE__ = c_ulong;
pub const __SIZE_FMTo__ = "lo";
pub const __SIZE_FMTu__ = "lu";
pub const __SIZE_FMTx__ = "lx";
pub const __SIZE_FMTX__ = "lX";
pub const __WCHAR_TYPE__ = c_uint;
pub const __WINT_TYPE__ = c_uint;
pub const __SIG_ATOMIC_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __SIG_ATOMIC_WIDTH__ = @as(c_int, 32);
pub const __CHAR16_TYPE__ = c_ushort;
pub const __CHAR32_TYPE__ = c_uint;
pub const __UINTPTR_TYPE__ = c_ulong;
pub const __UINTPTR_FMTo__ = "lo";
pub const __UINTPTR_FMTu__ = "lu";
pub const __UINTPTR_FMTx__ = "lx";
pub const __UINTPTR_FMTX__ = "lX";
pub const __FLT16_HAS_DENORM__ = @as(c_int, 1);
pub const __FLT16_DIG__ = @as(c_int, 3);
pub const __FLT16_DECIMAL_DIG__ = @as(c_int, 5);
pub const __FLT16_HAS_INFINITY__ = @as(c_int, 1);
pub const __FLT16_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __FLT16_MANT_DIG__ = @as(c_int, 11);
pub const __FLT16_MAX_10_EXP__ = @as(c_int, 4);
pub const __FLT16_MAX_EXP__ = @as(c_int, 16);
pub const __FLT16_MIN_10_EXP__ = -@as(c_int, 4);
pub const __FLT16_MIN_EXP__ = -@as(c_int, 13);
pub const __FLT_DENORM_MIN__ = @as(f32, 1.40129846e-45);
pub const __FLT_HAS_DENORM__ = @as(c_int, 1);
pub const __FLT_DIG__ = @as(c_int, 6);
pub const __FLT_DECIMAL_DIG__ = @as(c_int, 9);
pub const __FLT_EPSILON__ = @as(f32, 1.19209290e-7);
pub const __FLT_HAS_INFINITY__ = @as(c_int, 1);
pub const __FLT_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __FLT_MANT_DIG__ = @as(c_int, 24);
pub const __FLT_MAX_10_EXP__ = @as(c_int, 38);
pub const __FLT_MAX_EXP__ = @as(c_int, 128);
pub const __FLT_MAX__ = @as(f32, 3.40282347e+38);
pub const __FLT_MIN_10_EXP__ = -@as(c_int, 37);
pub const __FLT_MIN_EXP__ = -@as(c_int, 125);
pub const __FLT_MIN__ = @as(f32, 1.17549435e-38);
pub const __DBL_DENORM_MIN__ = 4.9406564584124654e-324;
pub const __DBL_HAS_DENORM__ = @as(c_int, 1);
pub const __DBL_DIG__ = @as(c_int, 15);
pub const __DBL_DECIMAL_DIG__ = @as(c_int, 17);
pub const __DBL_EPSILON__ = 2.2204460492503131e-16;
pub const __DBL_HAS_INFINITY__ = @as(c_int, 1);
pub const __DBL_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __DBL_MANT_DIG__ = @as(c_int, 53);
pub const __DBL_MAX_10_EXP__ = @as(c_int, 308);
pub const __DBL_MAX_EXP__ = @as(c_int, 1024);
pub const __DBL_MAX__ = 1.7976931348623157e+308;
pub const __DBL_MIN_10_EXP__ = -@as(c_int, 307);
pub const __DBL_MIN_EXP__ = -@as(c_int, 1021);
pub const __DBL_MIN__ = 2.2250738585072014e-308;
pub const __LDBL_DENORM_MIN__ = @as(c_longdouble, 6.47517511943802511092443895822764655e-4966);
pub const __LDBL_HAS_DENORM__ = @as(c_int, 1);
pub const __LDBL_DIG__ = @as(c_int, 33);
pub const __LDBL_DECIMAL_DIG__ = @as(c_int, 36);
pub const __LDBL_EPSILON__ = @as(c_longdouble, 1.92592994438723585305597794258492732e-34);
pub const __LDBL_HAS_INFINITY__ = @as(c_int, 1);
pub const __LDBL_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __LDBL_MANT_DIG__ = @as(c_int, 113);
pub const __LDBL_MAX_10_EXP__ = @as(c_int, 4932);
pub const __LDBL_MAX_EXP__ = @as(c_int, 16384);
pub const __LDBL_MAX__ = @as(c_longdouble, 1.18973149535723176508575932662800702e+4932);
pub const __LDBL_MIN_10_EXP__ = -@as(c_int, 4931);
pub const __LDBL_MIN_EXP__ = -@as(c_int, 16381);
pub const __LDBL_MIN__ = @as(c_longdouble, 3.36210314311209350626267781732175260e-4932);
pub const __POINTER_WIDTH__ = @as(c_int, 64);
pub const __BIGGEST_ALIGNMENT__ = @as(c_int, 16);
pub const __CHAR_UNSIGNED__ = @as(c_int, 1);
pub const __WCHAR_UNSIGNED__ = @as(c_int, 1);
pub const __WINT_UNSIGNED__ = @as(c_int, 1);
pub const __INT8_TYPE__ = i8;
pub const __INT8_FMTd__ = "hhd";
pub const __INT8_FMTi__ = "hhi";
pub const __INT8_C_SUFFIX__ = "";
pub const __INT16_TYPE__ = c_short;
pub const __INT16_FMTd__ = "hd";
pub const __INT16_FMTi__ = "hi";
pub const __INT16_C_SUFFIX__ = "";
pub const __INT32_TYPE__ = c_int;
pub const __INT32_FMTd__ = "d";
pub const __INT32_FMTi__ = "i";
pub const __INT32_C_SUFFIX__ = "";
pub const __INT64_TYPE__ = c_long;
pub const __INT64_FMTd__ = "ld";
pub const __INT64_FMTi__ = "li";
pub const __UINT8_TYPE__ = u8;
pub const __UINT8_FMTo__ = "hho";
pub const __UINT8_FMTu__ = "hhu";
pub const __UINT8_FMTx__ = "hhx";
pub const __UINT8_FMTX__ = "hhX";
pub const __UINT8_C_SUFFIX__ = "";
pub const __UINT8_MAX__ = @as(c_int, 255);
pub const __INT8_MAX__ = @as(c_int, 127);
pub const __UINT16_TYPE__ = c_ushort;
pub const __UINT16_FMTo__ = "ho";
pub const __UINT16_FMTu__ = "hu";
pub const __UINT16_FMTx__ = "hx";
pub const __UINT16_FMTX__ = "hX";
pub const __UINT16_C_SUFFIX__ = "";
pub const __UINT16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __INT16_MAX__ = @as(c_int, 32767);
pub const __UINT32_TYPE__ = c_uint;
pub const __UINT32_FMTo__ = "o";
pub const __UINT32_FMTu__ = "u";
pub const __UINT32_FMTx__ = "x";
pub const __UINT32_FMTX__ = "X";
pub const __UINT32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __INT32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __UINT64_TYPE__ = c_ulong;
pub const __UINT64_FMTo__ = "lo";
pub const __UINT64_FMTu__ = "lu";
pub const __UINT64_FMTx__ = "lx";
pub const __UINT64_FMTX__ = "lX";
pub const __UINT64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __INT64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INT_LEAST8_TYPE__ = i8;
pub const __INT_LEAST8_MAX__ = @as(c_int, 127);
pub const __INT_LEAST8_WIDTH__ = @as(c_int, 8);
pub const __INT_LEAST8_FMTd__ = "hhd";
pub const __INT_LEAST8_FMTi__ = "hhi";
pub const __UINT_LEAST8_TYPE__ = u8;
pub const __UINT_LEAST8_MAX__ = @as(c_int, 255);
pub const __UINT_LEAST8_FMTo__ = "hho";
pub const __UINT_LEAST8_FMTu__ = "hhu";
pub const __UINT_LEAST8_FMTx__ = "hhx";
pub const __UINT_LEAST8_FMTX__ = "hhX";
pub const __INT_LEAST16_TYPE__ = c_short;
pub const __INT_LEAST16_MAX__ = @as(c_int, 32767);
pub const __INT_LEAST16_WIDTH__ = @as(c_int, 16);
pub const __INT_LEAST16_FMTd__ = "hd";
pub const __INT_LEAST16_FMTi__ = "hi";
pub const __UINT_LEAST16_TYPE__ = c_ushort;
pub const __UINT_LEAST16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __UINT_LEAST16_FMTo__ = "ho";
pub const __UINT_LEAST16_FMTu__ = "hu";
pub const __UINT_LEAST16_FMTx__ = "hx";
pub const __UINT_LEAST16_FMTX__ = "hX";
pub const __INT_LEAST32_TYPE__ = c_int;
pub const __INT_LEAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __INT_LEAST32_WIDTH__ = @as(c_int, 32);
pub const __INT_LEAST32_FMTd__ = "d";
pub const __INT_LEAST32_FMTi__ = "i";
pub const __UINT_LEAST32_TYPE__ = c_uint;
pub const __UINT_LEAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __UINT_LEAST32_FMTo__ = "o";
pub const __UINT_LEAST32_FMTu__ = "u";
pub const __UINT_LEAST32_FMTx__ = "x";
pub const __UINT_LEAST32_FMTX__ = "X";
pub const __INT_LEAST64_TYPE__ = c_long;
pub const __INT_LEAST64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INT_LEAST64_WIDTH__ = @as(c_int, 64);
pub const __INT_LEAST64_FMTd__ = "ld";
pub const __INT_LEAST64_FMTi__ = "li";
pub const __UINT_LEAST64_TYPE__ = c_ulong;
pub const __UINT_LEAST64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINT_LEAST64_FMTo__ = "lo";
pub const __UINT_LEAST64_FMTu__ = "lu";
pub const __UINT_LEAST64_FMTx__ = "lx";
pub const __UINT_LEAST64_FMTX__ = "lX";
pub const __INT_FAST8_TYPE__ = i8;
pub const __INT_FAST8_MAX__ = @as(c_int, 127);
pub const __INT_FAST8_WIDTH__ = @as(c_int, 8);
pub const __INT_FAST8_FMTd__ = "hhd";
pub const __INT_FAST8_FMTi__ = "hhi";
pub const __UINT_FAST8_TYPE__ = u8;
pub const __UINT_FAST8_MAX__ = @as(c_int, 255);
pub const __UINT_FAST8_FMTo__ = "hho";
pub const __UINT_FAST8_FMTu__ = "hhu";
pub const __UINT_FAST8_FMTx__ = "hhx";
pub const __UINT_FAST8_FMTX__ = "hhX";
pub const __INT_FAST16_TYPE__ = c_short;
pub const __INT_FAST16_MAX__ = @as(c_int, 32767);
pub const __INT_FAST16_WIDTH__ = @as(c_int, 16);
pub const __INT_FAST16_FMTd__ = "hd";
pub const __INT_FAST16_FMTi__ = "hi";
pub const __UINT_FAST16_TYPE__ = c_ushort;
pub const __UINT_FAST16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __UINT_FAST16_FMTo__ = "ho";
pub const __UINT_FAST16_FMTu__ = "hu";
pub const __UINT_FAST16_FMTx__ = "hx";
pub const __UINT_FAST16_FMTX__ = "hX";
pub const __INT_FAST32_TYPE__ = c_int;
pub const __INT_FAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __INT_FAST32_WIDTH__ = @as(c_int, 32);
pub const __INT_FAST32_FMTd__ = "d";
pub const __INT_FAST32_FMTi__ = "i";
pub const __UINT_FAST32_TYPE__ = c_uint;
pub const __UINT_FAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __UINT_FAST32_FMTo__ = "o";
pub const __UINT_FAST32_FMTu__ = "u";
pub const __UINT_FAST32_FMTx__ = "x";
pub const __UINT_FAST32_FMTX__ = "X";
pub const __INT_FAST64_TYPE__ = c_long;
pub const __INT_FAST64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INT_FAST64_WIDTH__ = @as(c_int, 64);
pub const __INT_FAST64_FMTd__ = "ld";
pub const __INT_FAST64_FMTi__ = "li";
pub const __UINT_FAST64_TYPE__ = c_ulong;
pub const __UINT_FAST64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINT_FAST64_FMTo__ = "lo";
pub const __UINT_FAST64_FMTu__ = "lu";
pub const __UINT_FAST64_FMTx__ = "lx";
pub const __UINT_FAST64_FMTX__ = "lX";
pub const __USER_LABEL_PREFIX__ = "";
pub const __FINITE_MATH_ONLY__ = @as(c_int, 0);
pub const __GNUC_STDC_INLINE__ = @as(c_int, 1);
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL = @as(c_int, 1);
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_INT_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_LONG_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_BOOL_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_SHORT_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_INT_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_LONG_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_LLONG_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_POINTER_LOCK_FREE = @as(c_int, 2);
pub const __NO_INLINE__ = @as(c_int, 1);
pub const __PIC__ = @as(c_int, 2);
pub const __pic__ = @as(c_int, 2);
pub const __FLT_EVAL_METHOD__ = @as(c_int, 0);
pub const __FLT_RADIX__ = @as(c_int, 2);
pub const __DECIMAL_DIG__ = __LDBL_DECIMAL_DIG__;
pub const __SSP_STRONG__ = @as(c_int, 2);
pub const __AARCH64EL__ = @as(c_int, 1);
pub const __aarch64__ = @as(c_int, 1);
pub const __AARCH64_CMODEL_SMALL__ = @as(c_int, 1);
pub const __ARM_ACLE = @as(c_int, 200);
pub const __ARM_ARCH = @as(c_int, 8);
pub const __ARM_ARCH_PROFILE = 'A';
pub const __ARM_64BIT_STATE = @as(c_int, 1);
pub const __ARM_PCS_AAPCS64 = @as(c_int, 1);
pub const __ARM_ARCH_ISA_A64 = @as(c_int, 1);
pub const __ARM_FEATURE_CLZ = @as(c_int, 1);
pub const __ARM_FEATURE_FMA = @as(c_int, 1);
pub const __ARM_FEATURE_LDREX = @as(c_int, 0xF);
pub const __ARM_FEATURE_IDIV = @as(c_int, 1);
pub const __ARM_FEATURE_DIV = @as(c_int, 1);
pub const __ARM_FEATURE_NUMERIC_MAXMIN = @as(c_int, 1);
pub const __ARM_FEATURE_DIRECTED_ROUNDING = @as(c_int, 1);
pub const __ARM_ALIGN_MAX_STACK_PWR = @as(c_int, 4);
pub const __ARM_FP = @as(c_int, 0xE);
pub const __ARM_FP16_FORMAT_IEEE = @as(c_int, 1);
pub const __ARM_FP16_ARGS = @as(c_int, 1);
pub const __ARM_SIZEOF_WCHAR_T = @as(c_int, 4);
pub const __ARM_SIZEOF_MINIMAL_ENUM = @as(c_int, 4);
pub const __ARM_NEON = @as(c_int, 1);
pub const __ARM_NEON_FP = @as(c_int, 0xE);
pub const __ARM_FEATURE_UNALIGNED = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 = @as(c_int, 1);
pub const unix = @as(c_int, 1);
pub const __unix = @as(c_int, 1);
pub const __unix__ = @as(c_int, 1);
pub const linux = @as(c_int, 1);
pub const __linux = @as(c_int, 1);
pub const __linux__ = @as(c_int, 1);
pub const __ELF__ = @as(c_int, 1);
pub const __gnu_linux__ = @as(c_int, 1);
pub const __STDC__ = @as(c_int, 1);
pub const __STDC_HOSTED__ = @as(c_int, 1);
pub const __STDC_VERSION__ = @as(c_long, 201710);
pub const __STDC_UTF_16__ = @as(c_int, 1);
pub const __STDC_UTF_32__ = @as(c_int, 1);
pub const __GLIBC_MINOR__ = @as(c_int, 19);
pub const _DEBUG = @as(c_int, 1);
pub const __GCC_HAVE_DWARF2_CFI_ASM = @as(c_int, 1);
pub const __GST_H__ = "";
pub const __G_LIB_H__ = "";
pub const __GLIB_H_INSIDE__ = "";
pub const __G_ALLOCA_H__ = "";
pub const __G_TYPES_H__ = "";
pub const __GLIBCONFIG_H__ = "";
pub const __G_MACROS_H__ = "";
pub const __STDDEF_H = "";
pub const __need_ptrdiff_t = "";
pub const __need_size_t = "";
pub const __need_wchar_t = "";
pub const __need_NULL = "";
pub const __need_STDDEF_H_misc = "";
pub const _PTRDIFF_T = "";
pub const _SIZE_T = "";
pub const _WCHAR_T = "";
pub const NULL = @import("std").zig.c_translation.cast(?*anyopaque, @as(c_int, 0));
pub const __CLANG_MAX_ALIGN_T_DEFINED = "";
pub inline fn G_GNUC_CHECK_VERSION(major: anytype, minor: anytype) @TypeOf((__GNUC__ > major) or ((__GNUC__ == major) and (__GNUC_MINOR__ >= minor))) {
    return (__GNUC__ > major) or ((__GNUC__ == major) and (__GNUC_MINOR__ >= minor));
}
pub const G_CAN_INLINE = "";
pub const g_macro__has_builtin = __has_builtin;
pub const G_GNUC_FUNCTION = "" ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR(G_STRFUNC);
pub const G_GNUC_PRETTY_FUNCTION = "" ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR(G_STRFUNC);
pub const G_ANALYZER_ANALYZING = @as(c_int, 0);
pub const G_ANALYZER_NORETURN = "";
pub inline fn G_STRINGIFY(macro_or_string: anytype) @TypeOf(G_STRINGIFY_ARG(macro_or_string)) {
    return G_STRINGIFY_ARG(macro_or_string);
}
pub inline fn G_PASTE(identifier1: anytype, identifier2: anytype) @TypeOf(G_PASTE_ARGS(identifier1, identifier2)) {
    return G_PASTE_ARGS(identifier1, identifier2);
}
pub const G_BEGIN_DECLS = "";
pub const G_END_DECLS = "";
pub const FALSE = @as(c_int, 0);
pub const TRUE = !(FALSE != 0);
pub inline fn MAX(a: anytype, b: anytype) @TypeOf(if (a > b) a else b) {
    return if (a > b) a else b;
}
pub inline fn MIN(a: anytype, b: anytype) @TypeOf(if (a < b) a else b) {
    return if (a < b) a else b;
}
pub inline fn ABS(a: anytype) @TypeOf(if (a < @as(c_int, 0)) -a else a) {
    return if (a < @as(c_int, 0)) -a else a;
}
pub inline fn CLAMP(x: anytype, low: anytype, high: anytype) @TypeOf(if (x > high) high else if (x < low) low else x) {
    return if (x > high) high else if (x < low) low else x;
}
pub inline fn G_APPROX_VALUE(a: anytype, b: anytype, epsilon: anytype) @TypeOf((if (a > b) a - b else b - a) < epsilon) {
    return (if (a > b) a - b else b - a) < epsilon;
}
pub inline fn GPOINTER_TO_SIZE(p: anytype) gsize {
    return @import("std").zig.c_translation.cast(gsize, p);
}
pub inline fn GSIZE_TO_POINTER(s: anytype) gpointer {
    return @import("std").zig.c_translation.cast(gpointer, @import("std").zig.c_translation.cast(gsize, s));
}
pub inline fn G_STRUCT_OFFSET(struct_type: anytype, member: anytype) glong {
    return @import("std").zig.c_translation.cast(glong, offsetof(struct_type, member));
}
pub inline fn G_STRUCT_MEMBER_P(struct_p: anytype, struct_offset: anytype) gpointer {
    return @import("std").zig.c_translation.cast(gpointer, @import("std").zig.c_translation.cast([*c]guint8, struct_p) + @import("std").zig.c_translation.cast(glong, struct_offset));
}
pub inline fn G_LIKELY(expr: anytype) @TypeOf(expr) {
    return expr;
}
pub inline fn G_UNLIKELY(expr: anytype) @TypeOf(expr) {
    return expr;
}
pub const GLIB_DEPRECATED = G_DEPRECATED ++ _GLIB_EXTERN;
pub inline fn GLIB_UNAVAILABLE_STATIC_INLINE(maj: anytype, min: anytype) @TypeOf(G_UNAVAILABLE(maj, min)) {
    return G_UNAVAILABLE(maj, min);
}
pub const GLIB_DEPRECATED_ENUMERATOR = G_DEPRECATED;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_FOR(f: anytype) @TypeOf(G_DEPRECATED_FOR(f)) {
    return G_DEPRECATED_FOR(f);
}
pub inline fn GLIB_UNAVAILABLE_ENUMERATOR(maj: anytype, min: anytype) @TypeOf(G_UNAVAILABLE(maj, min)) {
    return G_UNAVAILABLE(maj, min);
}
pub const GLIB_DEPRECATED_TYPE = G_DEPRECATED;
pub inline fn GLIB_DEPRECATED_TYPE_FOR(f: anytype) @TypeOf(G_DEPRECATED_FOR(f)) {
    return G_DEPRECATED_FOR(f);
}
pub inline fn GLIB_UNAVAILABLE_TYPE(maj: anytype, min: anytype) @TypeOf(G_UNAVAILABLE(maj, min)) {
    return G_UNAVAILABLE(maj, min);
}
pub inline fn _GLIB_DEFINE_AUTOPTR_CHAINUP(ModuleObjName: anytype, ParentName: anytype) @TypeOf(_GLIB_DEFINE_AUTOPTR_CLEANUP_FUNCS(ModuleObjName, ParentName, _GLIB_AUTOPTR_CLEAR_FUNC_NAME(ParentName))) {
    return _GLIB_DEFINE_AUTOPTR_CLEANUP_FUNCS(ModuleObjName, ParentName, _GLIB_AUTOPTR_CLEAR_FUNC_NAME(ParentName));
}
pub inline fn G_DEFINE_AUTOPTR_CLEANUP_FUNC(TypeName: anytype, func: anytype) @TypeOf(_GLIB_DEFINE_AUTOPTR_CLEANUP_FUNCS(TypeName, TypeName, func)) {
    return _GLIB_DEFINE_AUTOPTR_CLEANUP_FUNCS(TypeName, TypeName, func);
}
pub const g_autofree = _GLIB_CLEANUP(g_autoptr_cleanup_generic_gfree);
pub const __CLANG_LIMITS_H = "";
pub const _GCC_LIMITS_H_ = "";
pub const _LIBC_LIMITS_H_ = @as(c_int, 1);
pub const __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION = "";
pub const _FEATURES_H = @as(c_int, 1);
pub const __KERNEL_STRICT_NAMES = "";
pub inline fn __GNUC_PREREQ(maj: anytype, min: anytype) @TypeOf(((__GNUC__ << @as(c_int, 16)) + __GNUC_MINOR__) >= ((maj << @as(c_int, 16)) + min)) {
    return ((__GNUC__ << @as(c_int, 16)) + __GNUC_MINOR__) >= ((maj << @as(c_int, 16)) + min);
}
pub inline fn __glibc_clang_prereq(maj: anytype, min: anytype) @TypeOf(((__clang_major__ << @as(c_int, 16)) + __clang_minor__) >= ((maj << @as(c_int, 16)) + min)) {
    return ((__clang_major__ << @as(c_int, 16)) + __clang_minor__) >= ((maj << @as(c_int, 16)) + min);
}
pub const _DEFAULT_SOURCE = @as(c_int, 1);
pub const __GLIBC_USE_ISOC2X = @as(c_int, 0);
pub const __USE_ISOC11 = @as(c_int, 1);
pub const __USE_ISOC99 = @as(c_int, 1);
pub const __USE_ISOC95 = @as(c_int, 1);
pub const __USE_POSIX_IMPLICITLY = @as(c_int, 1);
pub const _POSIX_SOURCE = @as(c_int, 1);
pub const _POSIX_C_SOURCE = @as(c_long, 200809);
pub const __USE_POSIX = @as(c_int, 1);
pub const __USE_POSIX2 = @as(c_int, 1);
pub const __USE_POSIX199309 = @as(c_int, 1);
pub const __USE_POSIX199506 = @as(c_int, 1);
pub const __USE_XOPEN2K = @as(c_int, 1);
pub const __USE_XOPEN2K8 = @as(c_int, 1);
pub const _ATFILE_SOURCE = @as(c_int, 1);
pub const __WORDSIZE = @as(c_int, 64);
pub const __WORDSIZE_TIME64_COMPAT32 = @as(c_int, 0);
pub const __TIMESIZE = __WORDSIZE;
pub const __USE_MISC = @as(c_int, 1);
pub const __USE_ATFILE = @as(c_int, 1);
pub const __USE_FORTIFY_LEVEL = @as(c_int, 0);
pub const __GLIBC_USE_DEPRECATED_GETS = @as(c_int, 0);
pub const __GLIBC_USE_DEPRECATED_SCANF = @as(c_int, 0);
pub const _STDC_PREDEF_H = @as(c_int, 1);
pub const __STDC_IEC_559__ = @as(c_int, 1);
pub const __STDC_IEC_559_COMPLEX__ = @as(c_int, 1);
pub const __STDC_ISO_10646__ = @as(c_long, 201706);
pub const __GNU_LIBRARY__ = @as(c_int, 6);
pub const __GLIBC__ = @as(c_int, 2);
pub inline fn __GLIBC_PREREQ(maj: anytype, min: anytype) @TypeOf(((__GLIBC__ << @as(c_int, 16)) + __GLIBC_MINOR__) >= ((maj << @as(c_int, 16)) + min)) {
    return ((__GLIBC__ << @as(c_int, 16)) + __GLIBC_MINOR__) >= ((maj << @as(c_int, 16)) + min);
}
pub const _SYS_CDEFS_H = @as(c_int, 1);
pub inline fn __glibc_has_builtin(name: anytype) @TypeOf(__has_builtin(name)) {
    return __has_builtin(name);
}
pub const __LEAF = "";
pub const __LEAF_ATTR = "";
pub inline fn __P(args: anytype) @TypeOf(args) {
    return args;
}
pub inline fn __PMT(args: anytype) @TypeOf(args) {
    return args;
}
pub const __ptr_t = ?*anyopaque;
pub const __BEGIN_DECLS = "";
pub const __END_DECLS = "";
pub inline fn __bos(ptr: anytype) @TypeOf(__builtin_object_size(ptr, __USE_FORTIFY_LEVEL > @as(c_int, 1))) {
    return __builtin_object_size(ptr, __USE_FORTIFY_LEVEL > @as(c_int, 1));
}
pub inline fn __bos0(ptr: anytype) @TypeOf(__builtin_object_size(ptr, @as(c_int, 0))) {
    return __builtin_object_size(ptr, @as(c_int, 0));
}
pub inline fn __glibc_objsize0(__o: anytype) @TypeOf(__bos0(__o)) {
    return __bos0(__o);
}
pub inline fn __glibc_objsize(__o: anytype) @TypeOf(__bos(__o)) {
    return __bos(__o);
}
pub inline fn __glibc_safe_len_cond(__l: anytype, __s: anytype, __osz: anytype) @TypeOf(__l <= (__osz / __s)) {
    return __l <= (__osz / __s);
}
pub inline fn __glibc_safe_or_unknown_len(__l: anytype, __s: anytype, __osz: anytype) @TypeOf(((__builtin_constant_p(__osz) != 0) and (__osz == (__SIZE_TYPE__ - @as(c_int, 1)))) or (((__glibc_unsigned_or_positive(__l) != 0) and (__builtin_constant_p(__glibc_safe_len_cond(__SIZE_TYPE__(__l), __s, __osz)) != 0)) and (__glibc_safe_len_cond(__SIZE_TYPE__(__l), __s, __osz) != 0))) {
    return ((__builtin_constant_p(__osz) != 0) and (__osz == (__SIZE_TYPE__ - @as(c_int, 1)))) or (((__glibc_unsigned_or_positive(__l) != 0) and (__builtin_constant_p(__glibc_safe_len_cond(__SIZE_TYPE__(__l), __s, __osz)) != 0)) and (__glibc_safe_len_cond(__SIZE_TYPE__(__l), __s, __osz) != 0));
}
pub inline fn __glibc_unsafe_len(__l: anytype, __s: anytype, __osz: anytype) @TypeOf(((__glibc_unsigned_or_positive(__l) != 0) and (__builtin_constant_p(__glibc_safe_len_cond(__SIZE_TYPE__(__l), __s, __osz)) != 0)) and !(__glibc_safe_len_cond(__SIZE_TYPE__(__l), __s, __osz) != 0)) {
    return ((__glibc_unsigned_or_positive(__l) != 0) and (__builtin_constant_p(__glibc_safe_len_cond(__SIZE_TYPE__(__l), __s, __osz)) != 0)) and !(__glibc_safe_len_cond(__SIZE_TYPE__(__l), __s, __osz) != 0);
}
pub const __glibc_c99_flexarr_available = @as(c_int, 1);
pub inline fn __ASMNAME(cname: anytype) @TypeOf(__ASMNAME2(__USER_LABEL_PREFIX__, cname)) {
    return __ASMNAME2(__USER_LABEL_PREFIX__, cname);
}
pub const __wur = "";
pub const __fortify_function = __extern_always_inline ++ __attribute_artificial__;
pub inline fn __glibc_unlikely(cond: anytype) @TypeOf(__builtin_expect(cond, @as(c_int, 0))) {
    return __builtin_expect(cond, @as(c_int, 0));
}
pub inline fn __glibc_likely(cond: anytype) @TypeOf(__builtin_expect(cond, @as(c_int, 1))) {
    return __builtin_expect(cond, @as(c_int, 1));
}
pub const __attribute_nonstring__ = "";
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = @as(c_int, 0);
pub inline fn __LDBL_REDIR1(name: anytype, proto: anytype, alias: anytype) @TypeOf(name ++ proto) {
    _ = alias;
    return name ++ proto;
}
pub inline fn __LDBL_REDIR(name: anytype, proto: anytype) @TypeOf(name ++ proto) {
    return name ++ proto;
}
pub inline fn __LDBL_REDIR1_NTH(name: anytype, proto: anytype, alias: anytype) @TypeOf(name ++ proto ++ __THROW) {
    _ = alias;
    return name ++ proto ++ __THROW;
}
pub inline fn __LDBL_REDIR_NTH(name: anytype, proto: anytype) @TypeOf(name ++ proto ++ __THROW) {
    return name ++ proto ++ __THROW;
}
pub inline fn __REDIRECT_LDBL(name: anytype, proto: anytype, alias: anytype) @TypeOf(__REDIRECT(name, proto, alias)) {
    return __REDIRECT(name, proto, alias);
}
pub inline fn __REDIRECT_NTH_LDBL(name: anytype, proto: anytype, alias: anytype) @TypeOf(__REDIRECT_NTH(name, proto, alias)) {
    return __REDIRECT_NTH(name, proto, alias);
}
pub const __HAVE_GENERIC_SELECTION = @as(c_int, 1);
pub const __attr_dealloc_free = "";
pub const __stub___compat_bdflush = "";
pub const __stub___compat_create_module = "";
pub const __stub___compat_get_kernel_syms = "";
pub const __stub___compat_query_module = "";
pub const __stub___compat_uselib = "";
pub const __stub_chflags = "";
pub const __stub_fchflags = "";
pub const __stub_gtty = "";
pub const __stub_revoke = "";
pub const __stub_setlogin = "";
pub const __stub_sigreturn = "";
pub const __stub_stty = "";
pub const __GLIBC_USE_LIB_EXT2 = @as(c_int, 0);
pub const __GLIBC_USE_IEC_60559_BFP_EXT = @as(c_int, 0);
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X = @as(c_int, 0);
pub const __GLIBC_USE_IEC_60559_EXT = @as(c_int, 0);
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT = @as(c_int, 0);
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = @as(c_int, 0);
pub const __GLIBC_USE_IEC_60559_TYPES_EXT = @as(c_int, 0);
pub const MB_LEN_MAX = @as(c_int, 16);
pub const LLONG_MIN = -LLONG_MAX - @as(c_int, 1);
pub const LLONG_MAX = __LONG_LONG_MAX__;
pub const ULLONG_MAX = (LLONG_MAX * @as(c_ulonglong, 2)) + @as(c_int, 1);
pub const _BITS_POSIX1_LIM_H = @as(c_int, 1);
pub const _POSIX_AIO_LISTIO_MAX = @as(c_int, 2);
pub const _POSIX_AIO_MAX = @as(c_int, 1);
pub const _POSIX_ARG_MAX = @as(c_int, 4096);
pub const _POSIX_CHILD_MAX = @as(c_int, 25);
pub const _POSIX_DELAYTIMER_MAX = @as(c_int, 32);
pub const _POSIX_HOST_NAME_MAX = @as(c_int, 255);
pub const _POSIX_LINK_MAX = @as(c_int, 8);
pub const _POSIX_LOGIN_NAME_MAX = @as(c_int, 9);
pub const _POSIX_MAX_CANON = @as(c_int, 255);
pub const _POSIX_MAX_INPUT = @as(c_int, 255);
pub const _POSIX_MQ_OPEN_MAX = @as(c_int, 8);
pub const _POSIX_MQ_PRIO_MAX = @as(c_int, 32);
pub const _POSIX_NAME_MAX = @as(c_int, 14);
pub const _POSIX_NGROUPS_MAX = @as(c_int, 8);
pub const _POSIX_OPEN_MAX = @as(c_int, 20);
pub const _POSIX_PATH_MAX = @as(c_int, 256);
pub const _POSIX_PIPE_BUF = @as(c_int, 512);
pub const _POSIX_RE_DUP_MAX = @as(c_int, 255);
pub const _POSIX_RTSIG_MAX = @as(c_int, 8);
pub const _POSIX_SEM_NSEMS_MAX = @as(c_int, 256);
pub const _POSIX_SEM_VALUE_MAX = @as(c_int, 32767);
pub const _POSIX_SIGQUEUE_MAX = @as(c_int, 32);
pub const _POSIX_SSIZE_MAX = @as(c_int, 32767);
pub const _POSIX_STREAM_MAX = @as(c_int, 8);
pub const _POSIX_SYMLINK_MAX = @as(c_int, 255);
pub const _POSIX_SYMLOOP_MAX = @as(c_int, 8);
pub const _POSIX_TIMER_MAX = @as(c_int, 32);
pub const _POSIX_TTY_NAME_MAX = @as(c_int, 9);
pub const _POSIX_TZNAME_MAX = @as(c_int, 6);
pub const _POSIX_CLOCKRES_MIN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 20000000, .decimal);
pub const __undef_NR_OPEN = "";
pub const __undef_LINK_MAX = "";
pub const __undef_OPEN_MAX = "";
pub const __undef_ARG_MAX = "";
pub const _LINUX_LIMITS_H = "";
pub const NR_OPEN = @as(c_int, 1024);
pub const NGROUPS_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65536, .decimal);
pub const ARG_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 131072, .decimal);
pub const LINK_MAX = @as(c_int, 127);
pub const MAX_CANON = @as(c_int, 255);
pub const MAX_INPUT = @as(c_int, 255);
pub const NAME_MAX = @as(c_int, 255);
pub const PATH_MAX = @as(c_int, 4096);
pub const PIPE_BUF = @as(c_int, 4096);
pub const XATTR_NAME_MAX = @as(c_int, 255);
pub const XATTR_SIZE_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65536, .decimal);
pub const XATTR_LIST_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65536, .decimal);
pub const RTSIG_MAX = @as(c_int, 32);
pub const _POSIX_THREAD_KEYS_MAX = @as(c_int, 128);
pub const PTHREAD_KEYS_MAX = @as(c_int, 1024);
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS = @as(c_int, 4);
pub const PTHREAD_DESTRUCTOR_ITERATIONS = _POSIX_THREAD_DESTRUCTOR_ITERATIONS;
pub const _POSIX_THREAD_THREADS_MAX = @as(c_int, 64);
pub const AIO_PRIO_DELTA_MAX = @as(c_int, 20);
pub const PTHREAD_STACK_MIN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 131072, .decimal);
pub const DELAYTIMER_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const TTY_NAME_MAX = @as(c_int, 32);
pub const LOGIN_NAME_MAX = @as(c_int, 256);
pub const HOST_NAME_MAX = @as(c_int, 64);
pub const MQ_PRIO_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 32768, .decimal);
pub const SEM_VALUE_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const SSIZE_MAX = LONG_MAX;
pub const _BITS_POSIX2_LIM_H = @as(c_int, 1);
pub const _POSIX2_BC_BASE_MAX = @as(c_int, 99);
pub const _POSIX2_BC_DIM_MAX = @as(c_int, 2048);
pub const _POSIX2_BC_SCALE_MAX = @as(c_int, 99);
pub const _POSIX2_BC_STRING_MAX = @as(c_int, 1000);
pub const _POSIX2_COLL_WEIGHTS_MAX = @as(c_int, 2);
pub const _POSIX2_EXPR_NEST_MAX = @as(c_int, 32);
pub const _POSIX2_LINE_MAX = @as(c_int, 2048);
pub const _POSIX2_RE_DUP_MAX = @as(c_int, 255);
pub const _POSIX2_CHARCLASS_NAME_MAX = @as(c_int, 14);
pub const BC_BASE_MAX = _POSIX2_BC_BASE_MAX;
pub const BC_DIM_MAX = _POSIX2_BC_DIM_MAX;
pub const BC_SCALE_MAX = _POSIX2_BC_SCALE_MAX;
pub const BC_STRING_MAX = _POSIX2_BC_STRING_MAX;
pub const COLL_WEIGHTS_MAX = @as(c_int, 255);
pub const EXPR_NEST_MAX = _POSIX2_EXPR_NEST_MAX;
pub const LINE_MAX = _POSIX2_LINE_MAX;
pub const CHARCLASS_NAME_MAX = @as(c_int, 2048);
pub const RE_DUP_MAX = @as(c_int, 0x7fff);
pub const SCHAR_MAX = __SCHAR_MAX__;
pub const SHRT_MAX = __SHRT_MAX__;
pub const INT_MAX = __INT_MAX__;
pub const LONG_MAX = __LONG_MAX__;
pub const SCHAR_MIN = -__SCHAR_MAX__ - @as(c_int, 1);
pub const SHRT_MIN = -__SHRT_MAX__ - @as(c_int, 1);
pub const INT_MIN = -__INT_MAX__ - @as(c_int, 1);
pub const LONG_MIN = -__LONG_MAX__ - @as(c_long, 1);
pub const UCHAR_MAX = (__SCHAR_MAX__ * @as(c_int, 2)) + @as(c_int, 1);
pub const USHRT_MAX = (__SHRT_MAX__ * @as(c_int, 2)) + @as(c_int, 1);
pub const UINT_MAX = (__INT_MAX__ * @as(c_uint, 2)) + @as(c_uint, 1);
pub const ULONG_MAX = (__LONG_MAX__ * @as(c_ulong, 2)) + @as(c_ulong, 1);
pub const CHAR_BIT = __CHAR_BIT__;
pub const CHAR_MIN = @as(c_int, 0);
pub const CHAR_MAX = UCHAR_MAX;
pub const __CLANG_FLOAT_H = "";
pub const FLT_EVAL_METHOD = __FLT_EVAL_METHOD__;
pub const FLT_RADIX = __FLT_RADIX__;
pub const FLT_MANT_DIG = __FLT_MANT_DIG__;
pub const DBL_MANT_DIG = __DBL_MANT_DIG__;
pub const LDBL_MANT_DIG = __LDBL_MANT_DIG__;
pub const DECIMAL_DIG = __DECIMAL_DIG__;
pub const FLT_DIG = __FLT_DIG__;
pub const DBL_DIG = __DBL_DIG__;
pub const LDBL_DIG = __LDBL_DIG__;
pub const FLT_MIN_EXP = __FLT_MIN_EXP__;
pub const DBL_MIN_EXP = __DBL_MIN_EXP__;
pub const LDBL_MIN_EXP = __LDBL_MIN_EXP__;
pub const FLT_MIN_10_EXP = __FLT_MIN_10_EXP__;
pub const DBL_MIN_10_EXP = __DBL_MIN_10_EXP__;
pub const LDBL_MIN_10_EXP = __LDBL_MIN_10_EXP__;
pub const FLT_MAX_EXP = __FLT_MAX_EXP__;
pub const DBL_MAX_EXP = __DBL_MAX_EXP__;
pub const LDBL_MAX_EXP = __LDBL_MAX_EXP__;
pub const FLT_MAX_10_EXP = __FLT_MAX_10_EXP__;
pub const DBL_MAX_10_EXP = __DBL_MAX_10_EXP__;
pub const LDBL_MAX_10_EXP = __LDBL_MAX_10_EXP__;
pub const FLT_MAX = __FLT_MAX__;
pub const DBL_MAX = __DBL_MAX__;
pub const LDBL_MAX = __LDBL_MAX__;
pub const FLT_EPSILON = __FLT_EPSILON__;
pub const DBL_EPSILON = __DBL_EPSILON__;
pub const LDBL_EPSILON = __LDBL_EPSILON__;
pub const FLT_MIN = __FLT_MIN__;
pub const DBL_MIN = __DBL_MIN__;
pub const LDBL_MIN = __LDBL_MIN__;
pub const FLT_TRUE_MIN = __FLT_DENORM_MIN__;
pub const DBL_TRUE_MIN = __DBL_DENORM_MIN__;
pub const LDBL_TRUE_MIN = __LDBL_DENORM_MIN__;
pub const FLT_DECIMAL_DIG = __FLT_DECIMAL_DIG__;
pub const DBL_DECIMAL_DIG = __DBL_DECIMAL_DIG__;
pub const LDBL_DECIMAL_DIG = __LDBL_DECIMAL_DIG__;
pub const FLT_HAS_SUBNORM = __FLT_HAS_DENORM__;
pub const DBL_HAS_SUBNORM = __DBL_HAS_DENORM__;
pub const LDBL_HAS_SUBNORM = __LDBL_HAS_DENORM__;
pub const GLIB_HAVE_ALLOCA_H = "";
pub const GLIB_USING_SYSTEM_PRINTF = "";
pub const G_MINFLOAT = FLT_MIN;
pub const G_MAXFLOAT = FLT_MAX;
pub const G_MINDOUBLE = DBL_MIN;
pub const G_MAXDOUBLE = DBL_MAX;
pub const G_MINSHORT = SHRT_MIN;
pub const G_MAXSHORT = SHRT_MAX;
pub const G_MAXUSHORT = USHRT_MAX;
pub const G_MININT = INT_MIN;
pub const G_MAXINT = INT_MAX;
pub const G_MAXUINT = UINT_MAX;
pub const G_MINLONG = LONG_MIN;
pub const G_MAXLONG = LONG_MAX;
pub const G_MAXULONG = ULONG_MAX;
pub const G_GINT16_MODIFIER = "h";
pub const G_GINT16_FORMAT = "hi";
pub const G_GUINT16_FORMAT = "hu";
pub const G_GINT32_MODIFIER = "";
pub const G_GINT32_FORMAT = "i";
pub const G_GUINT32_FORMAT = "u";
pub const G_HAVE_GINT64 = @as(c_int, 1);
pub const G_GINT64_CONSTANT = @import("std").zig.c_translation.Macros.L_SUFFIX;
pub const G_GUINT64_CONSTANT = @import("std").zig.c_translation.Macros.UL_SUFFIX;
pub const G_GINT64_MODIFIER = "l";
pub const G_GINT64_FORMAT = "li";
pub const G_GUINT64_FORMAT = "lu";
pub const GLIB_SIZEOF_VOID_P = @as(c_int, 8);
pub const GLIB_SIZEOF_LONG = @as(c_int, 8);
pub const GLIB_SIZEOF_SIZE_T = @as(c_int, 8);
pub const GLIB_SIZEOF_SSIZE_T = @as(c_int, 8);
pub const G_GSIZE_MODIFIER = "l";
pub const G_GSSIZE_MODIFIER = "l";
pub const G_GSIZE_FORMAT = "lu";
pub const G_GSSIZE_FORMAT = "li";
pub const G_MAXSIZE = G_MAXULONG;
pub const G_MINSSIZE = G_MINLONG;
pub const G_MAXSSIZE = G_MAXLONG;
pub const G_MINOFFSET = G_MININT64;
pub const G_MAXOFFSET = G_MAXINT64;
pub const G_GOFFSET_MODIFIER = G_GINT64_MODIFIER;
pub const G_GOFFSET_FORMAT = G_GINT64_FORMAT;
pub inline fn G_GOFFSET_CONSTANT(val: anytype) @TypeOf(G_GINT64_CONSTANT(val)) {
    return G_GINT64_CONSTANT(val);
}
pub const G_POLLFD_FORMAT = "%d";
pub inline fn GPOINTER_TO_INT(p: anytype) gint {
    return @import("std").zig.c_translation.cast(gint, @import("std").zig.c_translation.cast(glong, p));
}
pub inline fn GPOINTER_TO_UINT(p: anytype) guint {
    return @import("std").zig.c_translation.cast(guint, @import("std").zig.c_translation.cast(gulong, p));
}
pub inline fn GINT_TO_POINTER(i: anytype) gpointer {
    return @import("std").zig.c_translation.cast(gpointer, @import("std").zig.c_translation.cast(glong, i));
}
pub inline fn GUINT_TO_POINTER(u: anytype) gpointer {
    return @import("std").zig.c_translation.cast(gpointer, @import("std").zig.c_translation.cast(gulong, u));
}
pub const G_GINTPTR_MODIFIER = "l";
pub const G_GINTPTR_FORMAT = "li";
pub const G_GUINTPTR_FORMAT = "lu";
pub const GLIB_MAJOR_VERSION = @as(c_int, 2);
pub const GLIB_MINOR_VERSION = @as(c_int, 72);
pub const GLIB_MICRO_VERSION = @as(c_int, 3);
pub const G_OS_UNIX = "";
pub const G_VA_COPY = va_copy;
pub const G_HAVE_ISO_VARARGS = @as(c_int, 1);
pub const G_HAVE_GROWING_STACK = @as(c_int, 0);
pub const G_HAVE_GNUC_VISIBILITY = @as(c_int, 1);
pub const G_HAVE_GNUC_VARARGS = @as(c_int, 1);
pub const G_THREADS_ENABLED = "";
pub const G_THREADS_IMPL_POSIX = "";
pub const G_ATOMIC_LOCK_FREE = "";
pub inline fn GINT16_TO_LE(val: anytype) gint16 {
    return @import("std").zig.c_translation.cast(gint16, val);
}
pub inline fn GUINT16_TO_LE(val: anytype) guint16 {
    return @import("std").zig.c_translation.cast(guint16, val);
}
pub inline fn GINT16_TO_BE(val: anytype) gint16 {
    return @import("std").zig.c_translation.cast(gint16, GUINT16_SWAP_LE_BE(val));
}
pub inline fn GUINT16_TO_BE(val: anytype) @TypeOf(GUINT16_SWAP_LE_BE(val)) {
    return GUINT16_SWAP_LE_BE(val);
}
pub inline fn GINT32_TO_LE(val: anytype) gint32 {
    return @import("std").zig.c_translation.cast(gint32, val);
}
pub inline fn GUINT32_TO_LE(val: anytype) guint32 {
    return @import("std").zig.c_translation.cast(guint32, val);
}
pub inline fn GINT32_TO_BE(val: anytype) gint32 {
    return @import("std").zig.c_translation.cast(gint32, GUINT32_SWAP_LE_BE(val));
}
pub inline fn GUINT32_TO_BE(val: anytype) @TypeOf(GUINT32_SWAP_LE_BE(val)) {
    return GUINT32_SWAP_LE_BE(val);
}
pub inline fn GINT64_TO_LE(val: anytype) gint64 {
    return @import("std").zig.c_translation.cast(gint64, val);
}
pub inline fn GUINT64_TO_LE(val: anytype) guint64 {
    return @import("std").zig.c_translation.cast(guint64, val);
}
pub inline fn GINT64_TO_BE(val: anytype) gint64 {
    return @import("std").zig.c_translation.cast(gint64, GUINT64_SWAP_LE_BE(val));
}
pub inline fn GUINT64_TO_BE(val: anytype) @TypeOf(GUINT64_SWAP_LE_BE(val)) {
    return GUINT64_SWAP_LE_BE(val);
}
pub inline fn GLONG_TO_LE(val: anytype) glong {
    return @import("std").zig.c_translation.cast(glong, GINT64_TO_LE(val));
}
pub inline fn GULONG_TO_LE(val: anytype) gulong {
    return @import("std").zig.c_translation.cast(gulong, GUINT64_TO_LE(val));
}
pub inline fn GLONG_TO_BE(val: anytype) glong {
    return @import("std").zig.c_translation.cast(glong, GINT64_TO_BE(val));
}
pub inline fn GULONG_TO_BE(val: anytype) gulong {
    return @import("std").zig.c_translation.cast(gulong, GUINT64_TO_BE(val));
}
pub inline fn GINT_TO_LE(val: anytype) gint {
    return @import("std").zig.c_translation.cast(gint, GINT32_TO_LE(val));
}
pub inline fn GUINT_TO_LE(val: anytype) guint {
    return @import("std").zig.c_translation.cast(guint, GUINT32_TO_LE(val));
}
pub inline fn GINT_TO_BE(val: anytype) gint {
    return @import("std").zig.c_translation.cast(gint, GINT32_TO_BE(val));
}
pub inline fn GUINT_TO_BE(val: anytype) guint {
    return @import("std").zig.c_translation.cast(guint, GUINT32_TO_BE(val));
}
pub inline fn GSIZE_TO_LE(val: anytype) gsize {
    return @import("std").zig.c_translation.cast(gsize, GUINT64_TO_LE(val));
}
pub inline fn GSSIZE_TO_LE(val: anytype) gssize {
    return @import("std").zig.c_translation.cast(gssize, GINT64_TO_LE(val));
}
pub inline fn GSIZE_TO_BE(val: anytype) gsize {
    return @import("std").zig.c_translation.cast(gsize, GUINT64_TO_BE(val));
}
pub inline fn GSSIZE_TO_BE(val: anytype) gssize {
    return @import("std").zig.c_translation.cast(gssize, GINT64_TO_BE(val));
}
pub const G_BYTE_ORDER = G_LITTLE_ENDIAN;
pub const G_MODULE_SUFFIX = "so";
pub const G_PID_FORMAT = "i";
pub const GLIB_SYSDEF_AF_UNIX = @as(c_int, 1);
pub const GLIB_SYSDEF_AF_INET = @as(c_int, 2);
pub const GLIB_SYSDEF_AF_INET6 = @as(c_int, 10);
pub const GLIB_SYSDEF_MSG_OOB = @as(c_int, 1);
pub const GLIB_SYSDEF_MSG_PEEK = @as(c_int, 2);
pub const GLIB_SYSDEF_MSG_DONTROUTE = @as(c_int, 4);
pub const G_DIR_SEPARATOR = '/';
pub const G_DIR_SEPARATOR_S = "/";
pub const G_SEARCHPATH_SEPARATOR = ':';
pub const G_SEARCHPATH_SEPARATOR_S = ":";
pub const __G_VERSION_MACROS_H__ = "";
pub inline fn G_ENCODE_VERSION(major: anytype, minor: anytype) @TypeOf((major << @as(c_int, 16)) | (minor << @as(c_int, 8))) {
    return (major << @as(c_int, 16)) | (minor << @as(c_int, 8));
}
pub const GLIB_VERSION_2_26 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 26));
pub const GLIB_VERSION_2_28 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 28));
pub const GLIB_VERSION_2_30 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 30));
pub const GLIB_VERSION_2_32 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 32));
pub const GLIB_VERSION_2_34 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 34));
pub const GLIB_VERSION_2_36 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 36));
pub const GLIB_VERSION_2_38 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 38));
pub const GLIB_VERSION_2_40 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 40));
pub const GLIB_VERSION_2_42 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 42));
pub const GLIB_VERSION_2_44 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 44));
pub const GLIB_VERSION_2_46 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 46));
pub const GLIB_VERSION_2_48 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 48));
pub const GLIB_VERSION_2_50 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 50));
pub const GLIB_VERSION_2_52 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 52));
pub const GLIB_VERSION_2_54 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 54));
pub const GLIB_VERSION_2_56 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 56));
pub const GLIB_VERSION_2_58 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 58));
pub const GLIB_VERSION_2_60 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 60));
pub const GLIB_VERSION_2_62 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 62));
pub const GLIB_VERSION_2_64 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 64));
pub const GLIB_VERSION_2_66 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 66));
pub const GLIB_VERSION_2_68 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 68));
pub const GLIB_VERSION_2_70 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 70));
pub const GLIB_VERSION_2_72 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 72));
pub const GLIB_VERSION_CUR_STABLE = G_ENCODE_VERSION(GLIB_MAJOR_VERSION, GLIB_MINOR_VERSION);
pub const GLIB_VERSION_PREV_STABLE = G_ENCODE_VERSION(GLIB_MAJOR_VERSION, GLIB_MINOR_VERSION - @as(c_int, 2));
pub const GLIB_VERSION_MIN_REQUIRED = GLIB_VERSION_CUR_STABLE;
pub const GLIB_VERSION_MAX_ALLOWED = GLIB_VERSION_CUR_STABLE;
pub const GLIB_AVAILABLE_IN_ALL = _GLIB_EXTERN;
pub const GLIB_DEPRECATED_IN_2_26 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_26_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_26 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_26_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_26 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_26_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_26 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_26_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_26 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_MACRO_IN_2_26 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_26 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_26 = "";
pub const GLIB_DEPRECATED_IN_2_28 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_28_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_28 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_28_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_28 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_28_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_28 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_28_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_28 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_MACRO_IN_2_28 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_28 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_28 = "";
pub const GLIB_DEPRECATED_IN_2_30 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_30_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_30 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_30_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_30 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_30_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_30 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_30_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_30 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_MACRO_IN_2_30 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_30 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_30 = "";
pub const GLIB_DEPRECATED_IN_2_32 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_32_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_32 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_32_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_32 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_32_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_32 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_32_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_32 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_MACRO_IN_2_32 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_32 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_32 = "";
pub const GLIB_DEPRECATED_IN_2_34 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_34_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_34 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_34_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_34 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_34_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_34 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_34_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_34 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_MACRO_IN_2_34 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_34 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_34 = "";
pub const GLIB_DEPRECATED_IN_2_36 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_36_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_36 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_36_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_36 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_36_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_36 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_36_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_36 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_MACRO_IN_2_36 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_36 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_36 = "";
pub const GLIB_DEPRECATED_IN_2_38 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_38_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_38 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_38_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_38 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_38_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_38 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_38_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_38 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_MACRO_IN_2_38 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_38 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_38 = "";
pub const GLIB_DEPRECATED_IN_2_40 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_40_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_40 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_40_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_40 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_40_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_40 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_40_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_40 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_MACRO_IN_2_40 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_40 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_40 = "";
pub const GLIB_DEPRECATED_IN_2_42 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_42_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_42 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_42_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_42 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_MACRO_IN_2_42 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_42 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_42 = "";
pub const GLIB_DEPRECATED_IN_2_44 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_44_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_44 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_44_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_44 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_44_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_44 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_44_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_44 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_44 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_44 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_44 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_44 = "";
pub const GLIB_DEPRECATED_IN_2_46 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_46_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_46 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_46_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_46 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_MACRO_IN_2_46 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_46 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_46 = "";
pub const GLIB_DEPRECATED_IN_2_48 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_48_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_48 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_48_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_48 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_48_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_48 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_48_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_48 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_MACRO_IN_2_48 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_48 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_48 = "";
pub const GLIB_DEPRECATED_IN_2_50 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_50_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_50 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_50_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_50 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_50_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_50 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_50_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_50 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_MACRO_IN_2_50 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_50 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_50 = "";
pub const GLIB_DEPRECATED_IN_2_52 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_52_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_52 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_52_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_52 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_52_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_52 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_52_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_52 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_MACRO_IN_2_52 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_52 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_52 = "";
pub const GLIB_DEPRECATED_IN_2_54 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_54_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_54 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_54_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_54 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_54_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_54 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_54_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_54 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_MACRO_IN_2_54 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_54 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_54 = "";
pub const GLIB_DEPRECATED_IN_2_56 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_56_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_56 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_56_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_56 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_56_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_56 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_56_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_56 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_MACRO_IN_2_56 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_56 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_56 = "";
pub const GLIB_DEPRECATED_IN_2_58 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_58_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_58 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_58_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_58 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_58_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_58 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_58_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_58 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_MACRO_IN_2_58 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_58 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_58 = "";
pub const GLIB_DEPRECATED_IN_2_60 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_60_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_60 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_60_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_60 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_60_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_60 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_60_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_60 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_60 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_60 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_60 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_60 = "";
pub const GLIB_DEPRECATED_IN_2_62 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_62_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_62 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_62_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_62 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_62_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_62 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_62_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_62 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_62 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_62 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_62 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_62 = "";
pub const GLIB_DEPRECATED_IN_2_64 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_64_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_64 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_64_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_64 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_64_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_64 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_64_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_64 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_64 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_64 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_64 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_64 = "";
pub const GLIB_DEPRECATED_IN_2_66 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_66_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_66 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_66_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_66 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_66_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_66 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_66_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_66 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_66 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_66 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_66 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_66 = "";
pub const GLIB_DEPRECATED_IN_2_68 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_68_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_68 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_68_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_68 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_68_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_68 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_68_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_68 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_68 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_68 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_68 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_68 = "";
pub const GLIB_DEPRECATED_IN_2_70 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_70_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_70 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_70_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_70 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_70_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_70 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_70_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_70 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_70 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_70 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_70 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_70 = "";
pub const GLIB_DEPRECATED_IN_2_72 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_72_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_72 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_72_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_72 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_72_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_72 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_72_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_72 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_72 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_72 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_72 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_72 = "";
pub const _TIME_H = @as(c_int, 1);
pub const _BITS_TIME_H = @as(c_int, 1);
pub const _BITS_TYPES_H = @as(c_int, 1);
pub const __S16_TYPE = c_short;
pub const __U16_TYPE = c_ushort;
pub const __S32_TYPE = c_int;
pub const __U32_TYPE = c_uint;
pub const __SLONGWORD_TYPE = c_long;
pub const __ULONGWORD_TYPE = c_ulong;
pub const __SQUAD_TYPE = c_long;
pub const __UQUAD_TYPE = c_ulong;
pub const __SWORD_TYPE = c_long;
pub const __UWORD_TYPE = c_ulong;
pub const __SLONG32_TYPE = c_int;
pub const __ULONG32_TYPE = c_uint;
pub const __S64_TYPE = c_long;
pub const __U64_TYPE = c_ulong;
pub const _BITS_TYPESIZES_H = @as(c_int, 1);
pub const __INO_T_TYPE = __ULONGWORD_TYPE;
pub const __OFF_T_TYPE = __SLONGWORD_TYPE;
pub const __RLIM_T_TYPE = __ULONGWORD_TYPE;
pub const __BLKCNT_T_TYPE = __SLONGWORD_TYPE;
pub const __FSBLKCNT_T_TYPE = __ULONGWORD_TYPE;
pub const __FSFILCNT_T_TYPE = __ULONGWORD_TYPE;
pub const __TIME_T_TYPE = __SLONGWORD_TYPE;
pub const __SUSECONDS_T_TYPE = __SLONGWORD_TYPE;
pub const __DEV_T_TYPE = __UQUAD_TYPE;
pub const __UID_T_TYPE = __U32_TYPE;
pub const __GID_T_TYPE = __U32_TYPE;
pub const __INO64_T_TYPE = __UQUAD_TYPE;
pub const __MODE_T_TYPE = __U32_TYPE;
pub const __NLINK_T_TYPE = __U32_TYPE;
pub const __OFF64_T_TYPE = __SQUAD_TYPE;
pub const __PID_T_TYPE = __S32_TYPE;
pub const __RLIM64_T_TYPE = __UQUAD_TYPE;
pub const __BLKCNT64_T_TYPE = __SQUAD_TYPE;
pub const __FSBLKCNT64_T_TYPE = __UQUAD_TYPE;
pub const __FSFILCNT64_T_TYPE = __UQUAD_TYPE;
pub const __FSWORD_T_TYPE = __SWORD_TYPE;
pub const __ID_T_TYPE = __U32_TYPE;
pub const __CLOCK_T_TYPE = __SLONGWORD_TYPE;
pub const __USECONDS_T_TYPE = __U32_TYPE;
pub const __SUSECONDS64_T_TYPE = __SQUAD_TYPE;
pub const __DADDR_T_TYPE = __S32_TYPE;
pub const __KEY_T_TYPE = __S32_TYPE;
pub const __CLOCKID_T_TYPE = __S32_TYPE;
pub const __TIMER_T_TYPE = ?*anyopaque;
pub const __BLKSIZE_T_TYPE = __S32_TYPE;
pub const __SSIZE_T_TYPE = __SWORD_TYPE;
pub const __SYSCALL_SLONG_TYPE = __SLONGWORD_TYPE;
pub const __SYSCALL_ULONG_TYPE = __ULONGWORD_TYPE;
pub const __CPU_MASK_TYPE = __ULONGWORD_TYPE;
pub const __OFF_T_MATCHES_OFF64_T = @as(c_int, 1);
pub const __INO_T_MATCHES_INO64_T = @as(c_int, 1);
pub const __RLIM_T_MATCHES_RLIM64_T = @as(c_int, 1);
pub const __STATFS_MATCHES_STATFS64 = @as(c_int, 1);
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = __WORDSIZE == @as(c_int, 64);
pub const __FD_SETSIZE = @as(c_int, 1024);
pub const _BITS_TIME64_H = @as(c_int, 1);
pub const __TIME64_T_TYPE = __TIME_T_TYPE;
pub const CLOCKS_PER_SEC = @import("std").zig.c_translation.cast(__clock_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 1000000, .decimal));
pub const CLOCK_REALTIME = @as(c_int, 0);
pub const CLOCK_MONOTONIC = @as(c_int, 1);
pub const CLOCK_PROCESS_CPUTIME_ID = @as(c_int, 2);
pub const CLOCK_THREAD_CPUTIME_ID = @as(c_int, 3);
pub const CLOCK_MONOTONIC_RAW = @as(c_int, 4);
pub const CLOCK_REALTIME_COARSE = @as(c_int, 5);
pub const CLOCK_MONOTONIC_COARSE = @as(c_int, 6);
pub const CLOCK_BOOTTIME = @as(c_int, 7);
pub const CLOCK_REALTIME_ALARM = @as(c_int, 8);
pub const CLOCK_BOOTTIME_ALARM = @as(c_int, 9);
pub const CLOCK_TAI = @as(c_int, 11);
pub const TIMER_ABSTIME = @as(c_int, 1);
pub const __clock_t_defined = @as(c_int, 1);
pub const __time_t_defined = @as(c_int, 1);
pub const __struct_tm_defined = @as(c_int, 1);
pub const _STRUCT_TIMESPEC = @as(c_int, 1);
pub const _BITS_ENDIAN_H = @as(c_int, 1);
pub const __LITTLE_ENDIAN = @as(c_int, 1234);
pub const __BIG_ENDIAN = @as(c_int, 4321);
pub const __PDP_ENDIAN = @as(c_int, 3412);
pub const _BITS_ENDIANNESS_H = @as(c_int, 1);
pub const __BYTE_ORDER = __LITTLE_ENDIAN;
pub const __FLOAT_WORD_ORDER = __BYTE_ORDER;
pub inline fn __LONG_LONG_PAIR(HI: anytype, LO: anytype) @TypeOf(HI) {
    return blk: {
        _ = LO;
        break :blk HI;
    };
}
pub const __clockid_t_defined = @as(c_int, 1);
pub const __timer_t_defined = @as(c_int, 1);
pub const __itimerspec_defined = @as(c_int, 1);
pub const __pid_t_defined = "";
pub const _BITS_TYPES_LOCALE_T_H = @as(c_int, 1);
pub const _BITS_TYPES___LOCALE_T_H = @as(c_int, 1);
pub const TIME_UTC = @as(c_int, 1);
pub inline fn __isleap(year: anytype) @TypeOf(((year % @as(c_int, 4)) == @as(c_int, 0)) and (((year % @as(c_int, 100)) != @as(c_int, 0)) or ((year % @as(c_int, 400)) == @as(c_int, 0)))) {
    return ((year % @as(c_int, 4)) == @as(c_int, 0)) and (((year % @as(c_int, 100)) != @as(c_int, 0)) or ((year % @as(c_int, 400)) == @as(c_int, 0)));
}
pub const G_MININT8 = @import("std").zig.c_translation.cast(gint8, -G_MAXINT8 - @as(c_int, 1));
pub const G_MAXINT8 = @import("std").zig.c_translation.cast(gint8, @as(c_int, 0x7f));
pub const G_MAXUINT8 = @import("std").zig.c_translation.cast(guint8, @as(c_int, 0xff));
pub const G_MININT16 = @import("std").zig.c_translation.cast(gint16, -G_MAXINT16 - @as(c_int, 1));
pub const G_MAXINT16 = @import("std").zig.c_translation.cast(gint16, @as(c_int, 0x7fff));
pub const G_MAXUINT16 = @import("std").zig.c_translation.cast(guint16, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffff, .hexadecimal));
pub const G_MININT32 = @import("std").zig.c_translation.cast(gint32, -G_MAXINT32 - @as(c_int, 1));
pub const G_MAXINT32 = @import("std").zig.c_translation.cast(gint32, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x7fffffff, .hexadecimal));
pub const G_MAXUINT32 = @import("std").zig.c_translation.cast(guint32, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffffff, .hexadecimal));
pub const G_MININT64 = @import("std").zig.c_translation.cast(gint64, -G_MAXINT64 - G_GINT64_CONSTANT(@as(c_int, 1)));
pub const G_MAXINT64 = G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_int, 0x7fffffffffffffff, .hexadecimal));
pub const G_MAXUINT64 = G_GUINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffffffffffffff, .hexadecimal));
pub const G_E = 2.7182818284590452353602874713526624977572470937000;
pub const G_LN2 = 0.69314718055994530941723212145817656807550013436026;
pub const G_LN10 = 2.3025850929940456840179914546843642076011014886288;
pub const G_PI = 3.1415926535897932384626433832795028841971693993751;
pub const G_PI_2 = 1.5707963267948966192313216916397514420985846996876;
pub const G_PI_4 = 0.78539816339744830961566084581987572104929234984378;
pub const G_SQRT2 = 1.4142135623730950488016887242096980785696718753769;
pub const G_LITTLE_ENDIAN = @as(c_int, 1234);
pub const G_BIG_ENDIAN = @as(c_int, 4321);
pub const G_PDP_ENDIAN = @as(c_int, 3412);
pub inline fn GUINT16_SWAP_LE_BE_CONSTANT(val: anytype) guint16 {
    return @import("std").zig.c_translation.cast(guint16, @import("std").zig.c_translation.cast(guint16, @import("std").zig.c_translation.cast(guint16, val) >> @as(c_int, 8)) | @import("std").zig.c_translation.cast(guint16, @import("std").zig.c_translation.cast(guint16, val) << @as(c_int, 8)));
}
pub inline fn GUINT32_SWAP_LE_BE_CONSTANT(val: anytype) guint32 {
    return @import("std").zig.c_translation.cast(guint32, ((((@import("std").zig.c_translation.cast(guint32, val) & @import("std").zig.c_translation.cast(guint32, @as(c_uint, 0x000000ff))) << @as(c_int, 24)) | ((@import("std").zig.c_translation.cast(guint32, val) & @import("std").zig.c_translation.cast(guint32, @as(c_uint, 0x0000ff00))) << @as(c_int, 8))) | ((@import("std").zig.c_translation.cast(guint32, val) & @import("std").zig.c_translation.cast(guint32, @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00ff0000, .hexadecimal))) >> @as(c_int, 8))) | ((@import("std").zig.c_translation.cast(guint32, val) & @import("std").zig.c_translation.cast(guint32, @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xff000000, .hexadecimal))) >> @as(c_int, 24)));
}
pub inline fn GUINT64_SWAP_LE_BE_CONSTANT(val: anytype) guint64 {
    return @import("std").zig.c_translation.cast(guint64, ((((((((@import("std").zig.c_translation.cast(guint64, val) & @import("std").zig.c_translation.cast(guint64, G_GINT64_CONSTANT(@as(c_uint, 0x00000000000000ff)))) << @as(c_int, 56)) | ((@import("std").zig.c_translation.cast(guint64, val) & @import("std").zig.c_translation.cast(guint64, G_GINT64_CONSTANT(@as(c_uint, 0x000000000000ff00)))) << @as(c_int, 40))) | ((@import("std").zig.c_translation.cast(guint64, val) & @import("std").zig.c_translation.cast(guint64, G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x0000000000ff0000, .hexadecimal)))) << @as(c_int, 24))) | ((@import("std").zig.c_translation.cast(guint64, val) & @import("std").zig.c_translation.cast(guint64, G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00000000ff000000, .hexadecimal)))) << @as(c_int, 8))) | ((@import("std").zig.c_translation.cast(guint64, val) & @import("std").zig.c_translation.cast(guint64, G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x000000ff00000000, .hexadecimal)))) >> @as(c_int, 8))) | ((@import("std").zig.c_translation.cast(guint64, val) & @import("std").zig.c_translation.cast(guint64, G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x0000ff0000000000, .hexadecimal)))) >> @as(c_int, 24))) | ((@import("std").zig.c_translation.cast(guint64, val) & @import("std").zig.c_translation.cast(guint64, G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00ff000000000000, .hexadecimal)))) >> @as(c_int, 40))) | ((@import("std").zig.c_translation.cast(guint64, val) & @import("std").zig.c_translation.cast(guint64, G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xff00000000000000, .hexadecimal)))) >> @as(c_int, 56)));
}
pub inline fn GUINT16_SWAP_LE_BE(val: anytype) @TypeOf(GUINT16_SWAP_LE_BE_CONSTANT(val)) {
    return GUINT16_SWAP_LE_BE_CONSTANT(val);
}
pub inline fn GUINT32_SWAP_LE_BE(val: anytype) @TypeOf(GUINT32_SWAP_LE_BE_CONSTANT(val)) {
    return GUINT32_SWAP_LE_BE_CONSTANT(val);
}
pub inline fn GUINT64_SWAP_LE_BE(val: anytype) @TypeOf(GUINT64_SWAP_LE_BE_CONSTANT(val)) {
    return GUINT64_SWAP_LE_BE_CONSTANT(val);
}
pub inline fn GUINT16_SWAP_LE_PDP(val: anytype) guint16 {
    return @import("std").zig.c_translation.cast(guint16, val);
}
pub inline fn GUINT16_SWAP_BE_PDP(val: anytype) @TypeOf(GUINT16_SWAP_LE_BE(val)) {
    return GUINT16_SWAP_LE_BE(val);
}
pub inline fn GUINT32_SWAP_LE_PDP(val: anytype) guint32 {
    return @import("std").zig.c_translation.cast(guint32, ((@import("std").zig.c_translation.cast(guint32, val) & @import("std").zig.c_translation.cast(guint32, @as(c_uint, 0x0000ffff))) << @as(c_int, 16)) | ((@import("std").zig.c_translation.cast(guint32, val) & @import("std").zig.c_translation.cast(guint32, @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xffff0000, .hexadecimal))) >> @as(c_int, 16)));
}
pub inline fn GUINT32_SWAP_BE_PDP(val: anytype) guint32 {
    return @import("std").zig.c_translation.cast(guint32, ((@import("std").zig.c_translation.cast(guint32, val) & @import("std").zig.c_translation.cast(guint32, @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00ff00ff, .hexadecimal))) << @as(c_int, 8)) | ((@import("std").zig.c_translation.cast(guint32, val) & @import("std").zig.c_translation.cast(guint32, @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xff00ff00, .hexadecimal))) >> @as(c_int, 8)));
}
pub inline fn GINT16_FROM_LE(val: anytype) @TypeOf(GINT16_TO_LE(val)) {
    return GINT16_TO_LE(val);
}
pub inline fn GUINT16_FROM_LE(val: anytype) @TypeOf(GUINT16_TO_LE(val)) {
    return GUINT16_TO_LE(val);
}
pub inline fn GINT16_FROM_BE(val: anytype) @TypeOf(GINT16_TO_BE(val)) {
    return GINT16_TO_BE(val);
}
pub inline fn GUINT16_FROM_BE(val: anytype) @TypeOf(GUINT16_TO_BE(val)) {
    return GUINT16_TO_BE(val);
}
pub inline fn GINT32_FROM_LE(val: anytype) @TypeOf(GINT32_TO_LE(val)) {
    return GINT32_TO_LE(val);
}
pub inline fn GUINT32_FROM_LE(val: anytype) @TypeOf(GUINT32_TO_LE(val)) {
    return GUINT32_TO_LE(val);
}
pub inline fn GINT32_FROM_BE(val: anytype) @TypeOf(GINT32_TO_BE(val)) {
    return GINT32_TO_BE(val);
}
pub inline fn GUINT32_FROM_BE(val: anytype) @TypeOf(GUINT32_TO_BE(val)) {
    return GUINT32_TO_BE(val);
}
pub inline fn GINT64_FROM_LE(val: anytype) @TypeOf(GINT64_TO_LE(val)) {
    return GINT64_TO_LE(val);
}
pub inline fn GUINT64_FROM_LE(val: anytype) @TypeOf(GUINT64_TO_LE(val)) {
    return GUINT64_TO_LE(val);
}
pub inline fn GINT64_FROM_BE(val: anytype) @TypeOf(GINT64_TO_BE(val)) {
    return GINT64_TO_BE(val);
}
pub inline fn GUINT64_FROM_BE(val: anytype) @TypeOf(GUINT64_TO_BE(val)) {
    return GUINT64_TO_BE(val);
}
pub inline fn GLONG_FROM_LE(val: anytype) @TypeOf(GLONG_TO_LE(val)) {
    return GLONG_TO_LE(val);
}
pub inline fn GULONG_FROM_LE(val: anytype) @TypeOf(GULONG_TO_LE(val)) {
    return GULONG_TO_LE(val);
}
pub inline fn GLONG_FROM_BE(val: anytype) @TypeOf(GLONG_TO_BE(val)) {
    return GLONG_TO_BE(val);
}
pub inline fn GULONG_FROM_BE(val: anytype) @TypeOf(GULONG_TO_BE(val)) {
    return GULONG_TO_BE(val);
}
pub inline fn GINT_FROM_LE(val: anytype) @TypeOf(GINT_TO_LE(val)) {
    return GINT_TO_LE(val);
}
pub inline fn GUINT_FROM_LE(val: anytype) @TypeOf(GUINT_TO_LE(val)) {
    return GUINT_TO_LE(val);
}
pub inline fn GINT_FROM_BE(val: anytype) @TypeOf(GINT_TO_BE(val)) {
    return GINT_TO_BE(val);
}
pub inline fn GUINT_FROM_BE(val: anytype) @TypeOf(GUINT_TO_BE(val)) {
    return GUINT_TO_BE(val);
}
pub inline fn GSIZE_FROM_LE(val: anytype) @TypeOf(GSIZE_TO_LE(val)) {
    return GSIZE_TO_LE(val);
}
pub inline fn GSSIZE_FROM_LE(val: anytype) @TypeOf(GSSIZE_TO_LE(val)) {
    return GSSIZE_TO_LE(val);
}
pub inline fn GSIZE_FROM_BE(val: anytype) @TypeOf(GSIZE_TO_BE(val)) {
    return GSIZE_TO_BE(val);
}
pub inline fn GSSIZE_FROM_BE(val: anytype) @TypeOf(GSSIZE_TO_BE(val)) {
    return GSSIZE_TO_BE(val);
}
pub inline fn g_ntohl(val: anytype) @TypeOf(GUINT32_FROM_BE(val)) {
    return GUINT32_FROM_BE(val);
}
pub inline fn g_ntohs(val: anytype) @TypeOf(GUINT16_FROM_BE(val)) {
    return GUINT16_FROM_BE(val);
}
pub inline fn g_htonl(val: anytype) @TypeOf(GUINT32_TO_BE(val)) {
    return GUINT32_TO_BE(val);
}
pub inline fn g_htons(val: anytype) @TypeOf(GUINT16_TO_BE(val)) {
    return GUINT16_TO_BE(val);
}
pub const _GLIB_HAVE_BUILTIN_OVERFLOW_CHECKS = "";
pub inline fn g_uint_checked_mul(dest: anytype, a: anytype, b: anytype) @TypeOf(!(__builtin_mul_overflow(a, b, dest) != 0)) {
    return !(__builtin_mul_overflow(a, b, dest) != 0);
}
pub inline fn g_uint64_checked_mul(dest: anytype, a: anytype, b: anytype) @TypeOf(!(__builtin_mul_overflow(a, b, dest) != 0)) {
    return !(__builtin_mul_overflow(a, b, dest) != 0);
}
pub inline fn g_size_checked_mul(dest: anytype, a: anytype, b: anytype) @TypeOf(!(__builtin_mul_overflow(a, b, dest) != 0)) {
    return !(__builtin_mul_overflow(a, b, dest) != 0);
}
pub const G_IEEE754_FLOAT_BIAS = @as(c_int, 127);
pub const G_IEEE754_DOUBLE_BIAS = @as(c_int, 1023);
pub const G_LOG_2_BASE_10 = 0.30102999566398119521;
pub const GLIB_VAR = _GLIB_EXTERN;
pub const _STRING_H = @as(c_int, 1);
pub const _STRINGS_H = @as(c_int, 1);
pub inline fn g_alloca(size: anytype) @TypeOf(alloca(size)) {
    return alloca(size);
}
pub inline fn g_alloca0(size: anytype) @TypeOf(if (size == @as(c_int, 0)) NULL else memset(g_alloca(size), @as(c_int, 0), size)) {
    return if (size == @as(c_int, 0)) NULL else memset(g_alloca(size), @as(c_int, 0), size);
}
pub const __G_ARRAY_H__ = "";
pub inline fn g_array_append_val(a: anytype, v: anytype) @TypeOf(g_array_append_vals(a, &v, @as(c_int, 1))) {
    return g_array_append_vals(a, &v, @as(c_int, 1));
}
pub inline fn g_array_prepend_val(a: anytype, v: anytype) @TypeOf(g_array_prepend_vals(a, &v, @as(c_int, 1))) {
    return g_array_prepend_vals(a, &v, @as(c_int, 1));
}
pub inline fn g_array_insert_val(a: anytype, i: anytype, v: anytype) @TypeOf(g_array_insert_vals(a, i, &v, @as(c_int, 1))) {
    return g_array_insert_vals(a, i, &v, @as(c_int, 1));
}
pub inline fn g_ptr_array_index(array: anytype, index_: anytype) @TypeOf(array.*.pdata[index_]) {
    return array.*.pdata[index_];
}
pub const __G_ASYNCQUEUE_H__ = "";
pub const __G_THREAD_H__ = "";
pub const __G_ATOMIC_H__ = "";
pub const __GLIB_TYPEOF_H__ = "";
pub const __G_ERROR_H__ = "";
pub const __STDARG_H = "";
pub const _VA_LIST = "";
pub const __GNUC_VA_LIST = @as(c_int, 1);
pub const __G_QUARK_H__ = "";
pub const __G_UTILS_H__ = "";
pub const G_OS_INFO_KEY_NAME = GLIB_AVAILABLE_MACRO_IN_2_64 ++ "NAME";
pub const G_OS_INFO_KEY_PRETTY_NAME = GLIB_AVAILABLE_MACRO_IN_2_64 ++ "PRETTY_NAME";
pub const G_OS_INFO_KEY_VERSION = GLIB_AVAILABLE_MACRO_IN_2_64 ++ "VERSION";
pub const G_OS_INFO_KEY_VERSION_CODENAME = GLIB_AVAILABLE_MACRO_IN_2_64 ++ "VERSION_CODENAME";
pub const G_OS_INFO_KEY_VERSION_ID = GLIB_AVAILABLE_MACRO_IN_2_64 ++ "VERSION_ID";
pub const G_OS_INFO_KEY_ID = GLIB_AVAILABLE_MACRO_IN_2_64 ++ "ID";
pub const G_OS_INFO_KEY_HOME_URL = GLIB_AVAILABLE_MACRO_IN_2_64 ++ "HOME_URL";
pub const G_OS_INFO_KEY_DOCUMENTATION_URL = GLIB_AVAILABLE_MACRO_IN_2_64 ++ "DOCUMENTATION_URL";
pub const G_OS_INFO_KEY_SUPPORT_URL = GLIB_AVAILABLE_MACRO_IN_2_64 ++ "SUPPORT_URL";
pub const G_OS_INFO_KEY_BUG_REPORT_URL = GLIB_AVAILABLE_MACRO_IN_2_64 ++ "BUG_REPORT_URL";
pub const G_OS_INFO_KEY_PRIVACY_POLICY_URL = GLIB_AVAILABLE_MACRO_IN_2_64 ++ "PRIVACY_POLICY_URL";
pub inline fn g_ATEXIT(proc: anytype) @TypeOf(atexit(proc) ++ GLIB_DEPRECATED_MACRO_IN_2_32) {
    return atexit(proc) ++ GLIB_DEPRECATED_MACRO_IN_2_32;
}
pub const _STDLIB_H = @as(c_int, 1);
pub const WNOHANG = @as(c_int, 1);
pub const WUNTRACED = @as(c_int, 2);
pub const WSTOPPED = @as(c_int, 2);
pub const WEXITED = @as(c_int, 4);
pub const WCONTINUED = @as(c_int, 8);
pub const WNOWAIT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x01000000, .hexadecimal);
pub const __WNOTHREAD = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x20000000, .hexadecimal);
pub const __WALL = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x40000000, .hexadecimal);
pub const __WCLONE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hexadecimal);
pub const __ENUM_IDTYPE_T = @as(c_int, 1);
pub inline fn __WEXITSTATUS(status: anytype) @TypeOf((status & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff00, .hexadecimal)) >> @as(c_int, 8)) {
    return (status & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff00, .hexadecimal)) >> @as(c_int, 8);
}
pub inline fn __WTERMSIG(status: anytype) @TypeOf(status & @as(c_int, 0x7f)) {
    return status & @as(c_int, 0x7f);
}
pub inline fn __WSTOPSIG(status: anytype) @TypeOf(__WEXITSTATUS(status)) {
    return __WEXITSTATUS(status);
}
pub inline fn __WIFEXITED(status: anytype) @TypeOf(__WTERMSIG(status) == @as(c_int, 0)) {
    return __WTERMSIG(status) == @as(c_int, 0);
}
pub inline fn __WIFSIGNALED(status: anytype) @TypeOf((@import("std").zig.c_translation.cast(i8, (status & @as(c_int, 0x7f)) + @as(c_int, 1)) >> @as(c_int, 1)) > @as(c_int, 0)) {
    return (@import("std").zig.c_translation.cast(i8, (status & @as(c_int, 0x7f)) + @as(c_int, 1)) >> @as(c_int, 1)) > @as(c_int, 0);
}
pub inline fn __WIFSTOPPED(status: anytype) @TypeOf((status & @as(c_int, 0xff)) == @as(c_int, 0x7f)) {
    return (status & @as(c_int, 0xff)) == @as(c_int, 0x7f);
}
pub inline fn __WIFCONTINUED(status: anytype) @TypeOf(status == __W_CONTINUED) {
    return status == __W_CONTINUED;
}
pub inline fn __WCOREDUMP(status: anytype) @TypeOf(status & __WCOREFLAG) {
    return status & __WCOREFLAG;
}
pub inline fn __W_EXITCODE(ret: anytype, sig: anytype) @TypeOf((ret << @as(c_int, 8)) | sig) {
    return (ret << @as(c_int, 8)) | sig;
}
pub inline fn __W_STOPCODE(sig: anytype) @TypeOf((sig << @as(c_int, 8)) | @as(c_int, 0x7f)) {
    return (sig << @as(c_int, 8)) | @as(c_int, 0x7f);
}
pub const __W_CONTINUED = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffff, .hexadecimal);
pub const __WCOREFLAG = @as(c_int, 0x80);
pub inline fn WEXITSTATUS(status: anytype) @TypeOf(__WEXITSTATUS(status)) {
    return __WEXITSTATUS(status);
}
pub inline fn WTERMSIG(status: anytype) @TypeOf(__WTERMSIG(status)) {
    return __WTERMSIG(status);
}
pub inline fn WSTOPSIG(status: anytype) @TypeOf(__WSTOPSIG(status)) {
    return __WSTOPSIG(status);
}
pub inline fn WIFEXITED(status: anytype) @TypeOf(__WIFEXITED(status)) {
    return __WIFEXITED(status);
}
pub inline fn WIFSIGNALED(status: anytype) @TypeOf(__WIFSIGNALED(status)) {
    return __WIFSIGNALED(status);
}
pub inline fn WIFSTOPPED(status: anytype) @TypeOf(__WIFSTOPPED(status)) {
    return __WIFSTOPPED(status);
}
pub inline fn WIFCONTINUED(status: anytype) @TypeOf(__WIFCONTINUED(status)) {
    return __WIFCONTINUED(status);
}
pub const _BITS_FLOATN_H = "";
pub const __HAVE_FLOAT128 = @as(c_int, 1);
pub const __HAVE_DISTINCT_FLOAT128 = @as(c_int, 0);
pub const __HAVE_FLOAT64X = __HAVE_FLOAT128;
pub const __HAVE_FLOAT64X_LONG_DOUBLE = __HAVE_FLOAT128;
pub const __f128 = @import("std").zig.c_translation.Macros.L_SUFFIX;
pub const _BITS_FLOATN_COMMON_H = "";
pub const __HAVE_FLOAT16 = @as(c_int, 0);
pub const __HAVE_FLOAT32 = @as(c_int, 1);
pub const __HAVE_FLOAT64 = @as(c_int, 1);
pub const __HAVE_FLOAT32X = @as(c_int, 1);
pub const __HAVE_FLOAT128X = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT16 = __HAVE_FLOAT16;
pub const __HAVE_DISTINCT_FLOAT32 = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT64 = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT32X = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT64X = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT128X = __HAVE_FLOAT128X;
pub const __HAVE_FLOAT128_UNLIKE_LDBL = (__HAVE_DISTINCT_FLOAT128 != 0) and (__LDBL_MANT_DIG__ != @as(c_int, 113));
pub const __HAVE_FLOATN_NOT_TYPEDEF = @as(c_int, 0);
pub const __f32 = @import("std").zig.c_translation.Macros.F_SUFFIX;
pub inline fn __f64(x: anytype) @TypeOf(x) {
    return x;
}
pub inline fn __f32x(x: anytype) @TypeOf(x) {
    return x;
}
pub const __f64x = @import("std").zig.c_translation.Macros.L_SUFFIX;
pub inline fn __builtin_huge_valf32() @TypeOf(__builtin_huge_valf()) {
    return __builtin_huge_valf();
}
pub inline fn __builtin_inff32() @TypeOf(__builtin_inff()) {
    return __builtin_inff();
}
pub inline fn __builtin_nanf32(x: anytype) @TypeOf(__builtin_nanf(x)) {
    return __builtin_nanf(x);
}
pub const __ldiv_t_defined = @as(c_int, 1);
pub const __lldiv_t_defined = @as(c_int, 1);
pub const RAND_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const EXIT_FAILURE = @as(c_int, 1);
pub const EXIT_SUCCESS = @as(c_int, 0);
pub const MB_CUR_MAX = __ctype_get_mb_cur_max();
pub const _SYS_TYPES_H = @as(c_int, 1);
pub const __u_char_defined = "";
pub const __ino_t_defined = "";
pub const __dev_t_defined = "";
pub const __gid_t_defined = "";
pub const __mode_t_defined = "";
pub const __nlink_t_defined = "";
pub const __uid_t_defined = "";
pub const __off_t_defined = "";
pub const __id_t_defined = "";
pub const __ssize_t_defined = "";
pub const __daddr_t_defined = "";
pub const __key_t_defined = "";
pub const _BITS_STDINT_INTN_H = @as(c_int, 1);
pub const __BIT_TYPES_DEFINED__ = @as(c_int, 1);
pub const _ENDIAN_H = @as(c_int, 1);
pub const LITTLE_ENDIAN = __LITTLE_ENDIAN;
pub const BIG_ENDIAN = __BIG_ENDIAN;
pub const PDP_ENDIAN = __PDP_ENDIAN;
pub const BYTE_ORDER = __BYTE_ORDER;
pub const _BITS_BYTESWAP_H = @as(c_int, 1);
pub inline fn __bswap_constant_16(x: anytype) __uint16_t {
    return @import("std").zig.c_translation.cast(__uint16_t, ((x >> @as(c_int, 8)) & @as(c_int, 0xff)) | ((x & @as(c_int, 0xff)) << @as(c_int, 8)));
}
pub inline fn __bswap_constant_32(x: anytype) @TypeOf(((((x & @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xff000000, .hexadecimal)) >> @as(c_int, 24)) | ((x & @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00ff0000, .hexadecimal)) >> @as(c_int, 8))) | ((x & @as(c_uint, 0x0000ff00)) << @as(c_int, 8))) | ((x & @as(c_uint, 0x000000ff)) << @as(c_int, 24))) {
    return ((((x & @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xff000000, .hexadecimal)) >> @as(c_int, 24)) | ((x & @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00ff0000, .hexadecimal)) >> @as(c_int, 8))) | ((x & @as(c_uint, 0x0000ff00)) << @as(c_int, 8))) | ((x & @as(c_uint, 0x000000ff)) << @as(c_int, 24));
}
pub inline fn __bswap_constant_64(x: anytype) @TypeOf(((((((((x & @as(c_ulonglong, 0xff00000000000000)) >> @as(c_int, 56)) | ((x & @as(c_ulonglong, 0x00ff000000000000)) >> @as(c_int, 40))) | ((x & @as(c_ulonglong, 0x0000ff0000000000)) >> @as(c_int, 24))) | ((x & @as(c_ulonglong, 0x000000ff00000000)) >> @as(c_int, 8))) | ((x & @as(c_ulonglong, 0x00000000ff000000)) << @as(c_int, 8))) | ((x & @as(c_ulonglong, 0x0000000000ff0000)) << @as(c_int, 24))) | ((x & @as(c_ulonglong, 0x000000000000ff00)) << @as(c_int, 40))) | ((x & @as(c_ulonglong, 0x00000000000000ff)) << @as(c_int, 56))) {
    return ((((((((x & @as(c_ulonglong, 0xff00000000000000)) >> @as(c_int, 56)) | ((x & @as(c_ulonglong, 0x00ff000000000000)) >> @as(c_int, 40))) | ((x & @as(c_ulonglong, 0x0000ff0000000000)) >> @as(c_int, 24))) | ((x & @as(c_ulonglong, 0x000000ff00000000)) >> @as(c_int, 8))) | ((x & @as(c_ulonglong, 0x00000000ff000000)) << @as(c_int, 8))) | ((x & @as(c_ulonglong, 0x0000000000ff0000)) << @as(c_int, 24))) | ((x & @as(c_ulonglong, 0x000000000000ff00)) << @as(c_int, 40))) | ((x & @as(c_ulonglong, 0x00000000000000ff)) << @as(c_int, 56));
}
pub const _BITS_UINTN_IDENTITY_H = @as(c_int, 1);
pub inline fn htobe16(x: anytype) @TypeOf(__bswap_16(x)) {
    return __bswap_16(x);
}
pub inline fn htole16(x: anytype) @TypeOf(__uint16_identity(x)) {
    return __uint16_identity(x);
}
pub inline fn be16toh(x: anytype) @TypeOf(__bswap_16(x)) {
    return __bswap_16(x);
}
pub inline fn le16toh(x: anytype) @TypeOf(__uint16_identity(x)) {
    return __uint16_identity(x);
}
pub inline fn htobe32(x: anytype) @TypeOf(__bswap_32(x)) {
    return __bswap_32(x);
}
pub inline fn htole32(x: anytype) @TypeOf(__uint32_identity(x)) {
    return __uint32_identity(x);
}
pub inline fn be32toh(x: anytype) @TypeOf(__bswap_32(x)) {
    return __bswap_32(x);
}
pub inline fn le32toh(x: anytype) @TypeOf(__uint32_identity(x)) {
    return __uint32_identity(x);
}
pub inline fn htobe64(x: anytype) @TypeOf(__bswap_64(x)) {
    return __bswap_64(x);
}
pub inline fn htole64(x: anytype) @TypeOf(__uint64_identity(x)) {
    return __uint64_identity(x);
}
pub inline fn be64toh(x: anytype) @TypeOf(__bswap_64(x)) {
    return __bswap_64(x);
}
pub inline fn le64toh(x: anytype) @TypeOf(__uint64_identity(x)) {
    return __uint64_identity(x);
}
pub const _SYS_SELECT_H = @as(c_int, 1);
pub inline fn __FD_ISSET(d: anytype, s: anytype) @TypeOf((__FDS_BITS(s)[__FD_ELT(d)] & __FD_MASK(d)) != @as(c_int, 0)) {
    return (__FDS_BITS(s)[__FD_ELT(d)] & __FD_MASK(d)) != @as(c_int, 0);
}
pub const __sigset_t_defined = @as(c_int, 1);
pub const ____sigset_t_defined = "";
pub const _SIGSET_NWORDS = @as(c_int, 1024) / (@as(c_int, 8) * @import("std").zig.c_translation.sizeof(c_ulong));
pub const __timeval_defined = @as(c_int, 1);
pub const __suseconds_t_defined = "";
pub const __NFDBITS = @as(c_int, 8) * @import("std").zig.c_translation.cast(c_int, @import("std").zig.c_translation.sizeof(__fd_mask));
pub inline fn __FD_ELT(d: anytype) @TypeOf(d / __NFDBITS) {
    return d / __NFDBITS;
}
pub inline fn __FD_MASK(d: anytype) __fd_mask {
    return @import("std").zig.c_translation.cast(__fd_mask, @as(c_ulong, 1) << (d % __NFDBITS));
}
pub inline fn __FDS_BITS(set: anytype) @TypeOf(set.*.__fds_bits) {
    return set.*.__fds_bits;
}
pub const FD_SETSIZE = __FD_SETSIZE;
pub const NFDBITS = __NFDBITS;
pub inline fn FD_SET(fd: anytype, fdsetp: anytype) @TypeOf(__FD_SET(fd, fdsetp)) {
    return __FD_SET(fd, fdsetp);
}
pub inline fn FD_CLR(fd: anytype, fdsetp: anytype) @TypeOf(__FD_CLR(fd, fdsetp)) {
    return __FD_CLR(fd, fdsetp);
}
pub inline fn FD_ISSET(fd: anytype, fdsetp: anytype) @TypeOf(__FD_ISSET(fd, fdsetp)) {
    return __FD_ISSET(fd, fdsetp);
}
pub inline fn FD_ZERO(fdsetp: anytype) @TypeOf(__FD_ZERO(fdsetp)) {
    return __FD_ZERO(fdsetp);
}
pub const __blksize_t_defined = "";
pub const __blkcnt_t_defined = "";
pub const __fsblkcnt_t_defined = "";
pub const __fsfilcnt_t_defined = "";
pub const _BITS_PTHREADTYPES_COMMON_H = @as(c_int, 1);
pub const _THREAD_SHARED_TYPES_H = @as(c_int, 1);
pub const _BITS_PTHREADTYPES_ARCH_H = @as(c_int, 1);
pub const __SIZEOF_PTHREAD_ATTR_T = @as(c_int, 64);
pub const __SIZEOF_PTHREAD_MUTEX_T = @as(c_int, 48);
pub const __SIZEOF_PTHREAD_MUTEXATTR_T = @as(c_int, 8);
pub const __SIZEOF_PTHREAD_CONDATTR_T = @as(c_int, 8);
pub const __SIZEOF_PTHREAD_RWLOCK_T = @as(c_int, 56);
pub const __SIZEOF_PTHREAD_BARRIER_T = @as(c_int, 32);
pub const __SIZEOF_PTHREAD_BARRIERATTR_T = @as(c_int, 8);
pub const __SIZEOF_PTHREAD_COND_T = @as(c_int, 48);
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T = @as(c_int, 8);
pub const __LOCK_ALIGNMENT = "";
pub const __ONCE_ALIGNMENT = "";
pub const _THREAD_MUTEX_INTERNAL_H = @as(c_int, 1);
pub const __PTHREAD_MUTEX_HAVE_PREV = @as(c_int, 1);
pub const _RWLOCK_INTERNAL_H = "";
pub inline fn __PTHREAD_RWLOCK_INITIALIZER(__flags: anytype) @TypeOf(__flags) {
    return blk: {
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        break :blk __flags;
    };
}
pub const __have_pthread_attr_t = @as(c_int, 1);
pub const _ALLOCA_H = @as(c_int, 1);
pub const __COMPAR_FN_T = "";
pub inline fn g_abort() @TypeOf(abort()) {
    return abort();
}
pub const G_THREAD_ERROR = g_thread_error_quark();
pub inline fn G_LOCK_DEFINE(name: anytype) @TypeOf(GMutex ++ G_LOCK_NAME(name)) {
    return GMutex ++ G_LOCK_NAME(name);
}
pub inline fn G_LOCK(name: anytype) @TypeOf(g_mutex_lock(&G_LOCK_NAME(name))) {
    return g_mutex_lock(&G_LOCK_NAME(name));
}
pub inline fn G_UNLOCK(name: anytype) @TypeOf(g_mutex_unlock(&G_LOCK_NAME(name))) {
    return g_mutex_unlock(&G_LOCK_NAME(name));
}
pub inline fn G_TRYLOCK(name: anytype) @TypeOf(g_mutex_trylock(&G_LOCK_NAME(name))) {
    return g_mutex_trylock(&G_LOCK_NAME(name));
}
pub const __G_BACKTRACE_H__ = "";
pub const _SIGNAL_H = "";
pub const _BITS_SIGNUM_GENERIC_H = @as(c_int, 1);
pub const SIG_ERR = @import("std").zig.c_translation.cast(__sighandler_t, -@as(c_int, 1));
pub const SIG_DFL = @import("std").zig.c_translation.cast(__sighandler_t, @as(c_int, 0));
pub const SIG_IGN = @import("std").zig.c_translation.cast(__sighandler_t, @as(c_int, 1));
pub const SIGINT = @as(c_int, 2);
pub const SIGILL = @as(c_int, 4);
pub const SIGABRT = @as(c_int, 6);
pub const SIGFPE = @as(c_int, 8);
pub const SIGSEGV = @as(c_int, 11);
pub const SIGTERM = @as(c_int, 15);
pub const SIGHUP = @as(c_int, 1);
pub const SIGQUIT = @as(c_int, 3);
pub const SIGTRAP = @as(c_int, 5);
pub const SIGKILL = @as(c_int, 9);
pub const SIGPIPE = @as(c_int, 13);
pub const SIGALRM = @as(c_int, 14);
pub const SIGIO = SIGPOLL;
pub const SIGIOT = SIGABRT;
pub const SIGCLD = SIGCHLD;
pub const _BITS_SIGNUM_ARCH_H = @as(c_int, 1);
pub const SIGSTKFLT = @as(c_int, 16);
pub const SIGPWR = @as(c_int, 30);
pub const SIGBUS = @as(c_int, 7);
pub const SIGSYS = @as(c_int, 31);
pub const SIGURG = @as(c_int, 23);
pub const SIGSTOP = @as(c_int, 19);
pub const SIGTSTP = @as(c_int, 20);
pub const SIGCONT = @as(c_int, 18);
pub const SIGCHLD = @as(c_int, 17);
pub const SIGTTIN = @as(c_int, 21);
pub const SIGTTOU = @as(c_int, 22);
pub const SIGPOLL = @as(c_int, 29);
pub const SIGXFSZ = @as(c_int, 25);
pub const SIGXCPU = @as(c_int, 24);
pub const SIGVTALRM = @as(c_int, 26);
pub const SIGPROF = @as(c_int, 27);
pub const SIGUSR1 = @as(c_int, 10);
pub const SIGUSR2 = @as(c_int, 12);
pub const SIGWINCH = @as(c_int, 28);
pub const __SIGRTMIN = @as(c_int, 32);
pub const __SIGRTMAX = @as(c_int, 64);
pub const _NSIG = __SIGRTMAX + @as(c_int, 1);
pub const __sig_atomic_t_defined = @as(c_int, 1);
pub const __siginfo_t_defined = @as(c_int, 1);
pub const ____sigval_t_defined = "";
pub const __SI_MAX_SIZE = @as(c_int, 128);
pub const __SI_PAD_SIZE = (__SI_MAX_SIZE / @import("std").zig.c_translation.sizeof(c_int)) - @as(c_int, 4);
pub const _BITS_SIGINFO_ARCH_H = @as(c_int, 1);
pub const __SI_ALIGNMENT = "";
pub const __SI_BAND_TYPE = c_long;
pub const __SI_CLOCK_T = __clock_t;
pub const __SI_ERRNO_THEN_CODE = @as(c_int, 1);
pub const __SI_HAVE_SIGSYS = @as(c_int, 1);
pub const __SI_SIGFAULT_ADDL = "";
pub const _BITS_SIGINFO_CONSTS_H = @as(c_int, 1);
pub const __SI_ASYNCIO_AFTER_SIGIO = @as(c_int, 1);
pub const __sigval_t_defined = "";
pub const __sigevent_t_defined = @as(c_int, 1);
pub const __SIGEV_MAX_SIZE = @as(c_int, 64);
pub const __SIGEV_PAD_SIZE = (__SIGEV_MAX_SIZE / @import("std").zig.c_translation.sizeof(c_int)) - @as(c_int, 4);
pub const _BITS_SIGEVENT_CONSTS_H = @as(c_int, 1);
pub inline fn sigmask(sig: anytype) @TypeOf(__glibc_macro_warning("sigmask is deprecated")(@import("std").zig.c_translation.cast(c_int, @as(c_uint, 1) << (sig - @as(c_int, 1))))) {
    return __glibc_macro_warning("sigmask is deprecated")(@import("std").zig.c_translation.cast(c_int, @as(c_uint, 1) << (sig - @as(c_int, 1))));
}
pub const NSIG = _NSIG;
pub const _BITS_SIGACTION_H = @as(c_int, 1);
pub const SA_NOCLDSTOP = @as(c_int, 1);
pub const SA_NOCLDWAIT = @as(c_int, 2);
pub const SA_SIGINFO = @as(c_int, 4);
pub const SA_ONSTACK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x08000000, .hexadecimal);
pub const SA_RESTART = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000000, .hexadecimal);
pub const SA_NODEFER = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x40000000, .hexadecimal);
pub const SA_RESETHAND = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hexadecimal);
pub const SA_INTERRUPT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x20000000, .hexadecimal);
pub const SA_NOMASK = SA_NODEFER;
pub const SA_ONESHOT = SA_RESETHAND;
pub const SA_STACK = SA_ONSTACK;
pub const SIG_BLOCK = @as(c_int, 0);
pub const SIG_UNBLOCK = @as(c_int, 1);
pub const SIG_SETMASK = @as(c_int, 2);
pub const _BITS_SIGCONTEXT_H = @as(c_int, 1);
pub const sigcontext_struct = sigcontext;
pub const __ASM_SIGCONTEXT_H = "";
pub const _LINUX_TYPES_H = "";
pub const _ASM_GENERIC_TYPES_H = "";
pub const _ASM_GENERIC_INT_LL64_H = "";
pub const __ASM_BITSPERLONG_H = "";
pub const __BITS_PER_LONG = @as(c_int, 64);
pub const __ASM_GENERIC_BITS_PER_LONG = "";
pub const _LINUX_POSIX_TYPES_H = "";
pub const _LINUX_STDDEF_H = "";
pub const __ASM_POSIX_TYPES_H = "";
pub const __ASM_GENERIC_POSIX_TYPES_H = "";
pub const __bitwise = "";
pub const __bitwise__ = __bitwise;
pub const FPSIMD_MAGIC = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x46508001, .hexadecimal);
pub const ESR_MAGIC = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x45535201, .hexadecimal);
pub const EXTRA_MAGIC = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x45585401, .hexadecimal);
pub const SVE_MAGIC = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x53564501, .hexadecimal);
pub const __ASM_SVE_CONTEXT_H = "";
pub const __SVE_VQ_BYTES = @as(c_int, 16);
pub const __SVE_VQ_MIN = @as(c_int, 1);
pub const __SVE_VQ_MAX = @as(c_int, 512);
pub const __SVE_VL_MIN = __SVE_VQ_MIN * __SVE_VQ_BYTES;
pub const __SVE_VL_MAX = __SVE_VQ_MAX * __SVE_VQ_BYTES;
pub const __SVE_NUM_ZREGS = @as(c_int, 32);
pub const __SVE_NUM_PREGS = @as(c_int, 16);
pub inline fn __sve_vl_valid(vl: anytype) @TypeOf((((vl % __SVE_VQ_BYTES) == @as(c_int, 0)) and (vl >= __SVE_VL_MIN)) and (vl <= __SVE_VL_MAX)) {
    return (((vl % __SVE_VQ_BYTES) == @as(c_int, 0)) and (vl >= __SVE_VL_MIN)) and (vl <= __SVE_VL_MAX);
}
pub inline fn __sve_vq_from_vl(vl: anytype) @TypeOf(vl / __SVE_VQ_BYTES) {
    return vl / __SVE_VQ_BYTES;
}
pub inline fn __sve_vl_from_vq(vq: anytype) @TypeOf(vq * __SVE_VQ_BYTES) {
    return vq * __SVE_VQ_BYTES;
}
pub inline fn __SVE_ZREG_SIZE(vq: anytype) @TypeOf(@import("std").zig.c_translation.cast(__u32, vq) * __SVE_VQ_BYTES) {
    return @import("std").zig.c_translation.cast(__u32, vq) * __SVE_VQ_BYTES;
}
pub inline fn __SVE_PREG_SIZE(vq: anytype) @TypeOf(@import("std").zig.c_translation.cast(__u32, vq) * (__SVE_VQ_BYTES / @as(c_int, 8))) {
    return @import("std").zig.c_translation.cast(__u32, vq) * (__SVE_VQ_BYTES / @as(c_int, 8));
}
pub inline fn __SVE_FFR_SIZE(vq: anytype) @TypeOf(__SVE_PREG_SIZE(vq)) {
    return __SVE_PREG_SIZE(vq);
}
pub const __SVE_ZREGS_OFFSET = @as(c_int, 0);
pub inline fn __SVE_ZREG_OFFSET(vq: anytype, n: anytype) @TypeOf(__SVE_ZREGS_OFFSET + (__SVE_ZREG_SIZE(vq) * n)) {
    return __SVE_ZREGS_OFFSET + (__SVE_ZREG_SIZE(vq) * n);
}
pub inline fn __SVE_ZREGS_SIZE(vq: anytype) @TypeOf(__SVE_ZREG_OFFSET(vq, __SVE_NUM_ZREGS) - __SVE_ZREGS_OFFSET) {
    return __SVE_ZREG_OFFSET(vq, __SVE_NUM_ZREGS) - __SVE_ZREGS_OFFSET;
}
pub inline fn __SVE_PREGS_OFFSET(vq: anytype) @TypeOf(__SVE_ZREGS_OFFSET + __SVE_ZREGS_SIZE(vq)) {
    return __SVE_ZREGS_OFFSET + __SVE_ZREGS_SIZE(vq);
}
pub inline fn __SVE_PREG_OFFSET(vq: anytype, n: anytype) @TypeOf(__SVE_PREGS_OFFSET(vq) + (__SVE_PREG_SIZE(vq) * n)) {
    return __SVE_PREGS_OFFSET(vq) + (__SVE_PREG_SIZE(vq) * n);
}
pub inline fn __SVE_PREGS_SIZE(vq: anytype) @TypeOf(__SVE_PREG_OFFSET(vq, __SVE_NUM_PREGS) - __SVE_PREGS_OFFSET(vq)) {
    return __SVE_PREG_OFFSET(vq, __SVE_NUM_PREGS) - __SVE_PREGS_OFFSET(vq);
}
pub inline fn __SVE_FFR_OFFSET(vq: anytype) @TypeOf(__SVE_PREGS_OFFSET(vq) + __SVE_PREGS_SIZE(vq)) {
    return __SVE_PREGS_OFFSET(vq) + __SVE_PREGS_SIZE(vq);
}
pub const SVE_VQ_BYTES = __SVE_VQ_BYTES;
pub const SVE_VQ_MIN = __SVE_VQ_MIN;
pub const SVE_VQ_MAX = __SVE_VQ_MAX;
pub const SVE_VL_MIN = __SVE_VL_MIN;
pub const SVE_VL_MAX = __SVE_VL_MAX;
pub const SVE_NUM_ZREGS = __SVE_NUM_ZREGS;
pub const SVE_NUM_PREGS = __SVE_NUM_PREGS;
pub inline fn sve_vl_valid(vl: anytype) @TypeOf(__sve_vl_valid(vl)) {
    return __sve_vl_valid(vl);
}
pub inline fn sve_vq_from_vl(vl: anytype) @TypeOf(__sve_vq_from_vl(vl)) {
    return __sve_vq_from_vl(vl);
}
pub inline fn sve_vl_from_vq(vq: anytype) @TypeOf(__sve_vl_from_vq(vq)) {
    return __sve_vl_from_vq(vq);
}
pub inline fn SVE_SIG_ZREG_SIZE(vq: anytype) @TypeOf(__SVE_ZREG_SIZE(vq)) {
    return __SVE_ZREG_SIZE(vq);
}
pub inline fn SVE_SIG_PREG_SIZE(vq: anytype) @TypeOf(__SVE_PREG_SIZE(vq)) {
    return __SVE_PREG_SIZE(vq);
}
pub inline fn SVE_SIG_FFR_SIZE(vq: anytype) @TypeOf(__SVE_FFR_SIZE(vq)) {
    return __SVE_FFR_SIZE(vq);
}
pub const SVE_SIG_REGS_OFFSET = ((@import("std").zig.c_translation.sizeof(struct_sve_context) + (__SVE_VQ_BYTES - @as(c_int, 1))) / __SVE_VQ_BYTES) * __SVE_VQ_BYTES;
pub const SVE_SIG_ZREGS_OFFSET = SVE_SIG_REGS_OFFSET + __SVE_ZREGS_OFFSET;
pub inline fn SVE_SIG_ZREG_OFFSET(vq: anytype, n: anytype) @TypeOf(SVE_SIG_REGS_OFFSET + __SVE_ZREG_OFFSET(vq, n)) {
    return SVE_SIG_REGS_OFFSET + __SVE_ZREG_OFFSET(vq, n);
}
pub inline fn SVE_SIG_ZREGS_SIZE(vq: anytype) @TypeOf(__SVE_ZREGS_SIZE(vq)) {
    return __SVE_ZREGS_SIZE(vq);
}
pub inline fn SVE_SIG_PREGS_OFFSET(vq: anytype) @TypeOf(SVE_SIG_REGS_OFFSET + __SVE_PREGS_OFFSET(vq)) {
    return SVE_SIG_REGS_OFFSET + __SVE_PREGS_OFFSET(vq);
}
pub inline fn SVE_SIG_PREG_OFFSET(vq: anytype, n: anytype) @TypeOf(SVE_SIG_REGS_OFFSET + __SVE_PREG_OFFSET(vq, n)) {
    return SVE_SIG_REGS_OFFSET + __SVE_PREG_OFFSET(vq, n);
}
pub inline fn SVE_SIG_PREGS_SIZE(vq: anytype) @TypeOf(__SVE_PREGS_SIZE(vq)) {
    return __SVE_PREGS_SIZE(vq);
}
pub inline fn SVE_SIG_FFR_OFFSET(vq: anytype) @TypeOf(SVE_SIG_REGS_OFFSET + __SVE_FFR_OFFSET(vq)) {
    return SVE_SIG_REGS_OFFSET + __SVE_FFR_OFFSET(vq);
}
pub inline fn SVE_SIG_REGS_SIZE(vq: anytype) @TypeOf(__SVE_FFR_OFFSET(vq) + __SVE_FFR_SIZE(vq)) {
    return __SVE_FFR_OFFSET(vq) + __SVE_FFR_SIZE(vq);
}
pub inline fn SVE_SIG_CONTEXT_SIZE(vq: anytype) @TypeOf(SVE_SIG_REGS_OFFSET + SVE_SIG_REGS_SIZE(vq)) {
    return SVE_SIG_REGS_OFFSET + SVE_SIG_REGS_SIZE(vq);
}
pub const __stack_t_defined = @as(c_int, 1);
pub const _SYS_UCONTEXT_H = @as(c_int, 1);
pub inline fn __ctx(fld: anytype) @TypeOf(fld) {
    return fld;
}
pub const _SYS_PROCFS_H = @as(c_int, 1);
pub const _SYS_TIME_H = @as(c_int, 1);
pub inline fn timerisset(tvp: anytype) @TypeOf((tvp.*.tv_sec != 0) or (tvp.*.tv_usec != 0)) {
    return (tvp.*.tv_sec != 0) or (tvp.*.tv_usec != 0);
}
pub const _SYS_USER_H = @as(c_int, 1);
pub const ELF_NGREG = @import("std").zig.c_translation.sizeof(struct_user_regs_struct) / @import("std").zig.c_translation.sizeof(elf_greg_t);
pub const ELF_PRARGSZ = @as(c_int, 80);
pub const _BITS_SIGSTACK_H = @as(c_int, 1);
pub const MINSIGSTKSZ = @as(c_int, 5120);
pub const SIGSTKSZ = @as(c_int, 16384);
pub const _BITS_SS_FLAGS_H = @as(c_int, 1);
pub const __sigstack_defined = @as(c_int, 1);
pub const _BITS_SIGTHREAD_H = @as(c_int, 1);
pub const SIGRTMIN = __libc_current_sigrtmin();
pub const SIGRTMAX = __libc_current_sigrtmax();
pub const __G_BASE64_H__ = "";
pub const __G_BITLOCK_H__ = "";
pub const __G_BOOKMARK_FILE_H__ = "";
pub const __G_DATE_TIME_H__ = "";
pub const __G_TIME_ZONE_H__ = "";
pub const G_TIME_SPAN_DAY = G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_int, 86400000000, .decimal));
pub const G_TIME_SPAN_HOUR = G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_int, 3600000000, .decimal));
pub const G_TIME_SPAN_MINUTE = G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_int, 60000000, .decimal));
pub const G_TIME_SPAN_SECOND = G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_int, 1000000, .decimal));
pub const G_TIME_SPAN_MILLISECOND = G_GINT64_CONSTANT(@as(c_int, 1000));
pub const G_BOOKMARK_FILE_ERROR = g_bookmark_file_error_quark();
pub const __G_BYTES_H__ = "";
pub const __G_CHARSET_H__ = "";
pub const __G_CHECKSUM_H__ = "";
pub const __G_CONVERT_H__ = "";
pub const G_CONVERT_ERROR = g_convert_error_quark();
pub const __G_DATASET_H__ = "";
pub const G_DATALIST_FLAGS_MASK = @as(c_int, 0x3);
pub inline fn g_datalist_id_set_data(dl: anytype, q: anytype, d: anytype) @TypeOf(g_datalist_id_set_data_full(dl, q, d, NULL)) {
    return g_datalist_id_set_data_full(dl, q, d, NULL);
}
pub inline fn g_datalist_id_remove_data(dl: anytype, q: anytype) @TypeOf(g_datalist_id_set_data(dl, q, NULL)) {
    return g_datalist_id_set_data(dl, q, NULL);
}
pub inline fn g_datalist_set_data_full(dl: anytype, k: anytype, d: anytype, f: anytype) @TypeOf(g_datalist_id_set_data_full(dl, g_quark_from_string(k), d, f)) {
    return g_datalist_id_set_data_full(dl, g_quark_from_string(k), d, f);
}
pub inline fn g_datalist_remove_no_notify(dl: anytype, k: anytype) @TypeOf(g_datalist_id_remove_no_notify(dl, g_quark_try_string(k))) {
    return g_datalist_id_remove_no_notify(dl, g_quark_try_string(k));
}
pub inline fn g_datalist_set_data(dl: anytype, k: anytype, d: anytype) @TypeOf(g_datalist_set_data_full(dl, k, d, NULL)) {
    return g_datalist_set_data_full(dl, k, d, NULL);
}
pub inline fn g_datalist_remove_data(dl: anytype, k: anytype) @TypeOf(g_datalist_id_set_data(dl, g_quark_try_string(k), NULL)) {
    return g_datalist_id_set_data(dl, g_quark_try_string(k), NULL);
}
pub inline fn g_dataset_id_set_data(l: anytype, k: anytype, d: anytype) @TypeOf(g_dataset_id_set_data_full(l, k, d, NULL)) {
    return g_dataset_id_set_data_full(l, k, d, NULL);
}
pub inline fn g_dataset_id_remove_data(l: anytype, k: anytype) @TypeOf(g_dataset_id_set_data(l, k, NULL)) {
    return g_dataset_id_set_data(l, k, NULL);
}
pub inline fn g_dataset_get_data(l: anytype, k: anytype) @TypeOf(g_dataset_id_get_data(l, g_quark_try_string(k))) {
    return g_dataset_id_get_data(l, g_quark_try_string(k));
}
pub inline fn g_dataset_set_data_full(l: anytype, k: anytype, d: anytype, f: anytype) @TypeOf(g_dataset_id_set_data_full(l, g_quark_from_string(k), d, f)) {
    return g_dataset_id_set_data_full(l, g_quark_from_string(k), d, f);
}
pub inline fn g_dataset_remove_no_notify(l: anytype, k: anytype) @TypeOf(g_dataset_id_remove_no_notify(l, g_quark_try_string(k))) {
    return g_dataset_id_remove_no_notify(l, g_quark_try_string(k));
}
pub inline fn g_dataset_set_data(l: anytype, k: anytype, d: anytype) @TypeOf(g_dataset_set_data_full(l, k, d, NULL)) {
    return g_dataset_set_data_full(l, k, d, NULL);
}
pub inline fn g_dataset_remove_data(l: anytype, k: anytype) @TypeOf(g_dataset_id_set_data(l, g_quark_try_string(k), NULL)) {
    return g_dataset_id_set_data(l, g_quark_try_string(k), NULL);
}
pub const __G_DATE_H__ = "";
pub const G_DATE_BAD_JULIAN = @as(c_uint, 0);
pub const G_DATE_BAD_DAY = @as(c_uint, 0);
pub const G_DATE_BAD_YEAR = @as(c_uint, 0);
pub const g_date_weekday = g_date_get_weekday ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR(g_date_get_weekday);
pub const g_date_month = g_date_get_month ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR(g_date_get_month);
pub const g_date_year = g_date_get_year ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR(g_date_get_year);
pub const g_date_day = g_date_get_day ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR(g_date_get_day);
pub const g_date_julian = g_date_get_julian ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR(g_date_get_julian);
pub const g_date_day_of_year = g_date_get_day_of_year ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR(g_date_get_day_of_year);
pub const g_date_monday_week_of_year = g_date_get_monday_week_of_year ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR(g_date_get_monday_week_of_year);
pub const g_date_sunday_week_of_year = g_date_get_sunday_week_of_year ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR(g_date_get_sunday_week_of_year);
pub const g_date_days_in_month = g_date_get_days_in_month ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR(g_date_get_days_in_month);
pub const g_date_monday_weeks_in_year = g_date_get_monday_weeks_in_year ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR(g_date_get_monday_weeks_in_year);
pub const g_date_sunday_weeks_in_year = g_date_get_sunday_weeks_in_year ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR(g_date_get_sunday_weeks_in_year);
pub const __G_DIR_H__ = "";
pub const _DIRENT_H = @as(c_int, 1);
pub const _DIRENT_HAVE_D_RECLEN = "";
pub const _DIRENT_HAVE_D_OFF = "";
pub const _DIRENT_HAVE_D_TYPE = "";
pub const _DIRENT_MATCHES_DIRENT64 = @as(c_int, 1);
pub inline fn _D_EXACT_NAMLEN(d: anytype) @TypeOf(strlen(d.*.d_name)) {
    return strlen(d.*.d_name);
}
pub inline fn _D_ALLOC_NAMLEN(d: anytype) @TypeOf((@import("std").zig.c_translation.cast([*c]u8, d) + d.*.d_reclen) - (&d.*.d_name[@as(c_int, 0)])) {
    return (@import("std").zig.c_translation.cast([*c]u8, d) + d.*.d_reclen) - (&d.*.d_name[@as(c_int, 0)]);
}
pub inline fn IFTODT(mode: anytype) @TypeOf((mode & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o170000, .octal)) >> @as(c_int, 12)) {
    return (mode & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o170000, .octal)) >> @as(c_int, 12);
}
pub inline fn DTTOIF(dirtype: anytype) @TypeOf(dirtype << @as(c_int, 12)) {
    return dirtype << @as(c_int, 12);
}
pub const MAXNAMLEN = NAME_MAX;
pub const __G_ENVIRON_H__ = "";
pub const __G_FILEUTILS_H__ = "";
pub const G_FILE_ERROR = g_file_error_quark();
pub inline fn G_IS_DIR_SEPARATOR(c: anytype) @TypeOf(c == G_DIR_SEPARATOR) {
    return c == G_DIR_SEPARATOR;
}
pub const g_dirname = g_path_get_dirname ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR(g_path_get_dirname);
pub const __G_GETTEXT_H__ = "";
pub const __G_HASH_H__ = "";
pub const __G_LIST_H__ = "";
pub const __G_MEM_H__ = "";
pub const G_MEM_ALIGN = GLIB_SIZEOF_LONG;
pub inline fn g_new(struct_type: anytype, n_structs: anytype) @TypeOf(_G_NEW(struct_type, n_structs, malloc)) {
    return _G_NEW(struct_type, n_structs, malloc);
}
pub inline fn g_renew(struct_type: anytype, mem: anytype, n_structs: anytype) @TypeOf(_G_RENEW(struct_type, mem, n_structs, realloc)) {
    return _G_RENEW(struct_type, mem, n_structs, realloc);
}
pub const __G_NODE_H__ = "";
pub inline fn G_NODE_IS_ROOT(node: anytype) @TypeOf(((@import("std").zig.c_translation.cast([*c]GNode, node).*.parent == NULL) and (@import("std").zig.c_translation.cast([*c]GNode, node).*.prev == NULL)) and (@import("std").zig.c_translation.cast([*c]GNode, node).*.next == NULL)) {
    return ((@import("std").zig.c_translation.cast([*c]GNode, node).*.parent == NULL) and (@import("std").zig.c_translation.cast([*c]GNode, node).*.prev == NULL)) and (@import("std").zig.c_translation.cast([*c]GNode, node).*.next == NULL);
}
pub inline fn G_NODE_IS_LEAF(node: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]GNode, node).*.children == NULL) {
    return @import("std").zig.c_translation.cast([*c]GNode, node).*.children == NULL;
}
pub inline fn g_node_append(parent: anytype, node: anytype) @TypeOf(g_node_insert_before(parent, NULL, node)) {
    return g_node_insert_before(parent, NULL, node);
}
pub inline fn g_node_insert_data(parent: anytype, position: anytype, data: anytype) @TypeOf(g_node_insert(parent, position, g_node_new(data))) {
    return g_node_insert(parent, position, g_node_new(data));
}
pub inline fn g_node_insert_data_after(parent: anytype, sibling: anytype, data: anytype) @TypeOf(g_node_insert_after(parent, sibling, g_node_new(data))) {
    return g_node_insert_after(parent, sibling, g_node_new(data));
}
pub inline fn g_node_insert_data_before(parent: anytype, sibling: anytype, data: anytype) @TypeOf(g_node_insert_before(parent, sibling, g_node_new(data))) {
    return g_node_insert_before(parent, sibling, g_node_new(data));
}
pub inline fn g_node_prepend_data(parent: anytype, data: anytype) @TypeOf(g_node_prepend(parent, g_node_new(data))) {
    return g_node_prepend(parent, g_node_new(data));
}
pub inline fn g_node_append_data(parent: anytype, data: anytype) @TypeOf(g_node_insert_before(parent, NULL, g_node_new(data))) {
    return g_node_insert_before(parent, NULL, g_node_new(data));
}
pub inline fn g_node_prev_sibling(node: anytype) @TypeOf(if (node) @import("std").zig.c_translation.cast([*c]GNode, node).*.prev else NULL) {
    return if (node) @import("std").zig.c_translation.cast([*c]GNode, node).*.prev else NULL;
}
pub inline fn g_node_next_sibling(node: anytype) @TypeOf(if (node) @import("std").zig.c_translation.cast([*c]GNode, node).*.next else NULL) {
    return if (node) @import("std").zig.c_translation.cast([*c]GNode, node).*.next else NULL;
}
pub inline fn g_node_first_child(node: anytype) @TypeOf(if (node) @import("std").zig.c_translation.cast([*c]GNode, node).*.children else NULL) {
    return if (node) @import("std").zig.c_translation.cast([*c]GNode, node).*.children else NULL;
}
pub const g_list_free1 = g_list_free_1;
pub inline fn g_list_previous(list: anytype) @TypeOf(if (list) @import("std").zig.c_translation.cast([*c]GList, list).*.prev else NULL) {
    return if (list) @import("std").zig.c_translation.cast([*c]GList, list).*.prev else NULL;
}
pub inline fn g_list_next(list: anytype) @TypeOf(if (list) @import("std").zig.c_translation.cast([*c]GList, list).*.next else NULL) {
    return if (list) @import("std").zig.c_translation.cast([*c]GList, list).*.next else NULL;
}
pub inline fn g_hash_table_freeze(hash_table: anytype) @TypeOf(@import("std").zig.c_translation.cast(anyopaque, @as(c_int, 0)) ++ GLIB_DEPRECATED_MACRO_IN_2_26) {
    _ = hash_table;
    return @import("std").zig.c_translation.cast(anyopaque, @as(c_int, 0)) ++ GLIB_DEPRECATED_MACRO_IN_2_26;
}
pub inline fn g_hash_table_thaw(hash_table: anytype) @TypeOf(@import("std").zig.c_translation.cast(anyopaque, @as(c_int, 0)) ++ GLIB_DEPRECATED_MACRO_IN_2_26) {
    _ = hash_table;
    return @import("std").zig.c_translation.cast(anyopaque, @as(c_int, 0)) ++ GLIB_DEPRECATED_MACRO_IN_2_26;
}
pub const __G_HMAC_H__ = "";
pub const __G_HOOK_H__ = "";
pub const G_HOOK_FLAG_USER_SHIFT = @as(c_int, 4);
pub inline fn G_HOOK(hook: anytype) [*c]GHook {
    return @import("std").zig.c_translation.cast([*c]GHook, hook);
}
pub inline fn G_HOOK_FLAGS(hook: anytype) @TypeOf(G_HOOK(hook).*.flags) {
    return G_HOOK(hook).*.flags;
}
pub inline fn G_HOOK_ACTIVE(hook: anytype) @TypeOf((G_HOOK_FLAGS(hook) & G_HOOK_FLAG_ACTIVE) != @as(c_int, 0)) {
    return (G_HOOK_FLAGS(hook) & G_HOOK_FLAG_ACTIVE) != @as(c_int, 0);
}
pub inline fn G_HOOK_IN_CALL(hook: anytype) @TypeOf((G_HOOK_FLAGS(hook) & G_HOOK_FLAG_IN_CALL) != @as(c_int, 0)) {
    return (G_HOOK_FLAGS(hook) & G_HOOK_FLAG_IN_CALL) != @as(c_int, 0);
}
pub inline fn G_HOOK_IS_VALID(hook: anytype) @TypeOf((G_HOOK(hook).*.hook_id != @as(c_int, 0)) and ((G_HOOK_FLAGS(hook) & G_HOOK_FLAG_ACTIVE) != 0)) {
    return (G_HOOK(hook).*.hook_id != @as(c_int, 0)) and ((G_HOOK_FLAGS(hook) & G_HOOK_FLAG_ACTIVE) != 0);
}
pub inline fn G_HOOK_IS_UNLINKED(hook: anytype) @TypeOf((((G_HOOK(hook).*.next == NULL) and (G_HOOK(hook).*.prev == NULL)) and (G_HOOK(hook).*.hook_id == @as(c_int, 0))) and (G_HOOK(hook).*.ref_count == @as(c_int, 0))) {
    return (((G_HOOK(hook).*.next == NULL) and (G_HOOK(hook).*.prev == NULL)) and (G_HOOK(hook).*.hook_id == @as(c_int, 0))) and (G_HOOK(hook).*.ref_count == @as(c_int, 0));
}
pub inline fn g_hook_append(hook_list: anytype, hook: anytype) @TypeOf(g_hook_insert_before(hook_list, NULL, hook)) {
    return g_hook_insert_before(hook_list, NULL, hook);
}
pub const __G_HOST_UTILS_H__ = "";
pub const __G_IOCHANNEL_H__ = "";
pub const __G_MAIN_H__ = "";
pub const __G_POLL_H__ = "";
pub const __G_SLIST_H__ = "";
pub const g_slist_free1 = g_slist_free_1;
pub inline fn g_slist_next(slist: anytype) @TypeOf(if (slist) @import("std").zig.c_translation.cast([*c]GSList, slist).*.next else NULL) {
    return if (slist) @import("std").zig.c_translation.cast([*c]GSList, slist).*.next else NULL;
}
pub const G_PRIORITY_HIGH = -@as(c_int, 100);
pub const G_PRIORITY_DEFAULT = @as(c_int, 0);
pub const G_PRIORITY_HIGH_IDLE = @as(c_int, 100);
pub const G_PRIORITY_DEFAULT_IDLE = @as(c_int, 200);
pub const G_PRIORITY_LOW = @as(c_int, 300);
pub const G_SOURCE_REMOVE = FALSE;
pub const G_SOURCE_CONTINUE = TRUE;
pub const __G_STRING_H__ = "";
pub const __G_UNICODE_H__ = "";
pub const G_UNICODE_COMBINING_MARK = G_UNICODE_SPACING_MARK ++ GLIB_DEPRECATED_MACRO_IN_2_30_FOR(G_UNICODE_SPACING_MARK);
pub const G_UNICHAR_MAX_DECOMPOSITION_LENGTH = @as(c_int, 18);
pub const g_string_sprintf = g_string_printf ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR(g_string_printf);
pub const g_string_sprintfa = g_string_append_printf ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR(g_string_append_printf);
pub const G_IO_CHANNEL_ERROR = g_io_channel_error_quark();
pub const __G_KEY_FILE_H__ = "";
pub const G_KEY_FILE_ERROR = g_key_file_error_quark();
pub const G_KEY_FILE_DESKTOP_GROUP = "Desktop Entry";
pub const G_KEY_FILE_DESKTOP_KEY_TYPE = "Type";
pub const G_KEY_FILE_DESKTOP_KEY_VERSION = "Version";
pub const G_KEY_FILE_DESKTOP_KEY_NAME = "Name";
pub const G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME = "GenericName";
pub const G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY = "NoDisplay";
pub const G_KEY_FILE_DESKTOP_KEY_COMMENT = "Comment";
pub const G_KEY_FILE_DESKTOP_KEY_ICON = "Icon";
pub const G_KEY_FILE_DESKTOP_KEY_HIDDEN = "Hidden";
pub const G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN = "OnlyShowIn";
pub const G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN = "NotShowIn";
pub const G_KEY_FILE_DESKTOP_KEY_TRY_EXEC = "TryExec";
pub const G_KEY_FILE_DESKTOP_KEY_EXEC = "Exec";
pub const G_KEY_FILE_DESKTOP_KEY_PATH = "Path";
pub const G_KEY_FILE_DESKTOP_KEY_TERMINAL = "Terminal";
pub const G_KEY_FILE_DESKTOP_KEY_MIME_TYPE = "MimeType";
pub const G_KEY_FILE_DESKTOP_KEY_CATEGORIES = "Categories";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY = "StartupNotify";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS = "StartupWMClass";
pub const G_KEY_FILE_DESKTOP_KEY_URL = "URL";
pub const G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE = "DBusActivatable";
pub const G_KEY_FILE_DESKTOP_KEY_ACTIONS = "Actions";
pub const G_KEY_FILE_DESKTOP_TYPE_APPLICATION = "Application";
pub const G_KEY_FILE_DESKTOP_TYPE_LINK = "Link";
pub const G_KEY_FILE_DESKTOP_TYPE_DIRECTORY = "Directory";
pub const __G_MAPPED_FILE_H__ = "";
pub const __G_MARKUP_H__ = "";
pub const G_MARKUP_ERROR = g_markup_error_quark();
pub const __G_MESSAGES_H__ = "";
pub const __G_VARIANT_H__ = "";
pub const __G_VARIANT_TYPE_H__ = "";
pub inline fn G_VARIANT_TYPE(type_string: anytype) @TypeOf(g_variant_type_checked_(type_string)) {
    return g_variant_type_checked_(type_string);
}
pub const G_VARIANT_PARSE_ERROR = g_variant_parse_error_quark();
pub const G_LOG_LEVEL_USER_SHIFT = @as(c_int, 8);
pub const G_LOG_FATAL_MASK = G_LOG_FLAG_RECURSION | G_LOG_LEVEL_ERROR;
pub const G_LOG_DOMAIN = @import("std").zig.c_translation.cast([*c]gchar, @as(c_int, 0));
pub const __G_OPTION_H__ = "";
pub const G_OPTION_ERROR = g_option_error_quark();
pub const G_OPTION_REMAINING = "";
pub const G_OPTION_ENTRY_NULL = @import("std").mem.zeroInit(GLIB_AVAILABLE_MACRO_IN_2_70, .{ NULL, @as(c_int, 0), @as(c_int, 0), @as(c_int, 0), NULL, NULL, NULL });
pub const __G_PATTERN_H__ = "";
pub const __G_PRIMES_H__ = "";
pub const __G_QSORT_H__ = "";
pub const __G_QUEUE_H__ = "";
pub const __G_RAND_H__ = "";
pub inline fn g_rand_boolean(rand_: anytype) @TypeOf((g_rand_int(rand_) & (@as(c_int, 1) << @as(c_int, 15))) != @as(c_int, 0)) {
    return (g_rand_int(rand_) & (@as(c_int, 1) << @as(c_int, 15))) != @as(c_int, 0);
}
pub inline fn g_random_boolean() @TypeOf((g_random_int() & (@as(c_int, 1) << @as(c_int, 15))) != @as(c_int, 0)) {
    return (g_random_int() & (@as(c_int, 1) << @as(c_int, 15))) != @as(c_int, 0);
}
pub const __GREFCOUNT_H__ = "";
pub const __G_REGEX_H__ = "";
pub const G_REGEX_ERROR = g_regex_error_quark();
pub const __G_SCANNER_H__ = "";
pub const G_CSET_A_2_Z = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
pub const G_CSET_a_2_z = "abcdefghijklmnopqrstuvwxyz";
pub const G_CSET_DIGITS = "0123456789";
pub const G_CSET_LATINC = "\xc0\xc1\xc2\xc3\xc4\xc5\xc6" ++ "\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0" ++ "\xd1\xd2\xd3\xd4\xd5\xd6" ++ "\xd8\xd9\xda\xdb\xdc\xdd\xde";
pub const G_CSET_LATINS = "\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6" ++ "\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0" ++ "\xf1\xf2\xf3\xf4\xf5\xf6" ++ "\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff";
pub inline fn g_scanner_freeze_symbol_table(scanner: anytype) @TypeOf(@import("std").zig.c_translation.cast(anyopaque, @as(c_int, 0)) ++ GLIB_DEPRECATED_MACRO_IN_2_26) {
    _ = scanner;
    return @import("std").zig.c_translation.cast(anyopaque, @as(c_int, 0)) ++ GLIB_DEPRECATED_MACRO_IN_2_26;
}
pub inline fn g_scanner_thaw_symbol_table(scanner: anytype) @TypeOf(@import("std").zig.c_translation.cast(anyopaque, @as(c_int, 0)) ++ GLIB_DEPRECATED_MACRO_IN_2_26) {
    _ = scanner;
    return @import("std").zig.c_translation.cast(anyopaque, @as(c_int, 0)) ++ GLIB_DEPRECATED_MACRO_IN_2_26;
}
pub const __G_SEQUENCE_H__ = "";
pub const __G_SHELL_H__ = "";
pub const G_SHELL_ERROR = g_shell_error_quark();
pub const __G_SLICE_H__ = "";
pub const __G_SPAWN_H__ = "";
pub const G_SPAWN_ERROR = g_spawn_error_quark();
pub const G_SPAWN_EXIT_ERROR = g_spawn_exit_error_quark();
pub const __G_STRFUNCS_H__ = "";
pub inline fn g_ascii_isalnum(c: anytype) @TypeOf((g_ascii_table[@import("std").zig.c_translation.cast(guchar, c)] & G_ASCII_ALNUM) != @as(c_int, 0)) {
    return (g_ascii_table[@import("std").zig.c_translation.cast(guchar, c)] & G_ASCII_ALNUM) != @as(c_int, 0);
}
pub inline fn g_ascii_isalpha(c: anytype) @TypeOf((g_ascii_table[@import("std").zig.c_translation.cast(guchar, c)] & G_ASCII_ALPHA) != @as(c_int, 0)) {
    return (g_ascii_table[@import("std").zig.c_translation.cast(guchar, c)] & G_ASCII_ALPHA) != @as(c_int, 0);
}
pub inline fn g_ascii_iscntrl(c: anytype) @TypeOf((g_ascii_table[@import("std").zig.c_translation.cast(guchar, c)] & G_ASCII_CNTRL) != @as(c_int, 0)) {
    return (g_ascii_table[@import("std").zig.c_translation.cast(guchar, c)] & G_ASCII_CNTRL) != @as(c_int, 0);
}
pub inline fn g_ascii_isdigit(c: anytype) @TypeOf((g_ascii_table[@import("std").zig.c_translation.cast(guchar, c)] & G_ASCII_DIGIT) != @as(c_int, 0)) {
    return (g_ascii_table[@import("std").zig.c_translation.cast(guchar, c)] & G_ASCII_DIGIT) != @as(c_int, 0);
}
pub inline fn g_ascii_isgraph(c: anytype) @TypeOf((g_ascii_table[@import("std").zig.c_translation.cast(guchar, c)] & G_ASCII_GRAPH) != @as(c_int, 0)) {
    return (g_ascii_table[@import("std").zig.c_translation.cast(guchar, c)] & G_ASCII_GRAPH) != @as(c_int, 0);
}
pub inline fn g_ascii_islower(c: anytype) @TypeOf((g_ascii_table[@import("std").zig.c_translation.cast(guchar, c)] & G_ASCII_LOWER) != @as(c_int, 0)) {
    return (g_ascii_table[@import("std").zig.c_translation.cast(guchar, c)] & G_ASCII_LOWER) != @as(c_int, 0);
}
pub inline fn g_ascii_isprint(c: anytype) @TypeOf((g_ascii_table[@import("std").zig.c_translation.cast(guchar, c)] & G_ASCII_PRINT) != @as(c_int, 0)) {
    return (g_ascii_table[@import("std").zig.c_translation.cast(guchar, c)] & G_ASCII_PRINT) != @as(c_int, 0);
}
pub inline fn g_ascii_ispunct(c: anytype) @TypeOf((g_ascii_table[@import("std").zig.c_translation.cast(guchar, c)] & G_ASCII_PUNCT) != @as(c_int, 0)) {
    return (g_ascii_table[@import("std").zig.c_translation.cast(guchar, c)] & G_ASCII_PUNCT) != @as(c_int, 0);
}
pub inline fn g_ascii_isspace(c: anytype) @TypeOf((g_ascii_table[@import("std").zig.c_translation.cast(guchar, c)] & G_ASCII_SPACE) != @as(c_int, 0)) {
    return (g_ascii_table[@import("std").zig.c_translation.cast(guchar, c)] & G_ASCII_SPACE) != @as(c_int, 0);
}
pub inline fn g_ascii_isupper(c: anytype) @TypeOf((g_ascii_table[@import("std").zig.c_translation.cast(guchar, c)] & G_ASCII_UPPER) != @as(c_int, 0)) {
    return (g_ascii_table[@import("std").zig.c_translation.cast(guchar, c)] & G_ASCII_UPPER) != @as(c_int, 0);
}
pub inline fn g_ascii_isxdigit(c: anytype) @TypeOf((g_ascii_table[@import("std").zig.c_translation.cast(guchar, c)] & G_ASCII_XDIGIT) != @as(c_int, 0)) {
    return (g_ascii_table[@import("std").zig.c_translation.cast(guchar, c)] & G_ASCII_XDIGIT) != @as(c_int, 0);
}
pub const G_STR_DELIMITERS = "_-|> <.";
pub const G_ASCII_DTOSTR_BUF_SIZE = @as(c_int, 29) + @as(c_int, 10);
pub inline fn g_strstrip(string: anytype) @TypeOf(g_strchomp(g_strchug(string))) {
    return g_strchomp(g_strchug(string));
}
pub const G_NUMBER_PARSER_ERROR = g_number_parser_error_quark();
pub const __G_STRINGCHUNK_H__ = "";
pub const __G_STRVBUILDER_H__ = "";
pub const __G_TEST_UTILS_H__ = "";
pub const _ERRNO_H = @as(c_int, 1);
pub const _BITS_ERRNO_H = @as(c_int, 1);
pub const _ASM_GENERIC_ERRNO_H = "";
pub const _ASM_GENERIC_ERRNO_BASE_H = "";
pub const EPERM = @as(c_int, 1);
pub const ENOENT = @as(c_int, 2);
pub const ESRCH = @as(c_int, 3);
pub const EINTR = @as(c_int, 4);
pub const EIO = @as(c_int, 5);
pub const ENXIO = @as(c_int, 6);
pub const E2BIG = @as(c_int, 7);
pub const ENOEXEC = @as(c_int, 8);
pub const EBADF = @as(c_int, 9);
pub const ECHILD = @as(c_int, 10);
pub const EAGAIN = @as(c_int, 11);
pub const ENOMEM = @as(c_int, 12);
pub const EACCES = @as(c_int, 13);
pub const EFAULT = @as(c_int, 14);
pub const ENOTBLK = @as(c_int, 15);
pub const EBUSY = @as(c_int, 16);
pub const EEXIST = @as(c_int, 17);
pub const EXDEV = @as(c_int, 18);
pub const ENODEV = @as(c_int, 19);
pub const ENOTDIR = @as(c_int, 20);
pub const EISDIR = @as(c_int, 21);
pub const EINVAL = @as(c_int, 22);
pub const ENFILE = @as(c_int, 23);
pub const EMFILE = @as(c_int, 24);
pub const ENOTTY = @as(c_int, 25);
pub const ETXTBSY = @as(c_int, 26);
pub const EFBIG = @as(c_int, 27);
pub const ENOSPC = @as(c_int, 28);
pub const ESPIPE = @as(c_int, 29);
pub const EROFS = @as(c_int, 30);
pub const EMLINK = @as(c_int, 31);
pub const EPIPE = @as(c_int, 32);
pub const EDOM = @as(c_int, 33);
pub const ERANGE = @as(c_int, 34);
pub const EDEADLK = @as(c_int, 35);
pub const ENAMETOOLONG = @as(c_int, 36);
pub const ENOLCK = @as(c_int, 37);
pub const ENOSYS = @as(c_int, 38);
pub const ENOTEMPTY = @as(c_int, 39);
pub const ELOOP = @as(c_int, 40);
pub const EWOULDBLOCK = EAGAIN;
pub const ENOMSG = @as(c_int, 42);
pub const EIDRM = @as(c_int, 43);
pub const ECHRNG = @as(c_int, 44);
pub const EL2NSYNC = @as(c_int, 45);
pub const EL3HLT = @as(c_int, 46);
pub const EL3RST = @as(c_int, 47);
pub const ELNRNG = @as(c_int, 48);
pub const EUNATCH = @as(c_int, 49);
pub const ENOCSI = @as(c_int, 50);
pub const EL2HLT = @as(c_int, 51);
pub const EBADE = @as(c_int, 52);
pub const EBADR = @as(c_int, 53);
pub const EXFULL = @as(c_int, 54);
pub const ENOANO = @as(c_int, 55);
pub const EBADRQC = @as(c_int, 56);
pub const EBADSLT = @as(c_int, 57);
pub const EDEADLOCK = EDEADLK;
pub const EBFONT = @as(c_int, 59);
pub const ENOSTR = @as(c_int, 60);
pub const ENODATA = @as(c_int, 61);
pub const ETIME = @as(c_int, 62);
pub const ENOSR = @as(c_int, 63);
pub const ENONET = @as(c_int, 64);
pub const ENOPKG = @as(c_int, 65);
pub const EREMOTE = @as(c_int, 66);
pub const ENOLINK = @as(c_int, 67);
pub const EADV = @as(c_int, 68);
pub const ESRMNT = @as(c_int, 69);
pub const ECOMM = @as(c_int, 70);
pub const EPROTO = @as(c_int, 71);
pub const EMULTIHOP = @as(c_int, 72);
pub const EDOTDOT = @as(c_int, 73);
pub const EBADMSG = @as(c_int, 74);
pub const EOVERFLOW = @as(c_int, 75);
pub const ENOTUNIQ = @as(c_int, 76);
pub const EBADFD = @as(c_int, 77);
pub const EREMCHG = @as(c_int, 78);
pub const ELIBACC = @as(c_int, 79);
pub const ELIBBAD = @as(c_int, 80);
pub const ELIBSCN = @as(c_int, 81);
pub const ELIBMAX = @as(c_int, 82);
pub const ELIBEXEC = @as(c_int, 83);
pub const EILSEQ = @as(c_int, 84);
pub const ERESTART = @as(c_int, 85);
pub const ESTRPIPE = @as(c_int, 86);
pub const EUSERS = @as(c_int, 87);
pub const ENOTSOCK = @as(c_int, 88);
pub const EDESTADDRREQ = @as(c_int, 89);
pub const EMSGSIZE = @as(c_int, 90);
pub const EPROTOTYPE = @as(c_int, 91);
pub const ENOPROTOOPT = @as(c_int, 92);
pub const EPROTONOSUPPORT = @as(c_int, 93);
pub const ESOCKTNOSUPPORT = @as(c_int, 94);
pub const EOPNOTSUPP = @as(c_int, 95);
pub const EPFNOSUPPORT = @as(c_int, 96);
pub const EAFNOSUPPORT = @as(c_int, 97);
pub const EADDRINUSE = @as(c_int, 98);
pub const EADDRNOTAVAIL = @as(c_int, 99);
pub const ENETDOWN = @as(c_int, 100);
pub const ENETUNREACH = @as(c_int, 101);
pub const ENETRESET = @as(c_int, 102);
pub const ECONNABORTED = @as(c_int, 103);
pub const ECONNRESET = @as(c_int, 104);
pub const ENOBUFS = @as(c_int, 105);
pub const EISCONN = @as(c_int, 106);
pub const ENOTCONN = @as(c_int, 107);
pub const ESHUTDOWN = @as(c_int, 108);
pub const ETOOMANYREFS = @as(c_int, 109);
pub const ETIMEDOUT = @as(c_int, 110);
pub const ECONNREFUSED = @as(c_int, 111);
pub const EHOSTDOWN = @as(c_int, 112);
pub const EHOSTUNREACH = @as(c_int, 113);
pub const EALREADY = @as(c_int, 114);
pub const EINPROGRESS = @as(c_int, 115);
pub const ESTALE = @as(c_int, 116);
pub const EUCLEAN = @as(c_int, 117);
pub const ENOTNAM = @as(c_int, 118);
pub const ENAVAIL = @as(c_int, 119);
pub const EISNAM = @as(c_int, 120);
pub const EREMOTEIO = @as(c_int, 121);
pub const EDQUOT = @as(c_int, 122);
pub const ENOMEDIUM = @as(c_int, 123);
pub const EMEDIUMTYPE = @as(c_int, 124);
pub const ECANCELED = @as(c_int, 125);
pub const ENOKEY = @as(c_int, 126);
pub const EKEYEXPIRED = @as(c_int, 127);
pub const EKEYREVOKED = @as(c_int, 128);
pub const EKEYREJECTED = @as(c_int, 129);
pub const EOWNERDEAD = @as(c_int, 130);
pub const ENOTRECOVERABLE = @as(c_int, 131);
pub const ERFKILL = @as(c_int, 132);
pub const EHWPOISON = @as(c_int, 133);
pub const ENOTSUP = EOPNOTSUPP;
pub const errno = __errno_location().*;
pub const G_TEST_OPTION_ISOLATE_DIRS = "isolate_dirs";
pub inline fn g_test_initialized() @TypeOf(g_test_config_vars.*.test_initialized) {
    return g_test_config_vars.*.test_initialized;
}
pub inline fn g_test_quick() @TypeOf(g_test_config_vars.*.test_quick) {
    return g_test_config_vars.*.test_quick;
}
pub inline fn g_test_slow() @TypeOf(!(g_test_config_vars.*.test_quick != 0)) {
    return !(g_test_config_vars.*.test_quick != 0);
}
pub inline fn g_test_thorough() @TypeOf(!(g_test_config_vars.*.test_quick != 0)) {
    return !(g_test_config_vars.*.test_quick != 0);
}
pub inline fn g_test_perf() @TypeOf(g_test_config_vars.*.test_perf) {
    return g_test_config_vars.*.test_perf;
}
pub inline fn g_test_verbose() @TypeOf(g_test_config_vars.*.test_verbose) {
    return g_test_config_vars.*.test_verbose;
}
pub inline fn g_test_quiet() @TypeOf(g_test_config_vars.*.test_quiet) {
    return g_test_config_vars.*.test_quiet;
}
pub inline fn g_test_undefined() @TypeOf(g_test_config_vars.*.test_undefined) {
    return g_test_config_vars.*.test_undefined;
}
pub inline fn g_test_queue_unref(gobject: anytype) @TypeOf(g_test_queue_destroy(g_object_unref, gobject)) {
    return g_test_queue_destroy(g_object_unref, gobject);
}
pub inline fn g_test_rand_bit() @TypeOf(@as(c_int, 0) != (g_test_rand_int() & (@as(c_int, 1) << @as(c_int, 15)))) {
    return @as(c_int, 0) != (g_test_rand_int() & (@as(c_int, 1) << @as(c_int, 15)));
}
pub const __G_THREADPOOL_H__ = "";
pub const __G_TIMER_H__ = "";
pub const G_USEC_PER_SEC = @import("std").zig.c_translation.promoteIntLiteral(c_int, 1000000, .decimal);
pub const __G_TRASH_STACK_H__ = "";
pub const __G_TREE_H__ = "";
pub const G_URI_ERROR = g_uri_error_quark() ++ GLIB_AVAILABLE_MACRO_IN_2_66;
pub const G_URI_RESERVED_CHARS_GENERIC_DELIMITERS = ":/?#[]@";
pub const G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS = "!$&'()*+,;=";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH_ELEMENT = G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS ++ ":@";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH = G_URI_RESERVED_CHARS_ALLOWED_IN_PATH_ELEMENT ++ "/";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_USERINFO = G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS ++ ":";
pub const __G_UUID_H__ = "";
pub const __G_VERSION_H__ = "";
pub inline fn GLIB_CHECK_VERSION(major: anytype, minor: anytype, micro: anytype) @TypeOf(((GLIB_MAJOR_VERSION > major) or ((GLIB_MAJOR_VERSION == major) and (GLIB_MINOR_VERSION > minor))) or (((GLIB_MAJOR_VERSION == major) and (GLIB_MINOR_VERSION == minor)) and (GLIB_MICRO_VERSION >= micro))) {
    return ((GLIB_MAJOR_VERSION > major) or ((GLIB_MAJOR_VERSION == major) and (GLIB_MINOR_VERSION > minor))) or (((GLIB_MAJOR_VERSION == major) and (GLIB_MINOR_VERSION == minor)) and (GLIB_MICRO_VERSION >= micro));
}
pub const __G_ALLOCATOR_H__ = "";
pub const G_ALLOC_ONLY = @as(c_int, 1);
pub const G_ALLOC_AND_FREE = @as(c_int, 2);
pub const G_ALLOCATOR_LIST = @as(c_int, 1);
pub const G_ALLOCATOR_SLIST = @as(c_int, 2);
pub const G_ALLOCATOR_NODE = @as(c_int, 3);
pub inline fn g_chunk_free(mem: anytype, mem_chunk: anytype) @TypeOf(g_mem_chunk_free(mem_chunk, mem)) {
    return g_mem_chunk_free(mem_chunk, mem);
}
pub inline fn g_mem_chunk_create(@"type": anytype, x: anytype, y: anytype) @TypeOf(g_mem_chunk_new(NULL, @import("std").zig.c_translation.sizeof(@"type"), @as(c_int, 0), @as(c_int, 0))) {
    _ = @"type";
    _ = x;
    _ = y;
    return g_mem_chunk_new(NULL, @import("std").zig.c_translation.sizeof(@"type"), @as(c_int, 0), @as(c_int, 0));
}
pub const __G_CACHE_H__ = "";
pub const __G_COMPLETION_H__ = "";
pub const __G_DEPRECATED_MAIN_H__ = "";
pub const __G_REL_H__ = "";
pub const __G_DEPRECATED_THREAD_H__ = "";
pub const _PTHREAD_H = @as(c_int, 1);
pub const _SCHED_H = @as(c_int, 1);
pub const _BITS_SCHED_H = @as(c_int, 1);
pub const SCHED_OTHER = @as(c_int, 0);
pub const SCHED_FIFO = @as(c_int, 1);
pub const SCHED_RR = @as(c_int, 2);
pub const _BITS_TYPES_STRUCT_SCHED_PARAM = @as(c_int, 1);
pub const _BITS_CPU_SET_H = @as(c_int, 1);
pub const __CPU_SETSIZE = @as(c_int, 1024);
pub const __NCPUBITS = @as(c_int, 8) * @import("std").zig.c_translation.sizeof(__cpu_mask);
pub inline fn __CPUELT(cpu: anytype) @TypeOf(cpu / __NCPUBITS) {
    return cpu / __NCPUBITS;
}
pub inline fn __CPUMASK(cpu: anytype) @TypeOf(@import("std").zig.c_translation.cast(__cpu_mask, @as(c_int, 1)) << (cpu % __NCPUBITS)) {
    return @import("std").zig.c_translation.cast(__cpu_mask, @as(c_int, 1)) << (cpu % __NCPUBITS);
}
pub inline fn __CPU_COUNT_S(setsize: anytype, cpusetp: anytype) @TypeOf(__sched_cpucount(setsize, cpusetp)) {
    return __sched_cpucount(setsize, cpusetp);
}
pub inline fn __CPU_ALLOC_SIZE(count: anytype) @TypeOf((((count + __NCPUBITS) - @as(c_int, 1)) / __NCPUBITS) * @import("std").zig.c_translation.sizeof(__cpu_mask)) {
    return (((count + __NCPUBITS) - @as(c_int, 1)) / __NCPUBITS) * @import("std").zig.c_translation.sizeof(__cpu_mask);
}
pub inline fn __CPU_ALLOC(count: anytype) @TypeOf(__sched_cpualloc(count)) {
    return __sched_cpualloc(count);
}
pub inline fn __CPU_FREE(cpuset: anytype) @TypeOf(__sched_cpufree(cpuset)) {
    return __sched_cpufree(cpuset);
}
pub const _BITS_SETJMP_H = @as(c_int, 1);
pub const __jmp_buf_tag_defined = @as(c_int, 1);
pub const PTHREAD_CANCELED = @import("std").zig.c_translation.cast(?*anyopaque, -@as(c_int, 1));
pub const PTHREAD_ONCE_INIT = @as(c_int, 0);
pub const PTHREAD_BARRIER_SERIAL_THREAD = -@as(c_int, 1);
pub const __cleanup_fct_attribute = "";
pub inline fn __sigsetjmp_cancel(env: anytype, savemask: anytype) @TypeOf(__sigsetjmp(@import("std").zig.c_translation.cast([*c]struct___jmp_buf_tag, @import("std").zig.c_translation.cast(?*anyopaque, env)), savemask)) {
    return __sigsetjmp(@import("std").zig.c_translation.cast([*c]struct___jmp_buf_tag, @import("std").zig.c_translation.cast(?*anyopaque, env)), savemask);
}
pub const g_static_mutex_get_mutex = g_static_mutex_get_mutex_impl ++ GLIB_DEPRECATED_MACRO_IN_2_32;
pub inline fn g_thread_supported() @TypeOf(@as(c_int, 1) ++ GLIB_DEPRECATED_MACRO_IN_2_32) {
    return @as(c_int, 1) ++ GLIB_DEPRECATED_MACRO_IN_2_32;
}
pub const __GST_GLIB_COMPAT_H__ = "";
pub const __GLIB_GOBJECT_H__ = "";
pub const __GLIB_GOBJECT_H_INSIDE__ = "";
pub const __G_BINDING_H__ = "";
pub const __G_OBJECT_H__ = "";
pub const __G_TYPE_H__ = "";
pub inline fn G_TYPE_FUNDAMENTAL(@"type": anytype) @TypeOf(g_type_fundamental(@"type")) {
    return g_type_fundamental(@"type");
}
pub const G_TYPE_FUNDAMENTAL_MAX = @as(c_int, 255) << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_INVALID = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 0));
pub const G_TYPE_NONE = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 1));
pub const G_TYPE_INTERFACE = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 2));
pub const G_TYPE_CHAR = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 3));
pub const G_TYPE_UCHAR = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 4));
pub const G_TYPE_BOOLEAN = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 5));
pub const G_TYPE_INT = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 6));
pub const G_TYPE_UINT = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 7));
pub const G_TYPE_LONG = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 8));
pub const G_TYPE_ULONG = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 9));
pub const G_TYPE_INT64 = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 10));
pub const G_TYPE_UINT64 = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 11));
pub const G_TYPE_ENUM = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 12));
pub const G_TYPE_FLAGS = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 13));
pub const G_TYPE_FLOAT = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 14));
pub const G_TYPE_DOUBLE = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 15));
pub const G_TYPE_STRING = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 16));
pub const G_TYPE_POINTER = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 17));
pub const G_TYPE_BOXED = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 18));
pub const G_TYPE_PARAM = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 19));
pub const G_TYPE_OBJECT = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 20));
pub const G_TYPE_VARIANT = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 21));
pub const G_TYPE_FUNDAMENTAL_SHIFT = @as(c_int, 2);
pub inline fn G_TYPE_MAKE_FUNDAMENTAL(x: anytype) GType {
    return @import("std").zig.c_translation.cast(GType, x << G_TYPE_FUNDAMENTAL_SHIFT);
}
pub const G_TYPE_RESERVED_GLIB_FIRST = @as(c_int, 22);
pub const G_TYPE_RESERVED_GLIB_LAST = @as(c_int, 31);
pub const G_TYPE_RESERVED_BSE_FIRST = @as(c_int, 32);
pub const G_TYPE_RESERVED_BSE_LAST = @as(c_int, 48);
pub const G_TYPE_RESERVED_USER_FIRST = @as(c_int, 49);
pub inline fn G_TYPE_IS_FUNDAMENTAL(@"type": anytype) @TypeOf(@"type" <= G_TYPE_FUNDAMENTAL_MAX) {
    return @"type" <= G_TYPE_FUNDAMENTAL_MAX;
}
pub inline fn G_TYPE_IS_DERIVED(@"type": anytype) @TypeOf(@"type" > G_TYPE_FUNDAMENTAL_MAX) {
    return @"type" > G_TYPE_FUNDAMENTAL_MAX;
}
pub inline fn G_TYPE_IS_INTERFACE(@"type": anytype) @TypeOf(G_TYPE_FUNDAMENTAL(@"type") == G_TYPE_INTERFACE) {
    return G_TYPE_FUNDAMENTAL(@"type") == G_TYPE_INTERFACE;
}
pub inline fn G_TYPE_IS_CLASSED(@"type": anytype) @TypeOf(g_type_test_flags(@"type", G_TYPE_FLAG_CLASSED)) {
    return g_type_test_flags(@"type", G_TYPE_FLAG_CLASSED);
}
pub inline fn G_TYPE_IS_INSTANTIATABLE(@"type": anytype) @TypeOf(g_type_test_flags(@"type", G_TYPE_FLAG_INSTANTIATABLE)) {
    return g_type_test_flags(@"type", G_TYPE_FLAG_INSTANTIATABLE);
}
pub inline fn G_TYPE_IS_DERIVABLE(@"type": anytype) @TypeOf(g_type_test_flags(@"type", G_TYPE_FLAG_DERIVABLE)) {
    return g_type_test_flags(@"type", G_TYPE_FLAG_DERIVABLE);
}
pub inline fn G_TYPE_IS_DEEP_DERIVABLE(@"type": anytype) @TypeOf(g_type_test_flags(@"type", G_TYPE_FLAG_DEEP_DERIVABLE)) {
    return g_type_test_flags(@"type", G_TYPE_FLAG_DEEP_DERIVABLE);
}
pub inline fn G_TYPE_IS_ABSTRACT(@"type": anytype) @TypeOf(g_type_test_flags(@"type", G_TYPE_FLAG_ABSTRACT)) {
    return g_type_test_flags(@"type", G_TYPE_FLAG_ABSTRACT);
}
pub inline fn G_TYPE_IS_VALUE_ABSTRACT(@"type": anytype) @TypeOf(g_type_test_flags(@"type", G_TYPE_FLAG_VALUE_ABSTRACT)) {
    return g_type_test_flags(@"type", G_TYPE_FLAG_VALUE_ABSTRACT);
}
pub inline fn G_TYPE_IS_VALUE_TYPE(@"type": anytype) @TypeOf(g_type_check_is_value_type(@"type")) {
    return g_type_check_is_value_type(@"type");
}
pub inline fn G_TYPE_HAS_VALUE_TABLE(@"type": anytype) @TypeOf(g_type_value_table_peek(@"type") != NULL) {
    return g_type_value_table_peek(@"type") != NULL;
}
pub inline fn G_TYPE_IS_FINAL(@"type": anytype) @TypeOf(g_type_test_flags(@"type", G_TYPE_FLAG_FINAL) ++ GLIB_AVAILABLE_MACRO_IN_2_70) {
    return g_type_test_flags(@"type", G_TYPE_FLAG_FINAL) ++ GLIB_AVAILABLE_MACRO_IN_2_70;
}
pub inline fn G_TYPE_CHECK_INSTANCE(instance: anytype) @TypeOf(_G_TYPE_CHI(@import("std").zig.c_translation.cast([*c]GTypeInstance, instance))) {
    return _G_TYPE_CHI(@import("std").zig.c_translation.cast([*c]GTypeInstance, instance));
}
pub inline fn G_TYPE_CHECK_INSTANCE_CAST(instance: anytype, g_type: anytype, c_type: anytype) @TypeOf(_G_TYPE_CIC(instance, g_type, c_type)) {
    return _G_TYPE_CIC(instance, g_type, c_type);
}
pub inline fn G_TYPE_CHECK_INSTANCE_TYPE(instance: anytype, g_type: anytype) @TypeOf(_G_TYPE_CIT(instance, g_type)) {
    return _G_TYPE_CIT(instance, g_type);
}
pub inline fn G_TYPE_CHECK_INSTANCE_FUNDAMENTAL_TYPE(instance: anytype, g_type: anytype) @TypeOf(_G_TYPE_CIFT(instance, g_type)) {
    return _G_TYPE_CIFT(instance, g_type);
}
pub inline fn G_TYPE_INSTANCE_GET_CLASS(instance: anytype, g_type: anytype, c_type: anytype) @TypeOf(_G_TYPE_IGC(instance, g_type, c_type)) {
    return _G_TYPE_IGC(instance, g_type, c_type);
}
pub inline fn G_TYPE_INSTANCE_GET_INTERFACE(instance: anytype, g_type: anytype, c_type: anytype) @TypeOf(_G_TYPE_IGI(instance, g_type, c_type)) {
    return _G_TYPE_IGI(instance, g_type, c_type);
}
pub inline fn G_TYPE_CHECK_CLASS_CAST(g_class: anytype, g_type: anytype, c_type: anytype) @TypeOf(_G_TYPE_CCC(g_class, g_type, c_type)) {
    return _G_TYPE_CCC(g_class, g_type, c_type);
}
pub inline fn G_TYPE_CHECK_CLASS_TYPE(g_class: anytype, g_type: anytype) @TypeOf(_G_TYPE_CCT(g_class, g_type)) {
    return _G_TYPE_CCT(g_class, g_type);
}
pub inline fn G_TYPE_CHECK_VALUE(value: anytype) @TypeOf(_G_TYPE_CHV(value)) {
    return _G_TYPE_CHV(value);
}
pub inline fn G_TYPE_CHECK_VALUE_TYPE(value: anytype, g_type: anytype) @TypeOf(_G_TYPE_CVH(value, g_type)) {
    return _G_TYPE_CVH(value, g_type);
}
pub inline fn G_TYPE_FROM_INSTANCE(instance: anytype) @TypeOf(G_TYPE_FROM_CLASS(@import("std").zig.c_translation.cast([*c]GTypeInstance, instance).*.g_class)) {
    return G_TYPE_FROM_CLASS(@import("std").zig.c_translation.cast([*c]GTypeInstance, instance).*.g_class);
}
pub inline fn G_TYPE_FROM_CLASS(g_class: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]GTypeClass, g_class).*.g_type) {
    return @import("std").zig.c_translation.cast([*c]GTypeClass, g_class).*.g_type;
}
pub inline fn G_TYPE_FROM_INTERFACE(g_iface: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]GTypeInterface, g_iface).*.g_type) {
    return @import("std").zig.c_translation.cast([*c]GTypeInterface, g_iface).*.g_type;
}
pub inline fn G_DEFINE_TYPE_WITH_PRIVATE(TN: anytype, t_n: anytype, T_P: anytype) @TypeOf(G_DEFINE_TYPE_EXTENDED(TN, t_n, T_P, @as(c_int, 0), G_ADD_PRIVATE(TN))) {
    return G_DEFINE_TYPE_EXTENDED(TN, t_n, T_P, @as(c_int, 0), G_ADD_PRIVATE(TN));
}
pub inline fn G_DEFINE_ABSTRACT_TYPE_WITH_PRIVATE(TN: anytype, t_n: anytype, T_P: anytype) @TypeOf(G_DEFINE_TYPE_EXTENDED(TN, t_n, T_P, G_TYPE_FLAG_ABSTRACT, G_ADD_PRIVATE(TN))) {
    return G_DEFINE_TYPE_EXTENDED(TN, t_n, T_P, G_TYPE_FLAG_ABSTRACT, G_ADD_PRIVATE(TN));
}
pub inline fn G_PRIVATE_FIELD_P(TypeName: anytype, inst: anytype, field_name: anytype) @TypeOf(G_STRUCT_MEMBER_P(inst, G_PRIVATE_OFFSET(TypeName, field_name))) {
    return G_STRUCT_MEMBER_P(inst, G_PRIVATE_OFFSET(TypeName, field_name));
}
pub inline fn G_PRIVATE_FIELD(TypeName: anytype, inst: anytype, field_type: anytype, field_name: anytype) @TypeOf(G_STRUCT_MEMBER(field_type, inst, G_PRIVATE_OFFSET(TypeName, field_name))) {
    return G_STRUCT_MEMBER(field_type, inst, G_PRIVATE_OFFSET(TypeName, field_name));
}
pub inline fn _G_TYPE_CHI(ip: anytype) @TypeOf(g_type_check_instance(@import("std").zig.c_translation.cast([*c]GTypeInstance, ip))) {
    return g_type_check_instance(@import("std").zig.c_translation.cast([*c]GTypeInstance, ip));
}
pub inline fn _G_TYPE_CHV(vl: anytype) @TypeOf(g_type_check_value(@import("std").zig.c_translation.cast([*c]GValue, vl))) {
    return g_type_check_value(@import("std").zig.c_translation.cast([*c]GValue, vl));
}
pub inline fn _G_TYPE_CIFT(ip: anytype, ft: anytype) @TypeOf(g_type_check_instance_is_fundamentally_a(@import("std").zig.c_translation.cast([*c]GTypeInstance, ip), ft)) {
    return g_type_check_instance_is_fundamentally_a(@import("std").zig.c_translation.cast([*c]GTypeInstance, ip), ft);
}
pub const G_TYPE_FLAG_RESERVED_ID_BIT = @import("std").zig.c_translation.cast(GType, @as(c_int, 1) << @as(c_int, 0));
pub const __G_VALUE_H__ = "";
pub inline fn G_TYPE_IS_VALUE(@"type": anytype) @TypeOf(g_type_check_is_value_type(@"type")) {
    return g_type_check_is_value_type(@"type");
}
pub inline fn G_IS_VALUE(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE(value)) {
    return G_TYPE_CHECK_VALUE(value);
}
pub inline fn G_VALUE_TYPE(value: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]GValue, value).*.g_type) {
    return @import("std").zig.c_translation.cast([*c]GValue, value).*.g_type;
}
pub inline fn G_VALUE_TYPE_NAME(value: anytype) @TypeOf(g_type_name(G_VALUE_TYPE(value))) {
    return g_type_name(G_VALUE_TYPE(value));
}
pub inline fn G_VALUE_HOLDS(value: anytype, @"type": anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, @"type")) {
    return G_TYPE_CHECK_VALUE_TYPE(value, @"type");
}
pub const G_VALUE_NOCOPY_CONTENTS = @as(c_int, 1) << @as(c_int, 27);
pub const G_VALUE_INTERNED_STRING = @as(c_int, 1) << @as(c_int, 28) ++ GLIB_AVAILABLE_MACRO_IN_2_66;
pub const __G_PARAM_H__ = "";
pub inline fn G_TYPE_IS_PARAM(@"type": anytype) @TypeOf(G_TYPE_FUNDAMENTAL(@"type") == G_TYPE_PARAM) {
    return G_TYPE_FUNDAMENTAL(@"type") == G_TYPE_PARAM;
}
pub inline fn G_PARAM_SPEC(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM, GParamSpec)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM, GParamSpec);
}
pub inline fn G_IS_PARAM_SPEC(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_FUNDAMENTAL_TYPE(pspec, G_TYPE_PARAM)) {
    return G_TYPE_CHECK_INSTANCE_FUNDAMENTAL_TYPE(pspec, G_TYPE_PARAM);
}
pub inline fn G_PARAM_SPEC_CLASS(pclass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(pclass, G_TYPE_PARAM, GParamSpecClass)) {
    return G_TYPE_CHECK_CLASS_CAST(pclass, G_TYPE_PARAM, GParamSpecClass);
}
pub inline fn G_IS_PARAM_SPEC_CLASS(pclass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(pclass, G_TYPE_PARAM)) {
    return G_TYPE_CHECK_CLASS_TYPE(pclass, G_TYPE_PARAM);
}
pub inline fn G_PARAM_SPEC_GET_CLASS(pspec: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(pspec, G_TYPE_PARAM, GParamSpecClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(pspec, G_TYPE_PARAM, GParamSpecClass);
}
pub inline fn G_PARAM_SPEC_TYPE(pspec: anytype) @TypeOf(G_TYPE_FROM_INSTANCE(pspec)) {
    return G_TYPE_FROM_INSTANCE(pspec);
}
pub inline fn G_PARAM_SPEC_TYPE_NAME(pspec: anytype) @TypeOf(g_type_name(G_PARAM_SPEC_TYPE(pspec))) {
    return g_type_name(G_PARAM_SPEC_TYPE(pspec));
}
pub inline fn G_PARAM_SPEC_VALUE_TYPE(pspec: anytype) @TypeOf(G_PARAM_SPEC(pspec).*.value_type) {
    return G_PARAM_SPEC(pspec).*.value_type;
}
pub inline fn G_VALUE_HOLDS_PARAM(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_PARAM)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_PARAM);
}
pub const G_PARAM_STATIC_STRINGS = (G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK) | G_PARAM_STATIC_BLURB;
pub const G_PARAM_MASK = @as(c_int, 0x000000ff);
pub const G_PARAM_USER_SHIFT = @as(c_int, 8);
pub const __G_CLOSURE_H__ = "";
pub inline fn G_CLOSURE_NEEDS_MARSHAL(closure: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]GClosure, closure).*.marshal == NULL) {
    return @import("std").zig.c_translation.cast([*c]GClosure, closure).*.marshal == NULL;
}
pub inline fn G_CLOSURE_N_NOTIFIERS(cl: anytype) @TypeOf(((cl.*.n_guards << @as(c_long, 1)) + cl.*.n_fnotifiers) + cl.*.n_inotifiers) {
    return ((cl.*.n_guards << @as(c_long, 1)) + cl.*.n_fnotifiers) + cl.*.n_inotifiers;
}
pub inline fn G_CCLOSURE_SWAP_DATA(cclosure: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]GClosure, cclosure).*.derivative_flag) {
    return @import("std").zig.c_translation.cast([*c]GClosure, cclosure).*.derivative_flag;
}
pub inline fn G_CALLBACK(f: anytype) GCallback {
    return @import("std").zig.c_translation.cast(GCallback, f);
}
pub const __G_SIGNAL_H__ = "";
pub const __G_MARSHAL_H__ = "";
pub const g_cclosure_marshal_BOOL__FLAGS = g_cclosure_marshal_BOOLEAN__FLAGS;
pub const g_cclosure_marshal_BOOL__BOXED_BOXED = g_cclosure_marshal_BOOLEAN__BOXED_BOXED;
pub const G_SIGNAL_FLAGS_MASK = @as(c_int, 0x1ff);
pub const G_SIGNAL_MATCH_MASK = @as(c_int, 0x3f);
pub const G_SIGNAL_TYPE_STATIC_SCOPE = G_TYPE_FLAG_RESERVED_ID_BIT;
pub inline fn g_signal_connect(instance: anytype, detailed_signal: anytype, c_handler: anytype, data: anytype) @TypeOf(g_signal_connect_data(instance, detailed_signal, c_handler, data, NULL, @import("std").zig.c_translation.cast(GConnectFlags, @as(c_int, 0)))) {
    return g_signal_connect_data(instance, detailed_signal, c_handler, data, NULL, @import("std").zig.c_translation.cast(GConnectFlags, @as(c_int, 0)));
}
pub inline fn g_signal_connect_after(instance: anytype, detailed_signal: anytype, c_handler: anytype, data: anytype) @TypeOf(g_signal_connect_data(instance, detailed_signal, c_handler, data, NULL, G_CONNECT_AFTER)) {
    return g_signal_connect_data(instance, detailed_signal, c_handler, data, NULL, G_CONNECT_AFTER);
}
pub inline fn g_signal_connect_swapped(instance: anytype, detailed_signal: anytype, c_handler: anytype, data: anytype) @TypeOf(g_signal_connect_data(instance, detailed_signal, c_handler, data, NULL, G_CONNECT_SWAPPED)) {
    return g_signal_connect_data(instance, detailed_signal, c_handler, data, NULL, G_CONNECT_SWAPPED);
}
pub inline fn g_signal_handlers_disconnect_by_func(instance: anytype, func: anytype, data: anytype) @TypeOf(g_signal_handlers_disconnect_matched(instance, @import("std").zig.c_translation.cast(GSignalMatchType, G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), @as(c_int, 0), @as(c_int, 0), NULL, func, data)) {
    return g_signal_handlers_disconnect_matched(instance, @import("std").zig.c_translation.cast(GSignalMatchType, G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), @as(c_int, 0), @as(c_int, 0), NULL, func, data);
}
pub inline fn g_signal_handlers_disconnect_by_data(instance: anytype, data: anytype) @TypeOf(g_signal_handlers_disconnect_matched(instance, G_SIGNAL_MATCH_DATA, @as(c_int, 0), @as(c_int, 0), NULL, NULL, data)) {
    return g_signal_handlers_disconnect_matched(instance, G_SIGNAL_MATCH_DATA, @as(c_int, 0), @as(c_int, 0), NULL, NULL, data);
}
pub inline fn g_signal_handlers_block_by_func(instance: anytype, func: anytype, data: anytype) @TypeOf(g_signal_handlers_block_matched(instance, @import("std").zig.c_translation.cast(GSignalMatchType, G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), @as(c_int, 0), @as(c_int, 0), NULL, func, data)) {
    return g_signal_handlers_block_matched(instance, @import("std").zig.c_translation.cast(GSignalMatchType, G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), @as(c_int, 0), @as(c_int, 0), NULL, func, data);
}
pub inline fn g_signal_handlers_unblock_by_func(instance: anytype, func: anytype, data: anytype) @TypeOf(g_signal_handlers_unblock_matched(instance, @import("std").zig.c_translation.cast(GSignalMatchType, G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), @as(c_int, 0), @as(c_int, 0), NULL, func, data)) {
    return g_signal_handlers_unblock_matched(instance, @import("std").zig.c_translation.cast(GSignalMatchType, G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), @as(c_int, 0), @as(c_int, 0), NULL, func, data);
}
pub const __G_BOXED_H__ = "";
pub const __GLIB_TYPES_H__ = "";
pub const G_TYPE_DATE = g_date_get_type();
pub const G_TYPE_STRV = g_strv_get_type();
pub const G_TYPE_GSTRING = g_gstring_get_type();
pub const G_TYPE_HASH_TABLE = g_hash_table_get_type();
pub const G_TYPE_REGEX = g_regex_get_type();
pub const G_TYPE_MATCH_INFO = g_match_info_get_type();
pub const G_TYPE_ARRAY = g_array_get_type();
pub const G_TYPE_BYTE_ARRAY = g_byte_array_get_type();
pub const G_TYPE_PTR_ARRAY = g_ptr_array_get_type();
pub const G_TYPE_BYTES = g_bytes_get_type();
pub const G_TYPE_VARIANT_TYPE = g_variant_type_get_gtype();
pub const G_TYPE_ERROR = g_error_get_type();
pub const G_TYPE_DATE_TIME = g_date_time_get_type();
pub const G_TYPE_TIME_ZONE = g_time_zone_get_type();
pub const G_TYPE_IO_CHANNEL = g_io_channel_get_type();
pub const G_TYPE_IO_CONDITION = g_io_condition_get_type();
pub const G_TYPE_VARIANT_BUILDER = g_variant_builder_get_type();
pub const G_TYPE_VARIANT_DICT = g_variant_dict_get_type();
pub const G_TYPE_MAIN_LOOP = g_main_loop_get_type();
pub const G_TYPE_MAIN_CONTEXT = g_main_context_get_type();
pub const G_TYPE_SOURCE = g_source_get_type();
pub const G_TYPE_POLLFD = g_pollfd_get_type();
pub const G_TYPE_MARKUP_PARSE_CONTEXT = g_markup_parse_context_get_type();
pub const G_TYPE_KEY_FILE = g_key_file_get_type();
pub const G_TYPE_MAPPED_FILE = g_mapped_file_get_type();
pub const G_TYPE_THREAD = g_thread_get_type();
pub const G_TYPE_CHECKSUM = g_checksum_get_type();
pub const G_TYPE_OPTION_GROUP = g_option_group_get_type();
pub const G_TYPE_URI = g_uri_get_type();
pub const G_TYPE_TREE = g_tree_get_type();
pub const G_TYPE_PATTERN_SPEC = g_pattern_spec_get_type();
pub inline fn G_TYPE_IS_BOXED(@"type": anytype) @TypeOf(G_TYPE_FUNDAMENTAL(@"type") == G_TYPE_BOXED) {
    return G_TYPE_FUNDAMENTAL(@"type") == G_TYPE_BOXED;
}
pub inline fn G_VALUE_HOLDS_BOXED(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_BOXED)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_BOXED);
}
pub const G_TYPE_CLOSURE = g_closure_get_type();
pub const G_TYPE_VALUE = g_value_get_type();
pub inline fn G_TYPE_IS_OBJECT(@"type": anytype) @TypeOf(G_TYPE_FUNDAMENTAL(@"type") == G_TYPE_OBJECT) {
    return G_TYPE_FUNDAMENTAL(@"type") == G_TYPE_OBJECT;
}
pub inline fn G_OBJECT(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, G_TYPE_OBJECT, GObject)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, G_TYPE_OBJECT, GObject);
}
pub inline fn G_OBJECT_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_OBJECT, GObjectClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_OBJECT, GObjectClass);
}
pub inline fn G_IS_OBJECT(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_FUNDAMENTAL_TYPE(object, G_TYPE_OBJECT)) {
    return G_TYPE_CHECK_INSTANCE_FUNDAMENTAL_TYPE(object, G_TYPE_OBJECT);
}
pub inline fn G_IS_OBJECT_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_OBJECT)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_OBJECT);
}
pub inline fn G_OBJECT_GET_CLASS(object: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(object, G_TYPE_OBJECT, GObjectClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(object, G_TYPE_OBJECT, GObjectClass);
}
pub inline fn G_OBJECT_TYPE(object: anytype) @TypeOf(G_TYPE_FROM_INSTANCE(object)) {
    return G_TYPE_FROM_INSTANCE(object);
}
pub inline fn G_OBJECT_TYPE_NAME(object: anytype) @TypeOf(g_type_name(G_OBJECT_TYPE(object))) {
    return g_type_name(G_OBJECT_TYPE(object));
}
pub inline fn G_OBJECT_CLASS_TYPE(class: anytype) @TypeOf(G_TYPE_FROM_CLASS(class)) {
    return G_TYPE_FROM_CLASS(class);
}
pub inline fn G_OBJECT_CLASS_NAME(class: anytype) @TypeOf(g_type_name(G_OBJECT_CLASS_TYPE(class))) {
    return g_type_name(G_OBJECT_CLASS_TYPE(class));
}
pub inline fn G_VALUE_HOLDS_OBJECT(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_OBJECT)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_OBJECT);
}
pub const G_TYPE_INITIALLY_UNOWNED = g_initially_unowned_get_type();
pub inline fn G_INITIALLY_UNOWNED(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, G_TYPE_INITIALLY_UNOWNED, GInitiallyUnowned)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, G_TYPE_INITIALLY_UNOWNED, GInitiallyUnowned);
}
pub inline fn G_INITIALLY_UNOWNED_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_INITIALLY_UNOWNED, GInitiallyUnownedClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_INITIALLY_UNOWNED, GInitiallyUnownedClass);
}
pub inline fn G_IS_INITIALLY_UNOWNED(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, G_TYPE_INITIALLY_UNOWNED)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, G_TYPE_INITIALLY_UNOWNED);
}
pub inline fn G_IS_INITIALLY_UNOWNED_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_INITIALLY_UNOWNED)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_INITIALLY_UNOWNED);
}
pub inline fn G_INITIALLY_UNOWNED_GET_CLASS(object: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(object, G_TYPE_INITIALLY_UNOWNED, GInitiallyUnownedClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(object, G_TYPE_INITIALLY_UNOWNED, GInitiallyUnownedClass);
}
pub inline fn G_OBJECT_WARN_INVALID_PROPERTY_ID(object: anytype, property_id: anytype, pspec: anytype) @TypeOf(G_OBJECT_WARN_INVALID_PSPEC(object, "property", property_id, pspec)) {
    return G_OBJECT_WARN_INVALID_PSPEC(object, "property", property_id, pspec);
}
pub const G_TYPE_BINDING_FLAGS = g_binding_flags_get_type();
pub const G_TYPE_BINDING = g_binding_get_type();
pub inline fn G_BINDING(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_BINDING, GBinding)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_BINDING, GBinding);
}
pub inline fn G_IS_BINDING(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_BINDING)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_BINDING);
}
pub const __G_BINDING_GROUP_H__ = "";
pub inline fn G_BINDING_GROUP(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_BINDING_GROUP, GBindingGroup)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_BINDING_GROUP, GBindingGroup);
}
pub inline fn G_IS_BINDING_GROUP(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_BINDING_GROUP)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_BINDING_GROUP);
}
pub const G_TYPE_BINDING_GROUP = g_binding_group_get_type();
pub const __G_ENUMS_H__ = "";
pub inline fn G_TYPE_IS_ENUM(@"type": anytype) @TypeOf(G_TYPE_FUNDAMENTAL(@"type") == G_TYPE_ENUM) {
    return G_TYPE_FUNDAMENTAL(@"type") == G_TYPE_ENUM;
}
pub inline fn G_ENUM_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_ENUM, GEnumClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_ENUM, GEnumClass);
}
pub inline fn G_IS_ENUM_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_ENUM)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_ENUM);
}
pub inline fn G_ENUM_CLASS_TYPE(class: anytype) @TypeOf(G_TYPE_FROM_CLASS(class)) {
    return G_TYPE_FROM_CLASS(class);
}
pub inline fn G_ENUM_CLASS_TYPE_NAME(class: anytype) @TypeOf(g_type_name(G_ENUM_CLASS_TYPE(class))) {
    return g_type_name(G_ENUM_CLASS_TYPE(class));
}
pub inline fn G_TYPE_IS_FLAGS(@"type": anytype) @TypeOf(G_TYPE_FUNDAMENTAL(@"type") == G_TYPE_FLAGS) {
    return G_TYPE_FUNDAMENTAL(@"type") == G_TYPE_FLAGS;
}
pub inline fn G_FLAGS_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_FLAGS, GFlagsClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_FLAGS, GFlagsClass);
}
pub inline fn G_IS_FLAGS_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_FLAGS)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_FLAGS);
}
pub inline fn G_FLAGS_CLASS_TYPE(class: anytype) @TypeOf(G_TYPE_FROM_CLASS(class)) {
    return G_TYPE_FROM_CLASS(class);
}
pub inline fn G_FLAGS_CLASS_TYPE_NAME(class: anytype) @TypeOf(g_type_name(G_FLAGS_CLASS_TYPE(class))) {
    return g_type_name(G_FLAGS_CLASS_TYPE(class));
}
pub inline fn G_VALUE_HOLDS_ENUM(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_ENUM)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_ENUM);
}
pub inline fn G_VALUE_HOLDS_FLAGS(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_FLAGS)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_FLAGS);
}
pub const __GOBJECT_ENUM_TYPES_H__ = "";
pub const G_TYPE_UNICODE_TYPE = g_unicode_type_get_type();
pub const G_TYPE_UNICODE_BREAK_TYPE = g_unicode_break_type_get_type();
pub const G_TYPE_UNICODE_SCRIPT = g_unicode_script_get_type();
pub const G_TYPE_NORMALIZE_MODE = g_normalize_mode_get_type();
pub const __G_PARAMSPECS_H__ = "";
pub const G_TYPE_PARAM_CHAR = g_param_spec_types[@as(c_int, 0)];
pub inline fn G_IS_PARAM_SPEC_CHAR(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_CHAR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_CHAR);
}
pub inline fn G_PARAM_SPEC_CHAR(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_CHAR, GParamSpecChar)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_CHAR, GParamSpecChar);
}
pub const G_TYPE_PARAM_UCHAR = g_param_spec_types[@as(c_int, 1)];
pub inline fn G_IS_PARAM_SPEC_UCHAR(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_UCHAR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_UCHAR);
}
pub inline fn G_PARAM_SPEC_UCHAR(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_UCHAR, GParamSpecUChar)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_UCHAR, GParamSpecUChar);
}
pub const G_TYPE_PARAM_BOOLEAN = g_param_spec_types[@as(c_int, 2)];
pub inline fn G_IS_PARAM_SPEC_BOOLEAN(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_BOOLEAN)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_BOOLEAN);
}
pub inline fn G_PARAM_SPEC_BOOLEAN(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_BOOLEAN, GParamSpecBoolean)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_BOOLEAN, GParamSpecBoolean);
}
pub const G_TYPE_PARAM_INT = g_param_spec_types[@as(c_int, 3)];
pub inline fn G_IS_PARAM_SPEC_INT(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_INT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_INT);
}
pub inline fn G_PARAM_SPEC_INT(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_INT, GParamSpecInt)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_INT, GParamSpecInt);
}
pub const G_TYPE_PARAM_UINT = g_param_spec_types[@as(c_int, 4)];
pub inline fn G_IS_PARAM_SPEC_UINT(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_UINT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_UINT);
}
pub inline fn G_PARAM_SPEC_UINT(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_UINT, GParamSpecUInt)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_UINT, GParamSpecUInt);
}
pub const G_TYPE_PARAM_LONG = g_param_spec_types[@as(c_int, 5)];
pub inline fn G_IS_PARAM_SPEC_LONG(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_LONG)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_LONG);
}
pub inline fn G_PARAM_SPEC_LONG(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_LONG, GParamSpecLong)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_LONG, GParamSpecLong);
}
pub const G_TYPE_PARAM_ULONG = g_param_spec_types[@as(c_int, 6)];
pub inline fn G_IS_PARAM_SPEC_ULONG(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_ULONG)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_ULONG);
}
pub inline fn G_PARAM_SPEC_ULONG(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_ULONG, GParamSpecULong)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_ULONG, GParamSpecULong);
}
pub const G_TYPE_PARAM_INT64 = g_param_spec_types[@as(c_int, 7)];
pub inline fn G_IS_PARAM_SPEC_INT64(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_INT64)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_INT64);
}
pub inline fn G_PARAM_SPEC_INT64(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_INT64, GParamSpecInt64)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_INT64, GParamSpecInt64);
}
pub const G_TYPE_PARAM_UINT64 = g_param_spec_types[@as(c_int, 8)];
pub inline fn G_IS_PARAM_SPEC_UINT64(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_UINT64)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_UINT64);
}
pub inline fn G_PARAM_SPEC_UINT64(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_UINT64, GParamSpecUInt64)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_UINT64, GParamSpecUInt64);
}
pub const G_TYPE_PARAM_UNICHAR = g_param_spec_types[@as(c_int, 9)];
pub inline fn G_PARAM_SPEC_UNICHAR(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_UNICHAR, GParamSpecUnichar)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_UNICHAR, GParamSpecUnichar);
}
pub inline fn G_IS_PARAM_SPEC_UNICHAR(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_UNICHAR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_UNICHAR);
}
pub const G_TYPE_PARAM_ENUM = g_param_spec_types[@as(c_int, 10)];
pub inline fn G_IS_PARAM_SPEC_ENUM(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_ENUM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_ENUM);
}
pub inline fn G_PARAM_SPEC_ENUM(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_ENUM, GParamSpecEnum)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_ENUM, GParamSpecEnum);
}
pub const G_TYPE_PARAM_FLAGS = g_param_spec_types[@as(c_int, 11)];
pub inline fn G_IS_PARAM_SPEC_FLAGS(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_FLAGS)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_FLAGS);
}
pub inline fn G_PARAM_SPEC_FLAGS(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_FLAGS, GParamSpecFlags)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_FLAGS, GParamSpecFlags);
}
pub const G_TYPE_PARAM_FLOAT = g_param_spec_types[@as(c_int, 12)];
pub inline fn G_IS_PARAM_SPEC_FLOAT(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_FLOAT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_FLOAT);
}
pub inline fn G_PARAM_SPEC_FLOAT(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_FLOAT, GParamSpecFloat)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_FLOAT, GParamSpecFloat);
}
pub const G_TYPE_PARAM_DOUBLE = g_param_spec_types[@as(c_int, 13)];
pub inline fn G_IS_PARAM_SPEC_DOUBLE(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_DOUBLE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_DOUBLE);
}
pub inline fn G_PARAM_SPEC_DOUBLE(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_DOUBLE, GParamSpecDouble)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_DOUBLE, GParamSpecDouble);
}
pub const G_TYPE_PARAM_STRING = g_param_spec_types[@as(c_int, 14)];
pub inline fn G_IS_PARAM_SPEC_STRING(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_STRING)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_STRING);
}
pub inline fn G_PARAM_SPEC_STRING(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_STRING, GParamSpecString)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_STRING, GParamSpecString);
}
pub const G_TYPE_PARAM_PARAM = g_param_spec_types[@as(c_int, 15)];
pub inline fn G_IS_PARAM_SPEC_PARAM(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_PARAM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_PARAM);
}
pub inline fn G_PARAM_SPEC_PARAM(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_PARAM, GParamSpecParam)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_PARAM, GParamSpecParam);
}
pub const G_TYPE_PARAM_BOXED = g_param_spec_types[@as(c_int, 16)];
pub inline fn G_IS_PARAM_SPEC_BOXED(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_BOXED)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_BOXED);
}
pub inline fn G_PARAM_SPEC_BOXED(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_BOXED, GParamSpecBoxed)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_BOXED, GParamSpecBoxed);
}
pub const G_TYPE_PARAM_POINTER = g_param_spec_types[@as(c_int, 17)];
pub inline fn G_IS_PARAM_SPEC_POINTER(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_POINTER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_POINTER);
}
pub inline fn G_PARAM_SPEC_POINTER(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_POINTER, GParamSpecPointer)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_POINTER, GParamSpecPointer);
}
pub const G_TYPE_PARAM_VALUE_ARRAY = g_param_spec_types[@as(c_int, 18)] ++ GLIB_DEPRECATED_MACRO_IN_2_32;
pub inline fn G_IS_PARAM_SPEC_VALUE_ARRAY(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_VALUE_ARRAY) ++ GLIB_DEPRECATED_MACRO_IN_2_32) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_VALUE_ARRAY) ++ GLIB_DEPRECATED_MACRO_IN_2_32;
}
pub inline fn G_PARAM_SPEC_VALUE_ARRAY(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_VALUE_ARRAY, GParamSpecValueArray) ++ GLIB_DEPRECATED_MACRO_IN_2_32) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_VALUE_ARRAY, GParamSpecValueArray) ++ GLIB_DEPRECATED_MACRO_IN_2_32;
}
pub const G_TYPE_PARAM_OBJECT = g_param_spec_types[@as(c_int, 19)];
pub inline fn G_IS_PARAM_SPEC_OBJECT(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_OBJECT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_OBJECT);
}
pub inline fn G_PARAM_SPEC_OBJECT(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_OBJECT, GParamSpecObject)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_OBJECT, GParamSpecObject);
}
pub const G_TYPE_PARAM_OVERRIDE = g_param_spec_types[@as(c_int, 20)];
pub inline fn G_IS_PARAM_SPEC_OVERRIDE(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_OVERRIDE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_OVERRIDE);
}
pub inline fn G_PARAM_SPEC_OVERRIDE(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_OVERRIDE, GParamSpecOverride)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_OVERRIDE, GParamSpecOverride);
}
pub const G_TYPE_PARAM_GTYPE = g_param_spec_types[@as(c_int, 21)];
pub inline fn G_IS_PARAM_SPEC_GTYPE(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_GTYPE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_GTYPE);
}
pub inline fn G_PARAM_SPEC_GTYPE(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_GTYPE, GParamSpecGType)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_GTYPE, GParamSpecGType);
}
pub const G_TYPE_PARAM_VARIANT = g_param_spec_types[@as(c_int, 22)];
pub inline fn G_IS_PARAM_SPEC_VARIANT(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_VARIANT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_VARIANT);
}
pub inline fn G_PARAM_SPEC_VARIANT(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_VARIANT, GParamSpecVariant)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_VARIANT, GParamSpecVariant);
}
pub const GOBJECT_VAR = _GLIB_EXTERN;
pub const __G_SIGNAL_GROUP_H__ = "";
pub inline fn G_SIGNAL_GROUP(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_SIGNAL_GROUP, GSignalGroup)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_SIGNAL_GROUP, GSignalGroup);
}
pub inline fn G_IS_SIGNAL_GROUP(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_SIGNAL_GROUP)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_SIGNAL_GROUP);
}
pub const G_TYPE_SIGNAL_GROUP = g_signal_group_get_type();
pub const __G_SOURCECLOSURE_H__ = "";
pub const __G_TYPE_MODULE_H__ = "";
pub const G_TYPE_TYPE_MODULE = g_type_module_get_type();
pub inline fn G_TYPE_MODULE(module: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(module, G_TYPE_TYPE_MODULE, GTypeModule)) {
    return G_TYPE_CHECK_INSTANCE_CAST(module, G_TYPE_TYPE_MODULE, GTypeModule);
}
pub inline fn G_TYPE_MODULE_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_TYPE_MODULE, GTypeModuleClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_TYPE_MODULE, GTypeModuleClass);
}
pub inline fn G_IS_TYPE_MODULE(module: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(module, G_TYPE_TYPE_MODULE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(module, G_TYPE_TYPE_MODULE);
}
pub inline fn G_IS_TYPE_MODULE_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_TYPE_MODULE)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_TYPE_MODULE);
}
pub inline fn G_TYPE_MODULE_GET_CLASS(module: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(module, G_TYPE_TYPE_MODULE, GTypeModuleClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(module, G_TYPE_TYPE_MODULE, GTypeModuleClass);
}
pub const __G_TYPE_PLUGIN_H__ = "";
pub const G_TYPE_TYPE_PLUGIN = g_type_plugin_get_type();
pub inline fn G_TYPE_PLUGIN(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_TYPE_PLUGIN, GTypePlugin)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_TYPE_PLUGIN, GTypePlugin);
}
pub inline fn G_TYPE_PLUGIN_CLASS(vtable: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(vtable, G_TYPE_TYPE_PLUGIN, GTypePluginClass)) {
    return G_TYPE_CHECK_CLASS_CAST(vtable, G_TYPE_TYPE_PLUGIN, GTypePluginClass);
}
pub inline fn G_IS_TYPE_PLUGIN(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_TYPE_PLUGIN)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_TYPE_PLUGIN);
}
pub inline fn G_IS_TYPE_PLUGIN_CLASS(vtable: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(vtable, G_TYPE_TYPE_PLUGIN)) {
    return G_TYPE_CHECK_CLASS_TYPE(vtable, G_TYPE_TYPE_PLUGIN);
}
pub inline fn G_TYPE_PLUGIN_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_TYPE_PLUGIN, GTypePluginClass)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_TYPE_PLUGIN, GTypePluginClass);
}
pub const __G_VALUE_ARRAY_H__ = "";
pub const G_TYPE_VALUE_ARRAY = g_value_array_get_type() ++ GLIB_DEPRECATED_MACRO_IN_2_32_FOR(G_TYPE_ARRAY);
pub const __G_VALUETYPES_H__ = "";
pub inline fn G_VALUE_HOLDS_CHAR(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_CHAR)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_CHAR);
}
pub inline fn G_VALUE_HOLDS_UCHAR(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_UCHAR)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_UCHAR);
}
pub inline fn G_VALUE_HOLDS_BOOLEAN(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_BOOLEAN)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_BOOLEAN);
}
pub inline fn G_VALUE_HOLDS_INT(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_INT)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_INT);
}
pub inline fn G_VALUE_HOLDS_UINT(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_UINT)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_UINT);
}
pub inline fn G_VALUE_HOLDS_LONG(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_LONG)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_LONG);
}
pub inline fn G_VALUE_HOLDS_ULONG(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_ULONG)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_ULONG);
}
pub inline fn G_VALUE_HOLDS_INT64(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_INT64)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_INT64);
}
pub inline fn G_VALUE_HOLDS_UINT64(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_UINT64)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_UINT64);
}
pub inline fn G_VALUE_HOLDS_FLOAT(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_FLOAT)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_FLOAT);
}
pub inline fn G_VALUE_HOLDS_DOUBLE(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_DOUBLE)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_DOUBLE);
}
pub inline fn G_VALUE_HOLDS_STRING(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_STRING)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_STRING);
}
pub inline fn G_VALUE_IS_INTERNED_STRING(value: anytype) @TypeOf((G_VALUE_HOLDS_STRING(value) != 0) and ((value.*.data[@as(c_int, 1)].v_uint & G_VALUE_INTERNED_STRING) != 0) ++ GLIB_AVAILABLE_MACRO_IN_2_66) {
    return (G_VALUE_HOLDS_STRING(value) != 0) and ((value.*.data[@as(c_int, 1)].v_uint & G_VALUE_INTERNED_STRING) != 0) ++ GLIB_AVAILABLE_MACRO_IN_2_66;
}
pub inline fn G_VALUE_HOLDS_POINTER(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_POINTER)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_POINTER);
}
pub const G_TYPE_GTYPE = g_gtype_get_type();
pub inline fn G_VALUE_HOLDS_GTYPE(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_GTYPE)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_GTYPE);
}
pub inline fn G_VALUE_HOLDS_VARIANT(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_VARIANT)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_VARIANT);
}
pub const __GST_CONFIG_H__ = "";
pub const GST_PADDING = @as(c_int, 4);
pub const GST_PADDING_LARGE = @as(c_int, 20);
pub const GST_DISABLE_CAST_CHECKS = @as(c_int, 0);
pub const GST_DISABLE_GLIB_ASSERTS = @as(c_int, 0);
pub const GST_DISABLE_GLIB_CHECKS = @as(c_int, 0);
pub const GST_HAVE_UNALIGNED_ACCESS = @as(c_int, 0);
pub const GST_API = GST_API_IMPORT;
pub const GST_DEPRECATED = GST_API;
pub inline fn GST_DEPRECATED_FOR(f: anytype) @TypeOf(GST_API) {
    _ = f;
    return GST_API;
}
pub const GST_TYPE_ALLOCATOR_FLAGS = gst_allocator_flags_get_type();
pub const GST_TYPE_BIN_FLAGS = gst_bin_flags_get_type();
pub const GST_TYPE_BUFFER_FLAGS = gst_buffer_flags_get_type();
pub const GST_TYPE_BUFFER_COPY_FLAGS = gst_buffer_copy_flags_get_type();
pub const GST_TYPE_BUFFER_POOL_ACQUIRE_FLAGS = gst_buffer_pool_acquire_flags_get_type();
pub const GST_TYPE_BUS_FLAGS = gst_bus_flags_get_type();
pub const GST_TYPE_BUS_SYNC_REPLY = gst_bus_sync_reply_get_type();
pub const GST_TYPE_CAPS_FLAGS = gst_caps_flags_get_type();
pub const GST_TYPE_CAPS_INTERSECT_MODE = gst_caps_intersect_mode_get_type();
pub const GST_TYPE_CLOCK_RETURN = gst_clock_return_get_type();
pub const GST_TYPE_CLOCK_ENTRY_TYPE = gst_clock_entry_type_get_type();
pub const GST_TYPE_CLOCK_FLAGS = gst_clock_flags_get_type();
pub const GST_TYPE_DEBUG_GRAPH_DETAILS = gst_debug_graph_details_get_type();
pub const GST_TYPE_STATE = gst_state_get_type();
pub const GST_TYPE_STATE_CHANGE_RETURN = gst_state_change_return_get_type();
pub const GST_TYPE_STATE_CHANGE = gst_state_change_get_type();
pub const GST_TYPE_ELEMENT_FLAGS = gst_element_flags_get_type();
pub const GST_TYPE_CORE_ERROR = gst_core_error_get_type();
pub const GST_TYPE_LIBRARY_ERROR = gst_library_error_get_type();
pub const GST_TYPE_RESOURCE_ERROR = gst_resource_error_get_type();
pub const GST_TYPE_STREAM_ERROR = gst_stream_error_get_type();
pub const GST_TYPE_EVENT_TYPE_FLAGS = gst_event_type_flags_get_type();
pub const GST_TYPE_EVENT_TYPE = gst_event_type_get_type();
pub const GST_TYPE_STREAM_FLAGS = gst_stream_flags_get_type();
pub const GST_TYPE_QOS_TYPE = gst_qos_type_get_type();
pub const GST_TYPE_GAP_FLAGS = gst_gap_flags_get_type();
pub const GST_TYPE_FORMAT = gst_format_get_type();
pub const GST_TYPE_DEBUG_LEVEL = gst_debug_level_get_type();
pub const GST_TYPE_DEBUG_COLOR_FLAGS = gst_debug_color_flags_get_type();
pub const GST_TYPE_STACK_TRACE_FLAGS = gst_stack_trace_flags_get_type();
pub const GST_TYPE_DEBUG_COLOR_MODE = gst_debug_color_mode_get_type();
pub const GST_TYPE_ITERATOR_RESULT = gst_iterator_result_get_type();
pub const GST_TYPE_ITERATOR_ITEM = gst_iterator_item_get_type();
pub const GST_TYPE_MEMORY_FLAGS = gst_memory_flags_get_type();
pub const GST_TYPE_MAP_FLAGS = gst_map_flags_get_type();
pub const GST_TYPE_MESSAGE_TYPE = gst_message_type_get_type();
pub const GST_TYPE_STRUCTURE_CHANGE_TYPE = gst_structure_change_type_get_type();
pub const GST_TYPE_STREAM_STATUS_TYPE = gst_stream_status_type_get_type();
pub const GST_TYPE_PROGRESS_TYPE = gst_progress_type_get_type();
pub const GST_TYPE_META_FLAGS = gst_meta_flags_get_type();
pub const GST_TYPE_MINI_OBJECT_FLAGS = gst_mini_object_flags_get_type();
pub const GST_TYPE_LOCK_FLAGS = gst_lock_flags_get_type();
pub const GST_TYPE_OBJECT_FLAGS = gst_object_flags_get_type();
pub const GST_TYPE_PAD_DIRECTION = gst_pad_direction_get_type();
pub const GST_TYPE_PAD_MODE = gst_pad_mode_get_type();
pub const GST_TYPE_PAD_LINK_RETURN = gst_pad_link_return_get_type();
pub const GST_TYPE_FLOW_RETURN = gst_flow_return_get_type();
pub const GST_TYPE_PAD_LINK_CHECK = gst_pad_link_check_get_type();
pub const GST_TYPE_PAD_PROBE_TYPE = gst_pad_probe_type_get_type();
pub const GST_TYPE_PAD_PROBE_RETURN = gst_pad_probe_return_get_type();
pub const GST_TYPE_PAD_FLAGS = gst_pad_flags_get_type();
pub const GST_TYPE_PAD_PRESENCE = gst_pad_presence_get_type();
pub const GST_TYPE_PAD_TEMPLATE_FLAGS = gst_pad_template_flags_get_type();
pub const GST_TYPE_PARSE_ERROR = gst_parse_error_get_type();
pub const GST_TYPE_PARSE_FLAGS = gst_parse_flags_get_type();
pub const GST_TYPE_PIPELINE_FLAGS = gst_pipeline_flags_get_type();
pub const GST_TYPE_PLUGIN_ERROR = gst_plugin_error_get_type();
pub const GST_TYPE_PLUGIN_FLAGS = gst_plugin_flags_get_type();
pub const GST_TYPE_PLUGIN_DEPENDENCY_FLAGS = gst_plugin_dependency_flags_get_type();
pub const GST_TYPE_RANK = gst_rank_get_type();
pub const GST_TYPE_PROMISE_RESULT = gst_promise_result_get_type();
pub const GST_TYPE_QUERY_TYPE_FLAGS = gst_query_type_flags_get_type();
pub const GST_TYPE_QUERY_TYPE = gst_query_type_get_type();
pub const GST_TYPE_BUFFERING_MODE = gst_buffering_mode_get_type();
pub const GST_TYPE_SCHEDULING_FLAGS = gst_scheduling_flags_get_type();
pub const GST_TYPE_SEEK_TYPE = gst_seek_type_get_type();
pub const GST_TYPE_SEEK_FLAGS = gst_seek_flags_get_type();
pub const GST_TYPE_SEGMENT_FLAGS = gst_segment_flags_get_type();
pub const GST_TYPE_STREAM_TYPE = gst_stream_type_get_type();
pub const GST_TYPE_SERIALIZE_FLAGS = gst_serialize_flags_get_type();
pub const GST_TYPE_CLOCK_TYPE = gst_clock_type_get_type();
pub const GST_TYPE_TAG_MERGE_MODE = gst_tag_merge_mode_get_type();
pub const GST_TYPE_TAG_FLAG = gst_tag_flag_get_type();
pub const GST_TYPE_TAG_SCOPE = gst_tag_scope_get_type();
pub const GST_TYPE_TASK_STATE = gst_task_state_get_type();
pub const GST_TYPE_TOC_SCOPE = gst_toc_scope_get_type();
pub const GST_TYPE_TOC_ENTRY_TYPE = gst_toc_entry_type_get_type();
pub const GST_TYPE_TOC_LOOP_TYPE = gst_toc_loop_type_get_type();
pub const GST_TYPE_TRACER_VALUE_SCOPE = gst_tracer_value_scope_get_type();
pub const GST_TYPE_TRACER_VALUE_FLAGS = gst_tracer_value_flags_get_type();
pub const GST_TYPE_TYPE_FIND_PROBABILITY = gst_type_find_probability_get_type();
pub const GST_TYPE_URI_ERROR = gst_uri_error_get_type();
pub const GST_TYPE_URI_TYPE = gst_uri_type_get_type();
pub const GST_TYPE_SEARCH_MODE = gst_search_mode_get_type();
pub const GST_TYPE_PLUGIN_API_FLAGS = gst_plugin_api_flags_get_type();
pub const __GST_VERSION_H__ = "";
pub const GST_VERSION_MAJOR = @as(c_int, 1);
pub const GST_VERSION_MINOR = @as(c_int, 20);
pub const GST_VERSION_MICRO = @as(c_int, 3);
pub const GST_VERSION_NANO = @as(c_int, 0);
pub inline fn GST_CHECK_VERSION(major: anytype, minor: anytype, micro: anytype) @TypeOf((((GST_VERSION_MAJOR > major) or ((GST_VERSION_MAJOR == major) and (GST_VERSION_MINOR > minor))) or (((GST_VERSION_MAJOR == major) and (GST_VERSION_MINOR == minor)) and (GST_VERSION_MICRO >= micro))) or ((((GST_VERSION_MAJOR == major) and (GST_VERSION_MINOR == minor)) and ((GST_VERSION_MICRO + @as(c_int, 1)) == micro)) and (GST_VERSION_NANO > @as(c_int, 0)))) {
    return (((GST_VERSION_MAJOR > major) or ((GST_VERSION_MAJOR == major) and (GST_VERSION_MINOR > minor))) or (((GST_VERSION_MAJOR == major) and (GST_VERSION_MINOR == minor)) and (GST_VERSION_MICRO >= micro))) or ((((GST_VERSION_MAJOR == major) and (GST_VERSION_MINOR == minor)) and ((GST_VERSION_MICRO + @as(c_int, 1)) == micro)) and (GST_VERSION_NANO > @as(c_int, 0)));
}
pub const __GST_ATOMIC_QUEUE_H__ = "";
pub const GST_TYPE_ATOMIC_QUEUE = gst_atomic_queue_get_type();
pub const __GST_BIN_H__ = "";
pub const __GST_ELEMENT_H__ = "";
pub const GST_TYPE_ELEMENT = gst_element_get_type();
pub inline fn GST_IS_ELEMENT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_ELEMENT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_ELEMENT);
}
pub inline fn GST_IS_ELEMENT_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_ELEMENT)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_ELEMENT);
}
pub inline fn GST_ELEMENT_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_ELEMENT, GstElementClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_ELEMENT, GstElementClass);
}
pub inline fn GST_ELEMENT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_ELEMENT, GstElement)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_ELEMENT, GstElement);
}
pub inline fn GST_ELEMENT_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_ELEMENT, GstElementClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_ELEMENT, GstElementClass);
}
pub inline fn GST_ELEMENT_CAST(obj: anytype) [*c]GstElement {
    return @import("std").zig.c_translation.cast([*c]GstElement, obj);
}
pub const __GST_OBJECT_H__ = "";
pub const GST_TYPE_OBJECT = gst_object_get_type();
pub inline fn GST_IS_OBJECT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_OBJECT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_OBJECT);
}
pub inline fn GST_IS_OBJECT_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_OBJECT)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_OBJECT);
}
pub inline fn GST_OBJECT_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_OBJECT, GstObjectClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_OBJECT, GstObjectClass);
}
pub inline fn GST_OBJECT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_OBJECT, GstObject)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_OBJECT, GstObject);
}
pub inline fn GST_OBJECT_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_OBJECT, GstObjectClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_OBJECT, GstObjectClass);
}
pub inline fn GST_OBJECT_CAST(obj: anytype) [*c]GstObject {
    return @import("std").zig.c_translation.cast([*c]GstObject, obj);
}
pub inline fn GST_OBJECT_CLASS_CAST(klass: anytype) [*c]GstObjectClass {
    return @import("std").zig.c_translation.cast([*c]GstObjectClass, klass);
}
pub inline fn GST_OBJECT_REFCOUNT(obj: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]GObject, obj).*.ref_count) {
    return @import("std").zig.c_translation.cast([*c]GObject, obj).*.ref_count;
}
pub inline fn GST_OBJECT_REFCOUNT_VALUE(obj: anytype) @TypeOf(g_atomic_int_get(@import("std").zig.c_translation.cast([*c]gint, &GST_OBJECT_REFCOUNT(obj)))) {
    return g_atomic_int_get(@import("std").zig.c_translation.cast([*c]gint, &GST_OBJECT_REFCOUNT(obj)));
}
pub inline fn GST_OBJECT_GET_LOCK(obj: anytype) @TypeOf(&GST_OBJECT_CAST(obj).*.lock) {
    return &GST_OBJECT_CAST(obj).*.lock;
}
pub inline fn GST_OBJECT_LOCK(obj: anytype) @TypeOf(g_mutex_lock(GST_OBJECT_GET_LOCK(obj))) {
    return g_mutex_lock(GST_OBJECT_GET_LOCK(obj));
}
pub inline fn GST_OBJECT_TRYLOCK(obj: anytype) @TypeOf(g_mutex_trylock(GST_OBJECT_GET_LOCK(obj))) {
    return g_mutex_trylock(GST_OBJECT_GET_LOCK(obj));
}
pub inline fn GST_OBJECT_UNLOCK(obj: anytype) @TypeOf(g_mutex_unlock(GST_OBJECT_GET_LOCK(obj))) {
    return g_mutex_unlock(GST_OBJECT_GET_LOCK(obj));
}
pub inline fn GST_OBJECT_NAME(obj: anytype) @TypeOf(GST_OBJECT_CAST(obj).*.name) {
    return GST_OBJECT_CAST(obj).*.name;
}
pub inline fn GST_OBJECT_PARENT(obj: anytype) @TypeOf(GST_OBJECT_CAST(obj).*.parent) {
    return GST_OBJECT_CAST(obj).*.parent;
}
pub inline fn GST_OBJECT_FLAGS(obj: anytype) @TypeOf(GST_OBJECT_CAST(obj).*.flags) {
    return GST_OBJECT_CAST(obj).*.flags;
}
pub inline fn GST_OBJECT_FLAG_IS_SET(obj: anytype, flag: anytype) @TypeOf((GST_OBJECT_FLAGS(obj) & flag) == flag) {
    return (GST_OBJECT_FLAGS(obj) & flag) == flag;
}
pub const __GST_CONTROL_BINDING_H__ = "";
pub const GST_TYPE_CONTROL_BINDING = gst_control_binding_get_type();
pub inline fn GST_CONTROL_BINDING(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_CONTROL_BINDING, GstControlBinding)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_CONTROL_BINDING, GstControlBinding);
}
pub inline fn GST_CONTROL_BINDING_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_CONTROL_BINDING, GstControlBindingClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_CONTROL_BINDING, GstControlBindingClass);
}
pub inline fn GST_IS_CONTROL_BINDING(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_CONTROL_BINDING)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_CONTROL_BINDING);
}
pub inline fn GST_IS_CONTROL_BINDING_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_CONTROL_BINDING)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_CONTROL_BINDING);
}
pub const __GST_CONTROL_SOURCE_H__ = "";
pub const __GST_CLOCK_H__ = "";
pub const GST_TYPE_CLOCK = gst_clock_get_type();
pub inline fn GST_CLOCK(clock_1: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(clock_1, GST_TYPE_CLOCK, GstClock)) {
    return G_TYPE_CHECK_INSTANCE_CAST(clock_1, GST_TYPE_CLOCK, GstClock);
}
pub inline fn GST_IS_CLOCK(clock_1: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(clock_1, GST_TYPE_CLOCK)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(clock_1, GST_TYPE_CLOCK);
}
pub inline fn GST_CLOCK_CLASS(cclass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(cclass, GST_TYPE_CLOCK, GstClockClass)) {
    return G_TYPE_CHECK_CLASS_CAST(cclass, GST_TYPE_CLOCK, GstClockClass);
}
pub inline fn GST_IS_CLOCK_CLASS(cclass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(cclass, GST_TYPE_CLOCK)) {
    return G_TYPE_CHECK_CLASS_TYPE(cclass, GST_TYPE_CLOCK);
}
pub inline fn GST_CLOCK_GET_CLASS(clock_1: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(clock_1, GST_TYPE_CLOCK, GstClockClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(clock_1, GST_TYPE_CLOCK, GstClockClass);
}
pub inline fn GST_CLOCK_CAST(clock_1: anytype) [*c]GstClock {
    return @import("std").zig.c_translation.cast([*c]GstClock, clock_1);
}
pub const GST_TYPE_CLOCK_TIME = G_TYPE_UINT64;
pub const GST_CLOCK_TIME_NONE = @import("std").zig.c_translation.cast(GstClockTime, -@as(c_int, 1));
pub inline fn GST_CLOCK_TIME_IS_VALID(time_1: anytype) @TypeOf(@import("std").zig.c_translation.cast(GstClockTime, time_1) != GST_CLOCK_TIME_NONE) {
    return @import("std").zig.c_translation.cast(GstClockTime, time_1) != GST_CLOCK_TIME_NONE;
}
pub const GST_CLOCK_STIME_NONE = @import("std").zig.c_translation.cast(GstClockTimeDiff, G_MININT64);
pub inline fn GST_CLOCK_STIME_IS_VALID(time_1: anytype) @TypeOf(@import("std").zig.c_translation.cast(GstClockTimeDiff, time_1) != GST_CLOCK_STIME_NONE) {
    return @import("std").zig.c_translation.cast(GstClockTimeDiff, time_1) != GST_CLOCK_STIME_NONE;
}
pub const GST_SECOND = @import("std").zig.c_translation.cast(GstClockTimeDiff, G_USEC_PER_SEC * G_GINT64_CONSTANT(@as(c_int, 1000)));
pub const GST_MSECOND = @import("std").zig.c_translation.cast(GstClockTimeDiff, GST_SECOND / G_GINT64_CONSTANT(@as(c_int, 1000)));
pub const GST_USECOND = @import("std").zig.c_translation.cast(GstClockTimeDiff, GST_SECOND / G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_int, 1000000, .decimal)));
pub const GST_NSECOND = @import("std").zig.c_translation.cast(GstClockTimeDiff, GST_SECOND / G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_int, 1000000000, .decimal)));
pub inline fn GST_TIME_AS_SECONDS(time_1: anytype) @TypeOf(time_1 / GST_SECOND) {
    return time_1 / GST_SECOND;
}
pub inline fn GST_TIME_AS_MSECONDS(time_1: anytype) @TypeOf(time_1 / G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_int, 1000000, .decimal))) {
    return time_1 / G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_int, 1000000, .decimal));
}
pub inline fn GST_TIME_AS_USECONDS(time_1: anytype) @TypeOf(time_1 / G_GINT64_CONSTANT(@as(c_int, 1000))) {
    return time_1 / G_GINT64_CONSTANT(@as(c_int, 1000));
}
pub inline fn GST_TIME_AS_NSECONDS(time_1: anytype) @TypeOf(time_1) {
    return time_1;
}
pub inline fn GST_CLOCK_DIFF(s: anytype, e: anytype) GstClockTimeDiff {
    return @import("std").zig.c_translation.cast(GstClockTimeDiff, e - s);
}
pub inline fn GST_TIMEVAL_TO_TIME(tv: anytype) GstClockTime {
    return @import("std").zig.c_translation.cast(GstClockTime, (tv.tv_sec * GST_SECOND) + (tv.tv_usec * GST_USECOND));
}
pub inline fn GST_TIMESPEC_TO_TIME(ts: anytype) GstClockTime {
    return @import("std").zig.c_translation.cast(GstClockTime, (ts.tv_sec * GST_SECOND) + (ts.tv_nsec * GST_NSECOND));
}
pub const GST_TIME_FORMAT = "u:%02u:%02u.%09u";
pub inline fn GST_TIME_ARGS(t: anytype) @TypeOf(if (GST_CLOCK_TIME_IS_VALID(t)) @import("std").zig.c_translation.cast(guint, @import("std").zig.c_translation.cast(GstClockTime, t) % GST_SECOND) else @import("std").zig.c_translation.promoteIntLiteral(c_int, 999999999, .decimal)) {
    return blk: {
        _ = if (GST_CLOCK_TIME_IS_VALID(t)) @import("std").zig.c_translation.cast(guint, @import("std").zig.c_translation.cast(GstClockTime, t) / ((GST_SECOND * @as(c_int, 60)) * @as(c_int, 60))) else @as(c_int, 99);
        _ = if (GST_CLOCK_TIME_IS_VALID(t)) @import("std").zig.c_translation.cast(guint, (@import("std").zig.c_translation.cast(GstClockTime, t) / (GST_SECOND * @as(c_int, 60))) % @as(c_int, 60)) else @as(c_int, 99);
        _ = if (GST_CLOCK_TIME_IS_VALID(t)) @import("std").zig.c_translation.cast(guint, (@import("std").zig.c_translation.cast(GstClockTime, t) / GST_SECOND) % @as(c_int, 60)) else @as(c_int, 99);
        break :blk if (GST_CLOCK_TIME_IS_VALID(t)) @import("std").zig.c_translation.cast(guint, @import("std").zig.c_translation.cast(GstClockTime, t) % GST_SECOND) else @import("std").zig.c_translation.promoteIntLiteral(c_int, 999999999, .decimal);
    };
}
pub const GST_STIME_FORMAT = "c%" ++ GST_TIME_FORMAT;
pub inline fn GST_STIME_ARGS(t: anytype) @TypeOf(if (GST_CLOCK_STIME_IS_VALID(t)) @import("std").zig.c_translation.cast(guint, @import("std").zig.c_translation.cast(GstClockTime, ABS(t)) % GST_SECOND) else @import("std").zig.c_translation.promoteIntLiteral(c_int, 999999999, .decimal)) {
    return blk: {
        _ = if ((t == GST_CLOCK_STIME_NONE) or (t >= @as(c_int, 0))) '+' else '-';
        _ = if (GST_CLOCK_STIME_IS_VALID(t)) @import("std").zig.c_translation.cast(guint, @import("std").zig.c_translation.cast(GstClockTime, ABS(t)) / ((GST_SECOND * @as(c_int, 60)) * @as(c_int, 60))) else @as(c_int, 99);
        _ = if (GST_CLOCK_STIME_IS_VALID(t)) @import("std").zig.c_translation.cast(guint, (@import("std").zig.c_translation.cast(GstClockTime, ABS(t)) / (GST_SECOND * @as(c_int, 60))) % @as(c_int, 60)) else @as(c_int, 99);
        _ = if (GST_CLOCK_STIME_IS_VALID(t)) @import("std").zig.c_translation.cast(guint, (@import("std").zig.c_translation.cast(GstClockTime, ABS(t)) / GST_SECOND) % @as(c_int, 60)) else @as(c_int, 99);
        break :blk if (GST_CLOCK_STIME_IS_VALID(t)) @import("std").zig.c_translation.cast(guint, @import("std").zig.c_translation.cast(GstClockTime, ABS(t)) % GST_SECOND) else @import("std").zig.c_translation.promoteIntLiteral(c_int, 999999999, .decimal);
    };
}
pub inline fn GST_CLOCK_ENTRY(entry: anytype) [*c]GstClockEntry {
    return @import("std").zig.c_translation.cast([*c]GstClockEntry, entry);
}
pub inline fn GST_CLOCK_ENTRY_CLOCK(entry: anytype) @TypeOf(entry.*.clock) {
    return entry.*.clock;
}
pub inline fn GST_CLOCK_ENTRY_TYPE(entry: anytype) @TypeOf(entry.*.type) {
    return entry.*.type;
}
pub inline fn GST_CLOCK_ENTRY_TIME(entry: anytype) @TypeOf(entry.*.time) {
    return entry.*.time;
}
pub inline fn GST_CLOCK_ENTRY_INTERVAL(entry: anytype) @TypeOf(entry.*.interval) {
    return entry.*.interval;
}
pub inline fn GST_CLOCK_ENTRY_STATUS(entry: anytype) @TypeOf(entry.*.status) {
    return entry.*.status;
}
pub inline fn GST_CLOCK_FLAGS(clock_1: anytype) @TypeOf(GST_OBJECT_FLAGS(clock_1)) {
    return GST_OBJECT_FLAGS(clock_1);
}
pub const GST_TYPE_CONTROL_SOURCE = gst_control_source_get_type();
pub inline fn GST_CONTROL_SOURCE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_CONTROL_SOURCE, GstControlSource)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_CONTROL_SOURCE, GstControlSource);
}
pub inline fn GST_CONTROL_SOURCE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_CONTROL_SOURCE, GstControlSourceClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_CONTROL_SOURCE, GstControlSourceClass);
}
pub inline fn GST_IS_CONTROL_SOURCE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_CONTROL_SOURCE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_CONTROL_SOURCE);
}
pub inline fn GST_IS_CONTROL_SOURCE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_CONTROL_SOURCE)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_CONTROL_SOURCE);
}
pub inline fn GST_CONTROL_BINDING_PSPEC(cb: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]GstControlBinding, cb).*.pspec) {
    return @import("std").zig.c_translation.cast([*c]GstControlBinding, cb).*.pspec;
}
pub const __GST_PAD_H__ = "";
pub const __GST_BUFFER_H__ = "";
pub const __GST_MINI_OBJECT_H__ = "";
pub const GST_TYPE_MINI_OBJECT = _gst_mini_object_type;
pub inline fn GST_IS_MINI_OBJECT_TYPE(obj: anytype, @"type": anytype) @TypeOf((obj != 0) and (GST_MINI_OBJECT_TYPE(obj) == @"type")) {
    return (obj != 0) and (GST_MINI_OBJECT_TYPE(obj) == @"type");
}
pub inline fn GST_MINI_OBJECT_CAST(obj: anytype) [*c]GstMiniObject {
    return @import("std").zig.c_translation.cast([*c]GstMiniObject, obj);
}
pub inline fn GST_MINI_OBJECT(obj: anytype) @TypeOf(GST_MINI_OBJECT_CAST(obj)) {
    return GST_MINI_OBJECT_CAST(obj);
}
pub inline fn GST_MINI_OBJECT_TYPE(obj: anytype) @TypeOf(GST_MINI_OBJECT_CAST(obj).*.type) {
    return GST_MINI_OBJECT_CAST(obj).*.type;
}
pub inline fn GST_MINI_OBJECT_FLAGS(obj: anytype) @TypeOf(GST_MINI_OBJECT_CAST(obj).*.flags) {
    return GST_MINI_OBJECT_CAST(obj).*.flags;
}
pub inline fn GST_MINI_OBJECT_FLAG_IS_SET(obj: anytype, flag: anytype) @TypeOf(!!((GST_MINI_OBJECT_FLAGS(obj) & flag) != 0)) {
    return !!((GST_MINI_OBJECT_FLAGS(obj) & flag) != 0);
}
pub inline fn GST_MINI_OBJECT_IS_LOCKABLE(obj: anytype) @TypeOf(GST_MINI_OBJECT_FLAG_IS_SET(obj, GST_MINI_OBJECT_FLAG_LOCKABLE)) {
    return GST_MINI_OBJECT_FLAG_IS_SET(obj, GST_MINI_OBJECT_FLAG_LOCKABLE);
}
pub const GST_LOCK_FLAG_READWRITE = @import("std").zig.c_translation.cast(GstLockFlags, GST_LOCK_FLAG_READ | GST_LOCK_FLAG_WRITE);
pub inline fn GST_MINI_OBJECT_REFCOUNT(obj: anytype) @TypeOf(GST_MINI_OBJECT_CAST(obj).*.refcount) {
    return GST_MINI_OBJECT_CAST(obj).*.refcount;
}
pub inline fn GST_MINI_OBJECT_REFCOUNT_VALUE(obj: anytype) @TypeOf(g_atomic_int_get(&GST_MINI_OBJECT_CAST(obj).*.refcount)) {
    return g_atomic_int_get(&GST_MINI_OBJECT_CAST(obj).*.refcount);
}
pub inline fn GST_DEFINE_MINI_OBJECT_TYPE(TypeName: anytype, type_name: anytype) @TypeOf(G_DEFINE_BOXED_TYPE(TypeName, type_name, @import("std").zig.c_translation.cast(GBoxedCopyFunc, gst_mini_object_ref), @import("std").zig.c_translation.cast(GBoxedFreeFunc, gst_mini_object_unref))) {
    return G_DEFINE_BOXED_TYPE(TypeName, type_name, @import("std").zig.c_translation.cast(GBoxedCopyFunc, gst_mini_object_ref), @import("std").zig.c_translation.cast(GBoxedFreeFunc, gst_mini_object_unref));
}
pub const __GST_ALLOCATOR_H__ = "";
pub const __GST_MEMORY_H__ = "";
pub const GST_TYPE_MEMORY = _gst_memory_type;
pub inline fn GST_MEMORY_CAST(mem: anytype) [*c]GstMemory {
    return @import("std").zig.c_translation.cast([*c]GstMemory, mem);
}
pub inline fn GST_MEMORY_FLAGS(mem: anytype) @TypeOf(GST_MINI_OBJECT_FLAGS(mem)) {
    return GST_MINI_OBJECT_FLAGS(mem);
}
pub inline fn GST_MEMORY_FLAG_IS_SET(mem: anytype, flag: anytype) @TypeOf(GST_MINI_OBJECT_FLAG_IS_SET(mem, flag)) {
    return GST_MINI_OBJECT_FLAG_IS_SET(mem, flag);
}
pub inline fn GST_MEMORY_FLAG_UNSET(mem: anytype, flag: anytype) @TypeOf(GST_MINI_OBJECT_FLAG_UNSET(mem, flag)) {
    return GST_MINI_OBJECT_FLAG_UNSET(mem, flag);
}
pub inline fn GST_MEMORY_IS_READONLY(mem: anytype) @TypeOf(GST_MEMORY_FLAG_IS_SET(mem, GST_MEMORY_FLAG_READONLY)) {
    return GST_MEMORY_FLAG_IS_SET(mem, GST_MEMORY_FLAG_READONLY);
}
pub inline fn GST_MEMORY_IS_NO_SHARE(mem: anytype) @TypeOf(GST_MEMORY_FLAG_IS_SET(mem, GST_MEMORY_FLAG_NO_SHARE)) {
    return GST_MEMORY_FLAG_IS_SET(mem, GST_MEMORY_FLAG_NO_SHARE);
}
pub inline fn GST_MEMORY_IS_ZERO_PREFIXED(mem: anytype) @TypeOf(GST_MEMORY_FLAG_IS_SET(mem, GST_MEMORY_FLAG_ZERO_PREFIXED)) {
    return GST_MEMORY_FLAG_IS_SET(mem, GST_MEMORY_FLAG_ZERO_PREFIXED);
}
pub inline fn GST_MEMORY_IS_ZERO_PADDED(mem: anytype) @TypeOf(GST_MEMORY_FLAG_IS_SET(mem, GST_MEMORY_FLAG_ZERO_PADDED)) {
    return GST_MEMORY_FLAG_IS_SET(mem, GST_MEMORY_FLAG_ZERO_PADDED);
}
pub inline fn GST_MEMORY_IS_PHYSICALLY_CONTIGUOUS(mem: anytype) @TypeOf(GST_MEMORY_FLAG_IS_SET(mem, GST_MEMORY_FLAG_PHYSICALLY_CONTIGUOUS)) {
    return GST_MEMORY_FLAG_IS_SET(mem, GST_MEMORY_FLAG_PHYSICALLY_CONTIGUOUS);
}
pub inline fn GST_MEMORY_IS_NOT_MAPPABLE(mem: anytype) @TypeOf(GST_MEMORY_FLAG_IS_SET(mem, GST_MEMORY_FLAG_NOT_MAPPABLE)) {
    return GST_MEMORY_FLAG_IS_SET(mem, GST_MEMORY_FLAG_NOT_MAPPABLE);
}
pub const GST_MAP_READWRITE = @import("std").zig.c_translation.cast(GstMapFlags, GST_MAP_READ | GST_MAP_WRITE);
pub inline fn gst_memory_lock(m: anytype, f: anytype) @TypeOf(gst_mini_object_lock(GST_MINI_OBJECT_CAST(m), f)) {
    return gst_mini_object_lock(GST_MINI_OBJECT_CAST(m), f);
}
pub inline fn gst_memory_unlock(m: anytype, f: anytype) @TypeOf(gst_mini_object_unlock(GST_MINI_OBJECT_CAST(m), f)) {
    return gst_mini_object_unlock(GST_MINI_OBJECT_CAST(m), f);
}
pub inline fn gst_memory_is_writable(m: anytype) @TypeOf(gst_mini_object_is_writable(GST_MINI_OBJECT_CAST(m))) {
    return gst_mini_object_is_writable(GST_MINI_OBJECT_CAST(m));
}
pub inline fn gst_memory_make_writable(m: anytype) @TypeOf(GST_MEMORY_CAST(gst_mini_object_make_writable(GST_MINI_OBJECT_CAST(m)))) {
    return GST_MEMORY_CAST(gst_mini_object_make_writable(GST_MINI_OBJECT_CAST(m)));
}
pub const GST_TYPE_ALLOCATOR = gst_allocator_get_type();
pub inline fn GST_IS_ALLOCATOR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_ALLOCATOR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_ALLOCATOR);
}
pub inline fn GST_IS_ALLOCATOR_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_ALLOCATOR)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_ALLOCATOR);
}
pub inline fn GST_ALLOCATOR_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_ALLOCATOR, GstAllocatorClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_ALLOCATOR, GstAllocatorClass);
}
pub inline fn GST_ALLOCATOR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_ALLOCATOR, GstAllocator)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_ALLOCATOR, GstAllocator);
}
pub inline fn GST_ALLOCATOR_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_ALLOCATOR, GstAllocatorClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_ALLOCATOR, GstAllocatorClass);
}
pub inline fn GST_ALLOCATOR_CAST(obj: anytype) [*c]GstAllocator {
    return @import("std").zig.c_translation.cast([*c]GstAllocator, obj);
}
pub const GST_TYPE_ALLOCATION_PARAMS = gst_allocation_params_get_type();
pub const GST_ALLOCATOR_SYSMEM = "SystemMemory";
pub const __GST_CAPS_H__ = "";
pub const __GST_STRUCTURE_H__ = "";
pub const __GST_DATE_TIME_H__ = "";
pub const GST_TYPE_DATE_TIME = _gst_date_time_type;
pub const GST_TYPE_STRUCTURE = _gst_structure_type;
pub inline fn GST_IS_STRUCTURE(object: anytype) @TypeOf((object != 0) and (GST_STRUCTURE(object).*.type == GST_TYPE_STRUCTURE)) {
    return (object != 0) and (GST_STRUCTURE(object).*.type == GST_TYPE_STRUCTURE);
}
pub inline fn GST_STRUCTURE_CAST(object: anytype) [*c]GstStructure {
    return @import("std").zig.c_translation.cast([*c]GstStructure, object);
}
pub inline fn GST_STRUCTURE(object: anytype) @TypeOf(GST_STRUCTURE_CAST(object)) {
    return GST_STRUCTURE_CAST(object);
}
pub const __GST_CAPS_FEATURES_H__ = "";
pub const GST_TYPE_CAPS_FEATURES = _gst_caps_features_type;
pub inline fn GST_IS_CAPS_FEATURES(object: anytype) @TypeOf(gst_is_caps_features(object)) {
    return gst_is_caps_features(object);
}
pub inline fn GST_CAPS_FEATURES_CAST(object: anytype) [*c]GstCapsFeatures {
    return @import("std").zig.c_translation.cast([*c]GstCapsFeatures, object);
}
pub inline fn GST_CAPS_FEATURES(object: anytype) @TypeOf(GST_CAPS_FEATURES_CAST(object)) {
    return GST_CAPS_FEATURES_CAST(object);
}
pub const GST_CAPS_FEATURE_MEMORY_SYSTEM_MEMORY = "memory:SystemMemory";
pub const GST_CAPS_FEATURES_ANY = _gst_caps_features_any;
pub const GST_CAPS_FEATURES_MEMORY_SYSTEM_MEMORY = _gst_caps_features_memory_system_memory;
pub const GST_TYPE_CAPS = _gst_caps_type;
pub inline fn GST_IS_CAPS(obj: anytype) @TypeOf(GST_IS_MINI_OBJECT_TYPE(obj, GST_TYPE_CAPS)) {
    return GST_IS_MINI_OBJECT_TYPE(obj, GST_TYPE_CAPS);
}
pub inline fn GST_CAPS_CAST(obj: anytype) [*c]GstCaps {
    return @import("std").zig.c_translation.cast([*c]GstCaps, obj);
}
pub inline fn GST_CAPS(obj: anytype) @TypeOf(GST_CAPS_CAST(obj)) {
    return GST_CAPS_CAST(obj);
}
pub const GST_TYPE_STATIC_CAPS = gst_static_caps_get_type();
pub const GST_CAPS_ANY = _gst_caps_any;
pub const GST_CAPS_NONE = _gst_caps_none;
pub const GST_STATIC_CAPS_ANY = GST_STATIC_CAPS("ANY");
pub const GST_STATIC_CAPS_NONE = GST_STATIC_CAPS("NONE");
pub inline fn GST_CAPS_IS_SIMPLE(caps: anytype) @TypeOf(gst_caps_get_size(caps) == @as(c_int, 1)) {
    return gst_caps_get_size(caps) == @as(c_int, 1);
}
pub inline fn GST_CAPS_FLAGS(caps: anytype) @TypeOf(GST_MINI_OBJECT_FLAGS(caps)) {
    return GST_MINI_OBJECT_FLAGS(caps);
}
pub inline fn GST_CAPS_REFCOUNT(caps: anytype) @TypeOf(GST_MINI_OBJECT_REFCOUNT(caps)) {
    return GST_MINI_OBJECT_REFCOUNT(caps);
}
pub inline fn GST_CAPS_REFCOUNT_VALUE(caps: anytype) @TypeOf(GST_MINI_OBJECT_REFCOUNT_VALUE(caps)) {
    return GST_MINI_OBJECT_REFCOUNT_VALUE(caps);
}
pub inline fn GST_CAPS_FLAG_IS_SET(caps: anytype, flag: anytype) @TypeOf(GST_MINI_OBJECT_FLAG_IS_SET(caps, flag)) {
    return GST_MINI_OBJECT_FLAG_IS_SET(caps, flag);
}
pub inline fn GST_CAPS_FLAG_SET(caps: anytype, flag: anytype) @TypeOf(GST_MINI_OBJECT_FLAG_SET(caps, flag)) {
    return GST_MINI_OBJECT_FLAG_SET(caps, flag);
}
pub inline fn GST_CAPS_FLAG_UNSET(caps: anytype, flag: anytype) @TypeOf(GST_MINI_OBJECT_FLAG_UNSET(caps, flag)) {
    return GST_MINI_OBJECT_FLAG_UNSET(caps, flag);
}
pub inline fn gst_caps_is_writable(caps: anytype) @TypeOf(gst_mini_object_is_writable(GST_MINI_OBJECT_CAST(caps))) {
    return gst_mini_object_is_writable(GST_MINI_OBJECT_CAST(caps));
}
pub inline fn gst_caps_make_writable(caps: anytype) @TypeOf(GST_CAPS_CAST(gst_mini_object_make_writable(GST_MINI_OBJECT_CAST(caps)))) {
    return GST_CAPS_CAST(gst_mini_object_make_writable(GST_MINI_OBJECT_CAST(caps)));
}
pub const __GST_META_H__ = "";
pub inline fn GST_META_CAST(meta: anytype) [*c]GstMeta {
    return @import("std").zig.c_translation.cast([*c]GstMeta, meta);
}
pub inline fn GST_META_FLAGS(meta: anytype) @TypeOf(GST_META_CAST(meta).*.flags) {
    return GST_META_CAST(meta).*.flags;
}
pub inline fn GST_META_FLAG_IS_SET(meta: anytype, flag: anytype) @TypeOf(!!((GST_META_FLAGS(meta) & flag) != 0)) {
    return !!((GST_META_FLAGS(meta) & flag) != 0);
}
pub const GST_META_TAG_MEMORY_STR = "memory";
pub inline fn GST_META_TRANSFORM_IS_COPY(@"type": anytype) @TypeOf(@"type" == _gst_meta_transform_copy) {
    return @"type" == _gst_meta_transform_copy;
}
pub const GST_META_TAG_MEMORY = _gst_meta_tag_memory;
pub const GST_TYPE_BUFFER = _gst_buffer_type;
pub inline fn GST_IS_BUFFER(obj: anytype) @TypeOf(GST_IS_MINI_OBJECT_TYPE(obj, GST_TYPE_BUFFER)) {
    return GST_IS_MINI_OBJECT_TYPE(obj, GST_TYPE_BUFFER);
}
pub inline fn GST_BUFFER_CAST(obj: anytype) [*c]GstBuffer {
    return @import("std").zig.c_translation.cast([*c]GstBuffer, obj);
}
pub inline fn GST_BUFFER(obj: anytype) @TypeOf(GST_BUFFER_CAST(obj)) {
    return GST_BUFFER_CAST(obj);
}
pub inline fn GST_BUFFER_FLAGS(buf: anytype) @TypeOf(GST_MINI_OBJECT_FLAGS(buf)) {
    return GST_MINI_OBJECT_FLAGS(buf);
}
pub inline fn GST_BUFFER_FLAG_IS_SET(buf: anytype, flag: anytype) @TypeOf(GST_MINI_OBJECT_FLAG_IS_SET(buf, flag)) {
    return GST_MINI_OBJECT_FLAG_IS_SET(buf, flag);
}
pub inline fn GST_BUFFER_FLAG_SET(buf: anytype, flag: anytype) @TypeOf(GST_MINI_OBJECT_FLAG_SET(buf, flag)) {
    return GST_MINI_OBJECT_FLAG_SET(buf, flag);
}
pub inline fn GST_BUFFER_FLAG_UNSET(buf: anytype, flag: anytype) @TypeOf(GST_MINI_OBJECT_FLAG_UNSET(buf, flag)) {
    return GST_MINI_OBJECT_FLAG_UNSET(buf, flag);
}
pub inline fn GST_BUFFER_PTS(buf: anytype) @TypeOf(GST_BUFFER_CAST(buf).*.pts) {
    return GST_BUFFER_CAST(buf).*.pts;
}
pub inline fn GST_BUFFER_DTS(buf: anytype) @TypeOf(GST_BUFFER_CAST(buf).*.dts) {
    return GST_BUFFER_CAST(buf).*.dts;
}
pub inline fn GST_BUFFER_DTS_OR_PTS(buf: anytype) @TypeOf(if (GST_BUFFER_DTS_IS_VALID(buf)) GST_BUFFER_DTS(buf) else GST_BUFFER_PTS(buf)) {
    return if (GST_BUFFER_DTS_IS_VALID(buf)) GST_BUFFER_DTS(buf) else GST_BUFFER_PTS(buf);
}
pub inline fn GST_BUFFER_DURATION(buf: anytype) @TypeOf(GST_BUFFER_CAST(buf).*.duration) {
    return GST_BUFFER_CAST(buf).*.duration;
}
pub inline fn GST_BUFFER_OFFSET(buf: anytype) @TypeOf(GST_BUFFER_CAST(buf).*.offset) {
    return GST_BUFFER_CAST(buf).*.offset;
}
pub inline fn GST_BUFFER_OFFSET_END(buf: anytype) @TypeOf(GST_BUFFER_CAST(buf).*.offset_end) {
    return GST_BUFFER_CAST(buf).*.offset_end;
}
pub const GST_BUFFER_OFFSET_NONE = @import("std").zig.c_translation.cast(guint64, -@as(c_int, 1));
pub inline fn GST_BUFFER_DURATION_IS_VALID(buffer: anytype) @TypeOf(GST_CLOCK_TIME_IS_VALID(GST_BUFFER_DURATION(buffer))) {
    return GST_CLOCK_TIME_IS_VALID(GST_BUFFER_DURATION(buffer));
}
pub inline fn GST_BUFFER_PTS_IS_VALID(buffer: anytype) @TypeOf(GST_CLOCK_TIME_IS_VALID(GST_BUFFER_PTS(buffer))) {
    return GST_CLOCK_TIME_IS_VALID(GST_BUFFER_PTS(buffer));
}
pub inline fn GST_BUFFER_DTS_IS_VALID(buffer: anytype) @TypeOf(GST_CLOCK_TIME_IS_VALID(GST_BUFFER_DTS(buffer))) {
    return GST_CLOCK_TIME_IS_VALID(GST_BUFFER_DTS(buffer));
}
pub inline fn GST_BUFFER_OFFSET_IS_VALID(buffer: anytype) @TypeOf(GST_BUFFER_OFFSET(buffer) != GST_BUFFER_OFFSET_NONE) {
    return GST_BUFFER_OFFSET(buffer) != GST_BUFFER_OFFSET_NONE;
}
pub inline fn GST_BUFFER_OFFSET_END_IS_VALID(buffer: anytype) @TypeOf(GST_BUFFER_OFFSET_END(buffer) != GST_BUFFER_OFFSET_NONE) {
    return GST_BUFFER_OFFSET_END(buffer) != GST_BUFFER_OFFSET_NONE;
}
pub inline fn GST_BUFFER_IS_DISCONT(buffer: anytype) @TypeOf(GST_BUFFER_FLAG_IS_SET(buffer, GST_BUFFER_FLAG_DISCONT)) {
    return GST_BUFFER_FLAG_IS_SET(buffer, GST_BUFFER_FLAG_DISCONT);
}
pub const GST_BUFFER_COPY_METADATA = @import("std").zig.c_translation.cast(GstBufferCopyFlags, (GST_BUFFER_COPY_FLAGS | GST_BUFFER_COPY_TIMESTAMPS) | GST_BUFFER_COPY_META);
pub const GST_BUFFER_COPY_ALL = @import("std").zig.c_translation.cast(GstBufferCopyFlags, GST_BUFFER_COPY_METADATA | GST_BUFFER_COPY_MEMORY);
pub inline fn gst_buffer_is_writable(buf: anytype) @TypeOf(gst_mini_object_is_writable(GST_MINI_OBJECT_CAST(buf))) {
    return gst_mini_object_is_writable(GST_MINI_OBJECT_CAST(buf));
}
pub inline fn gst_buffer_make_writable(buf: anytype) @TypeOf(GST_BUFFER_CAST(gst_mini_object_make_writable(GST_MINI_OBJECT_CAST(buf)))) {
    return GST_BUFFER_CAST(gst_mini_object_make_writable(GST_MINI_OBJECT_CAST(buf)));
}
pub inline fn gst_value_set_buffer(v: anytype, b: anytype) @TypeOf(g_value_set_boxed(v, b)) {
    return g_value_set_boxed(v, b);
}
pub inline fn gst_value_take_buffer(v: anytype, b: anytype) @TypeOf(g_value_take_boxed(v, b)) {
    return g_value_take_boxed(v, b);
}
pub inline fn gst_value_get_buffer(v: anytype) @TypeOf(GST_BUFFER_CAST(g_value_get_boxed(v))) {
    return GST_BUFFER_CAST(g_value_get_boxed(v));
}
pub const GST_TYPE_PARENT_BUFFER_META_API_TYPE = GST_PARENT_BUFFER_META_API_TYPE;
pub const GST_PARENT_BUFFER_META_API_TYPE = gst_parent_buffer_meta_api_get_type();
pub inline fn gst_buffer_get_parent_buffer_meta(b: anytype) [*c]GstParentBufferMeta {
    return @import("std").zig.c_translation.cast([*c]GstParentBufferMeta, gst_buffer_get_meta(b, GST_PARENT_BUFFER_META_API_TYPE));
}
pub const GST_PARENT_BUFFER_META_INFO = gst_parent_buffer_meta_get_info();
pub const GST_REFERENCE_TIMESTAMP_META_API_TYPE = gst_reference_timestamp_meta_api_get_type();
pub const GST_REFERENCE_TIMESTAMP_META_INFO = gst_reference_timestamp_meta_get_info();
pub const __GST_BUFFER_LIST_H__ = "";
pub const GST_TYPE_BUFFER_LIST = _gst_buffer_list_type;
pub inline fn GST_IS_BUFFER_LIST(obj: anytype) @TypeOf(GST_IS_MINI_OBJECT_TYPE(obj, GST_TYPE_BUFFER_LIST)) {
    return GST_IS_MINI_OBJECT_TYPE(obj, GST_TYPE_BUFFER_LIST);
}
pub inline fn GST_BUFFER_LIST_CAST(obj: anytype) [*c]GstBufferList {
    return @import("std").zig.c_translation.cast([*c]GstBufferList, obj);
}
pub inline fn GST_BUFFER_LIST(obj: anytype) @TypeOf(GST_BUFFER_LIST_CAST(obj)) {
    return GST_BUFFER_LIST_CAST(obj);
}
pub inline fn gst_buffer_list_is_writable(list: anytype) @TypeOf(gst_mini_object_is_writable(GST_MINI_OBJECT_CAST(list))) {
    return gst_mini_object_is_writable(GST_MINI_OBJECT_CAST(list));
}
pub inline fn gst_buffer_list_make_writable(list: anytype) @TypeOf(GST_BUFFER_LIST_CAST(gst_mini_object_make_writable(GST_MINI_OBJECT_CAST(list)))) {
    return GST_BUFFER_LIST_CAST(gst_mini_object_make_writable(GST_MINI_OBJECT_CAST(list)));
}
pub const __GST_PAD_TEMPLATE_H__ = "";
pub const __GST_EVENT_H__ = "";
pub const GST_EVENT_TYPE_BOTH = @import("std").zig.c_translation.cast(GstEventTypeFlags, GST_EVENT_TYPE_UPSTREAM | GST_EVENT_TYPE_DOWNSTREAM);
pub const GST_EVENT_NUM_SHIFT = @as(c_int, 8);
pub inline fn GST_EVENT_MAKE_TYPE(num: anytype, flags: anytype) @TypeOf((num << GST_EVENT_NUM_SHIFT) | flags) {
    return (num << GST_EVENT_NUM_SHIFT) | flags;
}
pub const __GST_FORMAT_H__ = "";
pub const __GST_ITERATOR_H__ = "";
pub const GST_TYPE_ITERATOR = gst_iterator_get_type();
pub inline fn GST_ITERATOR(it: anytype) [*c]GstIterator {
    return @import("std").zig.c_translation.cast([*c]GstIterator, it);
}
pub inline fn GST_ITERATOR_LOCK(it: anytype) @TypeOf(GST_ITERATOR(it).*.lock) {
    return GST_ITERATOR(it).*.lock;
}
pub inline fn GST_ITERATOR_COOKIE(it: anytype) @TypeOf(GST_ITERATOR(it).*.cookie) {
    return GST_ITERATOR(it).*.cookie;
}
pub inline fn GST_ITERATOR_ORIG_COOKIE(it: anytype) @TypeOf(GST_ITERATOR(it).*.master_cookie) {
    return GST_ITERATOR(it).*.master_cookie;
}
pub const GST_FORMAT_PERCENT_MAX = G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_int, 1000000, .decimal));
pub const GST_FORMAT_PERCENT_SCALE = G_GINT64_CONSTANT(@as(c_int, 10000));
pub const __GST_TAGLIST_H__ = "";
pub const __GST_SAMPLE_H__ = "";
pub const __GST_SEGMENT_H__ = "";
pub const GST_TYPE_SEGMENT = gst_segment_get_type();
pub const GST_SEGMENT_INSTANT_FLAGS = ((GST_SEGMENT_FLAG_TRICKMODE | GST_SEGMENT_FLAG_TRICKMODE_KEY_UNITS) | GST_SEEK_FLAG_TRICKMODE_FORWARD_PREDICTED) | GST_SEGMENT_FLAG_TRICKMODE_NO_AUDIO;
pub const GST_TYPE_SAMPLE = _gst_sample_type;
pub inline fn GST_IS_SAMPLE(obj: anytype) @TypeOf(GST_IS_MINI_OBJECT_TYPE(obj, GST_TYPE_SAMPLE)) {
    return GST_IS_MINI_OBJECT_TYPE(obj, GST_TYPE_SAMPLE);
}
pub inline fn GST_SAMPLE_CAST(obj: anytype) [*c]GstSample {
    return @import("std").zig.c_translation.cast([*c]GstSample, obj);
}
pub inline fn GST_SAMPLE(obj: anytype) @TypeOf(GST_SAMPLE_CAST(obj)) {
    return GST_SAMPLE_CAST(obj);
}
pub inline fn gst_sample_is_writable(sample: anytype) @TypeOf(gst_mini_object_is_writable(GST_MINI_OBJECT_CAST(sample))) {
    return gst_mini_object_is_writable(GST_MINI_OBJECT_CAST(sample));
}
pub inline fn gst_sample_make_writable(sample: anytype) @TypeOf(GST_SAMPLE_CAST(gst_mini_object_make_writable(GST_MINI_OBJECT_CAST(sample)))) {
    return GST_SAMPLE_CAST(gst_mini_object_make_writable(GST_MINI_OBJECT_CAST(sample)));
}
pub inline fn gst_value_set_sample(v: anytype, b: anytype) @TypeOf(g_value_set_boxed(v, b)) {
    return g_value_set_boxed(v, b);
}
pub inline fn gst_value_take_sample(v: anytype, b: anytype) @TypeOf(g_value_take_boxed(v, b)) {
    return g_value_take_boxed(v, b);
}
pub inline fn gst_value_get_sample(v: anytype) @TypeOf(GST_SAMPLE_CAST(g_value_get_boxed(v))) {
    return GST_SAMPLE_CAST(g_value_get_boxed(v));
}
pub inline fn GST_TAG_MODE_IS_VALID(mode: anytype) @TypeOf((mode > GST_TAG_MERGE_UNDEFINED) and (mode < GST_TAG_MERGE_COUNT)) {
    return (mode > GST_TAG_MERGE_UNDEFINED) and (mode < GST_TAG_MERGE_COUNT);
}
pub inline fn GST_TAG_FLAG_IS_VALID(flag: anytype) @TypeOf((flag > GST_TAG_FLAG_UNDEFINED) and (flag < GST_TAG_FLAG_COUNT)) {
    return (flag > GST_TAG_FLAG_UNDEFINED) and (flag < GST_TAG_FLAG_COUNT);
}
pub inline fn GST_TAG_LIST(x: anytype) [*c]GstTagList {
    return @import("std").zig.c_translation.cast([*c]GstTagList, x);
}
pub const GST_TYPE_TAG_LIST = _gst_tag_list_type;
pub inline fn GST_IS_TAG_LIST(obj: anytype) @TypeOf(GST_IS_MINI_OBJECT_TYPE(obj, GST_TYPE_TAG_LIST)) {
    return GST_IS_MINI_OBJECT_TYPE(obj, GST_TYPE_TAG_LIST);
}
pub inline fn gst_tag_list_is_writable(taglist: anytype) @TypeOf(gst_mini_object_is_writable(GST_MINI_OBJECT_CAST(taglist))) {
    return gst_mini_object_is_writable(GST_MINI_OBJECT_CAST(taglist));
}
pub inline fn gst_tag_list_make_writable(taglist: anytype) @TypeOf(GST_TAG_LIST(gst_mini_object_make_writable(GST_MINI_OBJECT_CAST(taglist)))) {
    return GST_TAG_LIST(gst_mini_object_make_writable(GST_MINI_OBJECT_CAST(taglist)));
}
pub const GST_TAG_TITLE = "title";
pub const GST_TAG_TITLE_SORTNAME = "title-sortname";
pub const GST_TAG_ARTIST = "artist";
pub const GST_TAG_ARTIST_SORTNAME = "artist-sortname";
pub const GST_TAG_ALBUM = "album";
pub const GST_TAG_ALBUM_SORTNAME = "album-sortname";
pub const GST_TAG_ALBUM_ARTIST = "album-artist";
pub const GST_TAG_ALBUM_ARTIST_SORTNAME = "album-artist-sortname";
pub const GST_TAG_COMPOSER = "composer";
pub const GST_TAG_CONDUCTOR = "conductor";
pub const GST_TAG_DATE = "date";
pub const GST_TAG_DATE_TIME = "datetime";
pub const GST_TAG_GENRE = "genre";
pub const GST_TAG_COMMENT = "comment";
pub const GST_TAG_EXTENDED_COMMENT = "extended-comment";
pub const GST_TAG_TRACK_NUMBER = "track-number";
pub const GST_TAG_TRACK_COUNT = "track-count";
pub const GST_TAG_ALBUM_VOLUME_NUMBER = "album-disc-number";
pub const GST_TAG_ALBUM_VOLUME_COUNT = "album-disc-count";
pub const GST_TAG_LOCATION = "location";
pub const GST_TAG_HOMEPAGE = "homepage";
pub const GST_TAG_DESCRIPTION = "description";
pub const GST_TAG_VERSION = "version";
pub const GST_TAG_ISRC = "isrc";
pub const GST_TAG_ORGANIZATION = "organization";
pub const GST_TAG_COPYRIGHT = "copyright";
pub const GST_TAG_COPYRIGHT_URI = "copyright-uri";
pub const GST_TAG_ENCODED_BY = "encoded-by";
pub const GST_TAG_CONTACT = "contact";
pub const GST_TAG_LICENSE = "license";
pub const GST_TAG_LICENSE_URI = "license-uri";
pub const GST_TAG_PERFORMER = "performer";
pub const GST_TAG_DURATION = "duration";
pub const GST_TAG_CODEC = "codec";
pub const GST_TAG_VIDEO_CODEC = "video-codec";
pub const GST_TAG_AUDIO_CODEC = "audio-codec";
pub const GST_TAG_SUBTITLE_CODEC = "subtitle-codec";
pub const GST_TAG_CONTAINER_FORMAT = "container-format";
pub const GST_TAG_BITRATE = "bitrate";
pub const GST_TAG_NOMINAL_BITRATE = "nominal-bitrate";
pub const GST_TAG_MINIMUM_BITRATE = "minimum-bitrate";
pub const GST_TAG_MAXIMUM_BITRATE = "maximum-bitrate";
pub const GST_TAG_SERIAL = "serial";
pub const GST_TAG_ENCODER = "encoder";
pub const GST_TAG_ENCODER_VERSION = "encoder-version";
pub const GST_TAG_TRACK_GAIN = "replaygain-track-gain";
pub const GST_TAG_TRACK_PEAK = "replaygain-track-peak";
pub const GST_TAG_ALBUM_GAIN = "replaygain-album-gain";
pub const GST_TAG_ALBUM_PEAK = "replaygain-album-peak";
pub const GST_TAG_REFERENCE_LEVEL = "replaygain-reference-level";
pub const GST_TAG_LANGUAGE_CODE = "language-code";
pub const GST_TAG_LANGUAGE_NAME = "language-name";
pub const GST_TAG_IMAGE = "image";
pub const GST_TAG_PREVIEW_IMAGE = "preview-image";
pub const GST_TAG_ATTACHMENT = "attachment";
pub const GST_TAG_BEATS_PER_MINUTE = "beats-per-minute";
pub const GST_TAG_KEYWORDS = "keywords";
pub const GST_TAG_GEO_LOCATION_NAME = "geo-location-name";
pub const GST_TAG_GEO_LOCATION_LATITUDE = "geo-location-latitude";
pub const GST_TAG_GEO_LOCATION_LONGITUDE = "geo-location-longitude";
pub const GST_TAG_GEO_LOCATION_ELEVATION = "geo-location-elevation";
pub const GST_TAG_GEO_LOCATION_COUNTRY = "geo-location-country";
pub const GST_TAG_GEO_LOCATION_CITY = "geo-location-city";
pub const GST_TAG_GEO_LOCATION_SUBLOCATION = "geo-location-sublocation";
pub const GST_TAG_GEO_LOCATION_HORIZONTAL_ERROR = "geo-location-horizontal-error";
pub const GST_TAG_GEO_LOCATION_MOVEMENT_SPEED = "geo-location-movement-speed";
pub const GST_TAG_GEO_LOCATION_MOVEMENT_DIRECTION = "geo-location-movement-direction";
pub const GST_TAG_GEO_LOCATION_CAPTURE_DIRECTION = "geo-location-capture-direction";
pub const GST_TAG_SHOW_NAME = "show-name";
pub const GST_TAG_SHOW_SORTNAME = "show-sortname";
pub const GST_TAG_SHOW_EPISODE_NUMBER = "show-episode-number";
pub const GST_TAG_SHOW_SEASON_NUMBER = "show-season-number";
pub const GST_TAG_LYRICS = "lyrics";
pub const GST_TAG_COMPOSER_SORTNAME = "composer-sortname";
pub const GST_TAG_GROUPING = "grouping";
pub const GST_TAG_USER_RATING = "user-rating";
pub const GST_TAG_DEVICE_MANUFACTURER = "device-manufacturer";
pub const GST_TAG_DEVICE_MODEL = "device-model";
pub const GST_TAG_APPLICATION_NAME = "application-name";
pub const GST_TAG_APPLICATION_DATA = "application-data";
pub const GST_TAG_IMAGE_ORIENTATION = "image-orientation";
pub const GST_TAG_PUBLISHER = "publisher";
pub const GST_TAG_INTERPRETED_BY = "interpreted-by";
pub const GST_TAG_MIDI_BASE_NOTE = "midi-base-note";
pub const GST_TAG_PRIVATE_DATA = "private-data";
pub const __GST_MESSAGE_H__ = "";
pub const __GST_QUERY_H__ = "";
pub const GST_QUERY_TYPE_BOTH = @import("std").zig.c_translation.cast(GstQueryTypeFlags, GST_QUERY_TYPE_UPSTREAM | GST_QUERY_TYPE_DOWNSTREAM);
pub const GST_QUERY_NUM_SHIFT = @as(c_int, 8);
pub inline fn GST_QUERY_MAKE_TYPE(num: anytype, flags: anytype) @TypeOf((num << GST_QUERY_NUM_SHIFT) | flags) {
    return (num << GST_QUERY_NUM_SHIFT) | flags;
}
pub const GST_TYPE_QUERY = _gst_query_type;
pub inline fn GST_IS_QUERY(obj: anytype) @TypeOf(GST_IS_MINI_OBJECT_TYPE(obj, GST_TYPE_QUERY)) {
    return GST_IS_MINI_OBJECT_TYPE(obj, GST_TYPE_QUERY);
}
pub inline fn GST_QUERY_CAST(obj: anytype) [*c]GstQuery {
    return @import("std").zig.c_translation.cast([*c]GstQuery, obj);
}
pub inline fn GST_QUERY(obj: anytype) @TypeOf(GST_QUERY_CAST(obj)) {
    return GST_QUERY_CAST(obj);
}
pub inline fn GST_QUERY_TYPE(query: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]GstQuery, query).*.type) {
    return @import("std").zig.c_translation.cast([*c]GstQuery, query).*.type;
}
pub inline fn GST_QUERY_TYPE_NAME(query: anytype) @TypeOf(gst_query_type_get_name(GST_QUERY_TYPE(query))) {
    return gst_query_type_get_name(GST_QUERY_TYPE(query));
}
pub inline fn GST_QUERY_IS_UPSTREAM(ev: anytype) @TypeOf(!!((GST_QUERY_TYPE(ev) & GST_QUERY_TYPE_UPSTREAM) != 0)) {
    return !!((GST_QUERY_TYPE(ev) & GST_QUERY_TYPE_UPSTREAM) != 0);
}
pub inline fn GST_QUERY_IS_DOWNSTREAM(ev: anytype) @TypeOf(!!((GST_QUERY_TYPE(ev) & GST_QUERY_TYPE_DOWNSTREAM) != 0)) {
    return !!((GST_QUERY_TYPE(ev) & GST_QUERY_TYPE_DOWNSTREAM) != 0);
}
pub inline fn GST_QUERY_IS_SERIALIZED(ev: anytype) @TypeOf(!!((GST_QUERY_TYPE(ev) & GST_QUERY_TYPE_SERIALIZED) != 0)) {
    return !!((GST_QUERY_TYPE(ev) & GST_QUERY_TYPE_SERIALIZED) != 0);
}
pub const __GST_TOC_H__ = "";
pub const GST_TYPE_TOC = _gst_toc_type;
pub const GST_TYPE_TOC_ENTRY = _gst_toc_entry_type;
pub inline fn GST_TOC_ENTRY_TYPE_IS_ALTERNATIVE(entry_type: anytype) @TypeOf(entry_type < @as(c_int, 0)) {
    return entry_type < @as(c_int, 0);
}
pub inline fn GST_TOC_ENTRY_TYPE_IS_SEQUENCE(entry_type: anytype) @TypeOf(entry_type > @as(c_int, 0)) {
    return entry_type > @as(c_int, 0);
}
pub const GST_TOC_REPEAT_COUNT_INFINITE = -@as(c_int, 1);
pub inline fn gst_toc_ref(toc: anytype) [*c]GstToc {
    return @import("std").zig.c_translation.cast([*c]GstToc, gst_mini_object_ref(GST_MINI_OBJECT_CAST(toc)));
}
pub inline fn gst_toc_unref(toc: anytype) @TypeOf(gst_mini_object_unref(GST_MINI_OBJECT_CAST(toc))) {
    return gst_mini_object_unref(GST_MINI_OBJECT_CAST(toc));
}
pub inline fn gst_toc_copy(toc: anytype) [*c]GstToc {
    return @import("std").zig.c_translation.cast([*c]GstToc, gst_mini_object_copy(GST_MINI_OBJECT_CAST(toc)));
}
pub inline fn gst_toc_make_writable(toc: anytype) [*c]GstToc {
    return @import("std").zig.c_translation.cast([*c]GstToc, gst_mini_object_make_writable(GST_MINI_OBJECT_CAST(toc)));
}
pub inline fn gst_toc_entry_ref(entry: anytype) [*c]GstTocEntry {
    return @import("std").zig.c_translation.cast([*c]GstTocEntry, gst_mini_object_ref(GST_MINI_OBJECT_CAST(entry)));
}
pub inline fn gst_toc_entry_unref(entry: anytype) @TypeOf(gst_mini_object_unref(GST_MINI_OBJECT_CAST(entry))) {
    return gst_mini_object_unref(GST_MINI_OBJECT_CAST(entry));
}
pub inline fn gst_toc_entry_copy(entry: anytype) [*c]GstTocEntry {
    return @import("std").zig.c_translation.cast([*c]GstTocEntry, gst_mini_object_copy(GST_MINI_OBJECT_CAST(entry)));
}
pub inline fn gst_toc_entry_make_writable(entry: anytype) [*c]GstTocEntry {
    return @import("std").zig.c_translation.cast([*c]GstTocEntry, gst_mini_object_make_writable(GST_MINI_OBJECT_CAST(entry)));
}
pub const __GST_CONTEXT_H__ = "";
pub const GST_TYPE_CONTEXT = _gst_context_type;
pub inline fn GST_IS_CONTEXT(obj: anytype) @TypeOf(GST_IS_MINI_OBJECT_TYPE(obj, GST_TYPE_CONTEXT)) {
    return GST_IS_MINI_OBJECT_TYPE(obj, GST_TYPE_CONTEXT);
}
pub inline fn GST_CONTEXT_CAST(obj: anytype) [*c]GstContext {
    return @import("std").zig.c_translation.cast([*c]GstContext, obj);
}
pub inline fn GST_CONTEXT(obj: anytype) @TypeOf(GST_CONTEXT_CAST(obj)) {
    return GST_CONTEXT_CAST(obj);
}
pub inline fn gst_context_is_writable(context: anytype) @TypeOf(gst_mini_object_is_writable(GST_MINI_OBJECT_CAST(context))) {
    return gst_mini_object_is_writable(GST_MINI_OBJECT_CAST(context));
}
pub inline fn gst_context_make_writable(context: anytype) @TypeOf(GST_CONTEXT_CAST(gst_mini_object_make_writable(GST_MINI_OBJECT_CAST(context)))) {
    return GST_CONTEXT_CAST(gst_mini_object_make_writable(GST_MINI_OBJECT_CAST(context)));
}
pub inline fn gst_query_is_writable(q: anytype) @TypeOf(gst_mini_object_is_writable(GST_MINI_OBJECT_CAST(q))) {
    return gst_mini_object_is_writable(GST_MINI_OBJECT_CAST(q));
}
pub inline fn gst_query_make_writable(q: anytype) @TypeOf(GST_QUERY_CAST(gst_mini_object_make_writable(GST_MINI_OBJECT_CAST(q)))) {
    return GST_QUERY_CAST(gst_mini_object_make_writable(GST_MINI_OBJECT_CAST(q)));
}
pub const __GST_DEVICE_H__ = "";
pub const GST_TYPE_DEVICE = gst_device_get_type();
pub inline fn GST_IS_DEVICE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_DEVICE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_DEVICE);
}
pub inline fn GST_IS_DEVICE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_DEVICE)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_DEVICE);
}
pub inline fn GST_DEVICE_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_DEVICE, GstDeviceClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_DEVICE, GstDeviceClass);
}
pub inline fn GST_DEVICE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_DEVICE, GstDevice)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_DEVICE, GstDevice);
}
pub inline fn GST_DEVICE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_DEVICE, GstDeviceClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_DEVICE, GstDeviceClass);
}
pub inline fn GST_DEVICE_CAST(obj: anytype) [*c]GstDevice {
    return @import("std").zig.c_translation.cast([*c]GstDevice, obj);
}
pub const __GST_STREAMS_H__ = "";
pub const GST_TYPE_STREAM = gst_stream_get_type();
pub inline fn GST_IS_STREAM(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_STREAM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_STREAM);
}
pub inline fn GST_IS_STREAM_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_STREAM)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_STREAM);
}
pub inline fn GST_STREAM_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_STREAM, GstStreamClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_STREAM, GstStreamClass);
}
pub inline fn GST_STREAM(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_STREAM, GstStream)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_STREAM, GstStream);
}
pub inline fn GST_STREAM_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_STREAM, GstStreamClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_STREAM, GstStreamClass);
}
pub inline fn GST_STREAM_CAST(obj: anytype) [*c]GstStream {
    return @import("std").zig.c_translation.cast([*c]GstStream, obj);
}
pub const __GST_STREAM_COLLECTION_H__ = "";
pub const GST_TYPE_STREAM_COLLECTION = gst_stream_collection_get_type();
pub inline fn GST_IS_STREAM_COLLECTION(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_STREAM_COLLECTION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_STREAM_COLLECTION);
}
pub inline fn GST_IS_STREAM_COLLECTION_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_STREAM_COLLECTION)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_STREAM_COLLECTION);
}
pub inline fn GST_STREAM_COLLECTION_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_STREAM_COLLECTION, GstStreamCollectionClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_STREAM_COLLECTION, GstStreamCollectionClass);
}
pub inline fn GST_STREAM_COLLECTION(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_STREAM_COLLECTION, GstStreamCollection)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_STREAM_COLLECTION, GstStreamCollection);
}
pub inline fn GST_STREAM_COLLECTION_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_STREAM_COLLECTION, GstStreamCollectionClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_STREAM_COLLECTION, GstStreamCollectionClass);
}
pub inline fn GST_STREAM_COLLECTION_CAST(obj: anytype) [*c]GstStreamCollection {
    return @import("std").zig.c_translation.cast([*c]GstStreamCollection, obj);
}
pub const GST_TYPE_MESSAGE = _gst_message_type;
pub inline fn GST_IS_MESSAGE(obj: anytype) @TypeOf(GST_IS_MINI_OBJECT_TYPE(obj, GST_TYPE_MESSAGE)) {
    return GST_IS_MINI_OBJECT_TYPE(obj, GST_TYPE_MESSAGE);
}
pub inline fn GST_MESSAGE_CAST(obj: anytype) [*c]GstMessage {
    return @import("std").zig.c_translation.cast([*c]GstMessage, obj);
}
pub inline fn GST_MESSAGE(obj: anytype) @TypeOf(GST_MESSAGE_CAST(obj)) {
    return GST_MESSAGE_CAST(obj);
}
pub inline fn GST_MESSAGE_GET_LOCK(message: anytype) @TypeOf(&GST_MESSAGE_CAST(message).*.lock) {
    return &GST_MESSAGE_CAST(message).*.lock;
}
pub inline fn GST_MESSAGE_LOCK(message: anytype) @TypeOf(g_mutex_lock(GST_MESSAGE_GET_LOCK(message))) {
    return g_mutex_lock(GST_MESSAGE_GET_LOCK(message));
}
pub inline fn GST_MESSAGE_UNLOCK(message: anytype) @TypeOf(g_mutex_unlock(GST_MESSAGE_GET_LOCK(message))) {
    return g_mutex_unlock(GST_MESSAGE_GET_LOCK(message));
}
pub inline fn GST_MESSAGE_GET_COND(message: anytype) @TypeOf(&GST_MESSAGE_CAST(message).*.cond) {
    return &GST_MESSAGE_CAST(message).*.cond;
}
pub inline fn GST_MESSAGE_WAIT(message: anytype) @TypeOf(g_cond_wait(GST_MESSAGE_GET_COND(message), GST_MESSAGE_GET_LOCK(message))) {
    return g_cond_wait(GST_MESSAGE_GET_COND(message), GST_MESSAGE_GET_LOCK(message));
}
pub inline fn GST_MESSAGE_SIGNAL(message: anytype) @TypeOf(g_cond_signal(GST_MESSAGE_GET_COND(message))) {
    return g_cond_signal(GST_MESSAGE_GET_COND(message));
}
pub inline fn GST_MESSAGE_TYPE(message: anytype) @TypeOf(GST_MESSAGE_CAST(message).*.type) {
    return GST_MESSAGE_CAST(message).*.type;
}
pub inline fn GST_MESSAGE_TYPE_IS_EXTENDED(message: anytype) @TypeOf(!!((GST_MESSAGE_CAST(message).*.type & GST_MESSAGE_EXTENDED) != 0)) {
    return !!((GST_MESSAGE_CAST(message).*.type & GST_MESSAGE_EXTENDED) != 0);
}
pub inline fn GST_MESSAGE_TYPE_NAME(message: anytype) @TypeOf(gst_message_type_get_name(GST_MESSAGE_TYPE(message))) {
    return gst_message_type_get_name(GST_MESSAGE_TYPE(message));
}
pub inline fn GST_MESSAGE_TIMESTAMP(message: anytype) @TypeOf(GST_MESSAGE_CAST(message).*.timestamp) {
    return GST_MESSAGE_CAST(message).*.timestamp;
}
pub inline fn GST_MESSAGE_SRC(message: anytype) @TypeOf(GST_MESSAGE_CAST(message).*.src) {
    return GST_MESSAGE_CAST(message).*.src;
}
pub inline fn GST_MESSAGE_SEQNUM(message: anytype) @TypeOf(GST_MESSAGE_CAST(message).*.seqnum) {
    return GST_MESSAGE_CAST(message).*.seqnum;
}
pub inline fn GST_MESSAGE_SRC_NAME(message: anytype) @TypeOf(if (GST_MESSAGE_SRC(message)) GST_OBJECT_NAME(GST_MESSAGE_SRC(message)) else "(NULL)") {
    return if (GST_MESSAGE_SRC(message)) GST_OBJECT_NAME(GST_MESSAGE_SRC(message)) else "(NULL)";
}
pub inline fn gst_message_is_writable(msg: anytype) @TypeOf(gst_mini_object_is_writable(GST_MINI_OBJECT_CAST(msg))) {
    return gst_mini_object_is_writable(GST_MINI_OBJECT_CAST(msg));
}
pub inline fn gst_message_make_writable(msg: anytype) @TypeOf(GST_MESSAGE_CAST(gst_mini_object_make_writable(GST_MINI_OBJECT_CAST(msg)))) {
    return GST_MESSAGE_CAST(gst_mini_object_make_writable(GST_MINI_OBJECT_CAST(msg)));
}
pub const GST_TYPE_EVENT = _gst_event_type;
pub inline fn GST_IS_EVENT(obj: anytype) @TypeOf(GST_IS_MINI_OBJECT_TYPE(obj, GST_TYPE_EVENT)) {
    return GST_IS_MINI_OBJECT_TYPE(obj, GST_TYPE_EVENT);
}
pub inline fn GST_EVENT_CAST(obj: anytype) [*c]GstEvent {
    return @import("std").zig.c_translation.cast([*c]GstEvent, obj);
}
pub inline fn GST_EVENT(obj: anytype) @TypeOf(GST_EVENT_CAST(obj)) {
    return GST_EVENT_CAST(obj);
}
pub inline fn GST_EVENT_TYPE(event: anytype) @TypeOf(GST_EVENT_CAST(event).*.type) {
    return GST_EVENT_CAST(event).*.type;
}
pub inline fn GST_EVENT_TYPE_NAME(event: anytype) @TypeOf(gst_event_type_get_name(GST_EVENT_TYPE(event))) {
    return gst_event_type_get_name(GST_EVENT_TYPE(event));
}
pub inline fn GST_EVENT_TIMESTAMP(event: anytype) @TypeOf(GST_EVENT_CAST(event).*.timestamp) {
    return GST_EVENT_CAST(event).*.timestamp;
}
pub inline fn GST_EVENT_SEQNUM(event: anytype) @TypeOf(GST_EVENT_CAST(event).*.seqnum) {
    return GST_EVENT_CAST(event).*.seqnum;
}
pub inline fn GST_EVENT_IS_UPSTREAM(ev: anytype) @TypeOf(!!((GST_EVENT_TYPE(ev) & GST_EVENT_TYPE_UPSTREAM) != 0)) {
    return !!((GST_EVENT_TYPE(ev) & GST_EVENT_TYPE_UPSTREAM) != 0);
}
pub inline fn GST_EVENT_IS_DOWNSTREAM(ev: anytype) @TypeOf(!!((GST_EVENT_TYPE(ev) & GST_EVENT_TYPE_DOWNSTREAM) != 0)) {
    return !!((GST_EVENT_TYPE(ev) & GST_EVENT_TYPE_DOWNSTREAM) != 0);
}
pub inline fn GST_EVENT_IS_SERIALIZED(ev: anytype) @TypeOf(!!((GST_EVENT_TYPE(ev) & GST_EVENT_TYPE_SERIALIZED) != 0)) {
    return !!((GST_EVENT_TYPE(ev) & GST_EVENT_TYPE_SERIALIZED) != 0);
}
pub inline fn GST_EVENT_IS_STICKY(ev: anytype) @TypeOf(!!((GST_EVENT_TYPE(ev) & GST_EVENT_TYPE_STICKY) != 0)) {
    return !!((GST_EVENT_TYPE(ev) & GST_EVENT_TYPE_STICKY) != 0);
}
pub inline fn gst_event_is_writable(ev: anytype) @TypeOf(gst_mini_object_is_writable(GST_MINI_OBJECT_CAST(ev))) {
    return gst_mini_object_is_writable(GST_MINI_OBJECT_CAST(ev));
}
pub inline fn gst_event_make_writable(ev: anytype) @TypeOf(GST_EVENT_CAST(gst_mini_object_make_writable(GST_MINI_OBJECT_CAST(ev)))) {
    return GST_EVENT_CAST(gst_mini_object_make_writable(GST_MINI_OBJECT_CAST(ev)));
}
pub const __GST_TASK_H__ = "";
pub const __GST_TASK_POOL_H__ = "";
pub const GST_TYPE_TASK_POOL = gst_task_pool_get_type();
pub inline fn GST_TASK_POOL(pool: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pool, GST_TYPE_TASK_POOL, GstTaskPool)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pool, GST_TYPE_TASK_POOL, GstTaskPool);
}
pub inline fn GST_IS_TASK_POOL(pool: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pool, GST_TYPE_TASK_POOL)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pool, GST_TYPE_TASK_POOL);
}
pub inline fn GST_TASK_POOL_CLASS(pclass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(pclass, GST_TYPE_TASK_POOL, GstTaskPoolClass)) {
    return G_TYPE_CHECK_CLASS_CAST(pclass, GST_TYPE_TASK_POOL, GstTaskPoolClass);
}
pub inline fn GST_IS_TASK_POOL_CLASS(pclass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(pclass, GST_TYPE_TASK_POOL)) {
    return G_TYPE_CHECK_CLASS_TYPE(pclass, GST_TYPE_TASK_POOL);
}
pub inline fn GST_TASK_POOL_GET_CLASS(pool: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(pool, GST_TYPE_TASK_POOL, GstTaskPoolClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(pool, GST_TYPE_TASK_POOL, GstTaskPoolClass);
}
pub inline fn GST_TASK_POOL_CAST(pool: anytype) [*c]GstTaskPool {
    return @import("std").zig.c_translation.cast([*c]GstTaskPool, pool);
}
pub const GST_TYPE_SHARED_TASK_POOL = gst_shared_task_pool_get_type();
pub inline fn GST_SHARED_TASK_POOL(pool: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pool, GST_TYPE_TASK_POOL, GstSharedTaskPool)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pool, GST_TYPE_TASK_POOL, GstSharedTaskPool);
}
pub inline fn GST_IS_SHARED_TASK_POOL(pool: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pool, GST_TYPE_SHARED_TASK_POOL)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pool, GST_TYPE_SHARED_TASK_POOL);
}
pub inline fn GST_SHARED_TASK_POOL_CLASS(pclass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(pclass, GST_TYPE_SHARED_TASK_POOL, GstSharedTaskPoolClass)) {
    return G_TYPE_CHECK_CLASS_CAST(pclass, GST_TYPE_SHARED_TASK_POOL, GstSharedTaskPoolClass);
}
pub inline fn GST_IS_SHARED_TASK_POOL_CLASS(pclass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(pclass, GST_TYPE_SHARED_TASK_POOL)) {
    return G_TYPE_CHECK_CLASS_TYPE(pclass, GST_TYPE_SHARED_TASK_POOL);
}
pub inline fn GST_SHARED_TASK_POOL_GET_CLASS(pool: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(pool, GST_TYPE_SHARED_TASK_POOL, GstSharedTaskPoolClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(pool, GST_TYPE_SHARED_TASK_POOL, GstSharedTaskPoolClass);
}
pub const GST_TYPE_TASK = gst_task_get_type();
pub inline fn GST_TASK(task: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(task, GST_TYPE_TASK, GstTask)) {
    return G_TYPE_CHECK_INSTANCE_CAST(task, GST_TYPE_TASK, GstTask);
}
pub inline fn GST_IS_TASK(task: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(task, GST_TYPE_TASK)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(task, GST_TYPE_TASK);
}
pub inline fn GST_TASK_CLASS(tclass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(tclass, GST_TYPE_TASK, GstTaskClass)) {
    return G_TYPE_CHECK_CLASS_CAST(tclass, GST_TYPE_TASK, GstTaskClass);
}
pub inline fn GST_IS_TASK_CLASS(tclass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(tclass, GST_TYPE_TASK)) {
    return G_TYPE_CHECK_CLASS_TYPE(tclass, GST_TYPE_TASK);
}
pub inline fn GST_TASK_GET_CLASS(task: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(task, GST_TYPE_TASK, GstTaskClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(task, GST_TYPE_TASK, GstTaskClass);
}
pub inline fn GST_TASK_CAST(task: anytype) [*c]GstTask {
    return @import("std").zig.c_translation.cast([*c]GstTask, task);
}
pub inline fn GST_TASK_STATE(task: anytype) @TypeOf(GST_TASK_CAST(task).*.state) {
    return GST_TASK_CAST(task).*.state;
}
pub inline fn GST_TASK_GET_COND(task: anytype) @TypeOf(&GST_TASK_CAST(task).*.cond) {
    return &GST_TASK_CAST(task).*.cond;
}
pub inline fn GST_TASK_WAIT(task: anytype) @TypeOf(g_cond_wait(GST_TASK_GET_COND(task), GST_OBJECT_GET_LOCK(task))) {
    return g_cond_wait(GST_TASK_GET_COND(task), GST_OBJECT_GET_LOCK(task));
}
pub inline fn GST_TASK_SIGNAL(task: anytype) @TypeOf(g_cond_signal(GST_TASK_GET_COND(task))) {
    return g_cond_signal(GST_TASK_GET_COND(task));
}
pub inline fn GST_TASK_BROADCAST(task: anytype) @TypeOf(g_cond_broadcast(GST_TASK_GET_COND(task))) {
    return g_cond_broadcast(GST_TASK_GET_COND(task));
}
pub inline fn GST_TASK_GET_LOCK(task: anytype) @TypeOf(GST_TASK_CAST(task).*.lock) {
    return GST_TASK_CAST(task).*.lock;
}
pub const GST_TYPE_STATIC_PAD_TEMPLATE = gst_static_pad_template_get_type();
pub const GST_TYPE_PAD_TEMPLATE = gst_pad_template_get_type();
pub inline fn GST_PAD_TEMPLATE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_PAD_TEMPLATE, GstPadTemplate)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_PAD_TEMPLATE, GstPadTemplate);
}
pub inline fn GST_PAD_TEMPLATE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_PAD_TEMPLATE, GstPadTemplateClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_PAD_TEMPLATE, GstPadTemplateClass);
}
pub inline fn GST_IS_PAD_TEMPLATE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_PAD_TEMPLATE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_PAD_TEMPLATE);
}
pub inline fn GST_IS_PAD_TEMPLATE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_PAD_TEMPLATE)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_PAD_TEMPLATE);
}
pub inline fn GST_PAD_TEMPLATE_NAME_TEMPLATE(templ: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]GstPadTemplate, templ).*.name_template) {
    return @import("std").zig.c_translation.cast([*c]GstPadTemplate, templ).*.name_template;
}
pub inline fn GST_PAD_TEMPLATE_DIRECTION(templ: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]GstPadTemplate, templ).*.direction) {
    return @import("std").zig.c_translation.cast([*c]GstPadTemplate, templ).*.direction;
}
pub inline fn GST_PAD_TEMPLATE_PRESENCE(templ: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]GstPadTemplate, templ).*.presence) {
    return @import("std").zig.c_translation.cast([*c]GstPadTemplate, templ).*.presence;
}
pub inline fn GST_PAD_TEMPLATE_CAPS(templ: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]GstPadTemplate, templ).*.caps) {
    return @import("std").zig.c_translation.cast([*c]GstPadTemplate, templ).*.caps;
}
pub inline fn GST_PAD_TEMPLATE_GTYPE(templ: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]GstPadTemplate, templ).*.ABI.abi.gtype) {
    return @import("std").zig.c_translation.cast([*c]GstPadTemplate, templ).*.ABI.abi.gtype;
}
pub const GST_TYPE_PAD = gst_pad_get_type();
pub inline fn GST_IS_PAD(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_PAD)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_PAD);
}
pub inline fn GST_IS_PAD_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_PAD)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_PAD);
}
pub inline fn GST_PAD(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_PAD, GstPad)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_PAD, GstPad);
}
pub inline fn GST_PAD_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_PAD, GstPadClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_PAD, GstPadClass);
}
pub inline fn GST_PAD_CAST(obj: anytype) [*c]GstPad {
    return @import("std").zig.c_translation.cast([*c]GstPad, obj);
}
pub inline fn GST_PAD_LINK_FAILED(ret: anytype) @TypeOf(ret < GST_PAD_LINK_OK) {
    return ret < GST_PAD_LINK_OK;
}
pub inline fn GST_PAD_LINK_SUCCESSFUL(ret: anytype) @TypeOf(ret >= GST_PAD_LINK_OK) {
    return ret >= GST_PAD_LINK_OK;
}
pub inline fn GST_PAD_PROBE_INFO_TYPE(d: anytype) @TypeOf(d.*.type) {
    return d.*.type;
}
pub inline fn GST_PAD_PROBE_INFO_ID(d: anytype) @TypeOf(d.*.id) {
    return d.*.id;
}
pub inline fn GST_PAD_PROBE_INFO_DATA(d: anytype) @TypeOf(d.*.data) {
    return d.*.data;
}
pub inline fn GST_PAD_PROBE_INFO_FLOW_RETURN(d: anytype) @TypeOf(d.*.ABI.abi.flow_ret) {
    return d.*.ABI.abi.flow_ret;
}
pub inline fn GST_PAD_PROBE_INFO_BUFFER(d: anytype) @TypeOf(GST_BUFFER_CAST(GST_PAD_PROBE_INFO_DATA(d))) {
    return GST_BUFFER_CAST(GST_PAD_PROBE_INFO_DATA(d));
}
pub inline fn GST_PAD_PROBE_INFO_BUFFER_LIST(d: anytype) @TypeOf(GST_BUFFER_LIST_CAST(GST_PAD_PROBE_INFO_DATA(d))) {
    return GST_BUFFER_LIST_CAST(GST_PAD_PROBE_INFO_DATA(d));
}
pub inline fn GST_PAD_PROBE_INFO_EVENT(d: anytype) @TypeOf(GST_EVENT_CAST(GST_PAD_PROBE_INFO_DATA(d))) {
    return GST_EVENT_CAST(GST_PAD_PROBE_INFO_DATA(d));
}
pub inline fn GST_PAD_PROBE_INFO_QUERY(d: anytype) @TypeOf(GST_QUERY_CAST(GST_PAD_PROBE_INFO_DATA(d))) {
    return GST_QUERY_CAST(GST_PAD_PROBE_INFO_DATA(d));
}
pub inline fn GST_PAD_PROBE_INFO_OFFSET(d: anytype) @TypeOf(d.*.offset) {
    return d.*.offset;
}
pub inline fn GST_PAD_PROBE_INFO_SIZE(d: anytype) @TypeOf(d.*.size) {
    return d.*.size;
}
pub inline fn GST_PAD_NAME(pad: anytype) @TypeOf(GST_OBJECT_NAME(pad)) {
    return GST_OBJECT_NAME(pad);
}
pub inline fn GST_PAD_PARENT(pad: anytype) @TypeOf(GST_ELEMENT_CAST(GST_OBJECT_PARENT(pad))) {
    return GST_ELEMENT_CAST(GST_OBJECT_PARENT(pad));
}
pub inline fn GST_PAD_ELEMENT_PRIVATE(pad: anytype) @TypeOf(GST_PAD_CAST(pad).*.element_private) {
    return GST_PAD_CAST(pad).*.element_private;
}
pub inline fn GST_PAD_PAD_TEMPLATE(pad: anytype) @TypeOf(GST_PAD_CAST(pad).*.padtemplate) {
    return GST_PAD_CAST(pad).*.padtemplate;
}
pub inline fn GST_PAD_DIRECTION(pad: anytype) @TypeOf(GST_PAD_CAST(pad).*.direction) {
    return GST_PAD_CAST(pad).*.direction;
}
pub inline fn GST_PAD_TASK(pad: anytype) @TypeOf(GST_PAD_CAST(pad).*.task) {
    return GST_PAD_CAST(pad).*.task;
}
pub inline fn GST_PAD_MODE(pad: anytype) @TypeOf(GST_PAD_CAST(pad).*.mode) {
    return GST_PAD_CAST(pad).*.mode;
}
pub inline fn GST_PAD_ACTIVATEFUNC(pad: anytype) @TypeOf(GST_PAD_CAST(pad).*.activatefunc) {
    return GST_PAD_CAST(pad).*.activatefunc;
}
pub inline fn GST_PAD_ACTIVATEMODEFUNC(pad: anytype) @TypeOf(GST_PAD_CAST(pad).*.activatemodefunc) {
    return GST_PAD_CAST(pad).*.activatemodefunc;
}
pub inline fn GST_PAD_CHAINFUNC(pad: anytype) @TypeOf(GST_PAD_CAST(pad).*.chainfunc) {
    return GST_PAD_CAST(pad).*.chainfunc;
}
pub inline fn GST_PAD_CHAINLISTFUNC(pad: anytype) @TypeOf(GST_PAD_CAST(pad).*.chainlistfunc) {
    return GST_PAD_CAST(pad).*.chainlistfunc;
}
pub inline fn GST_PAD_GETRANGEFUNC(pad: anytype) @TypeOf(GST_PAD_CAST(pad).*.getrangefunc) {
    return GST_PAD_CAST(pad).*.getrangefunc;
}
pub inline fn GST_PAD_EVENTFUNC(pad: anytype) @TypeOf(GST_PAD_CAST(pad).*.eventfunc) {
    return GST_PAD_CAST(pad).*.eventfunc;
}
pub inline fn GST_PAD_EVENTFULLFUNC(pad: anytype) @TypeOf(GST_PAD_CAST(pad).*.ABI.abi.eventfullfunc) {
    return GST_PAD_CAST(pad).*.ABI.abi.eventfullfunc;
}
pub inline fn GST_PAD_QUERYFUNC(pad: anytype) @TypeOf(GST_PAD_CAST(pad).*.queryfunc) {
    return GST_PAD_CAST(pad).*.queryfunc;
}
pub inline fn GST_PAD_ITERINTLINKFUNC(pad: anytype) @TypeOf(GST_PAD_CAST(pad).*.iterintlinkfunc) {
    return GST_PAD_CAST(pad).*.iterintlinkfunc;
}
pub inline fn GST_PAD_PEER(pad: anytype) @TypeOf(GST_PAD_CAST(pad).*.peer) {
    return GST_PAD_CAST(pad).*.peer;
}
pub inline fn GST_PAD_LINKFUNC(pad: anytype) @TypeOf(GST_PAD_CAST(pad).*.linkfunc) {
    return GST_PAD_CAST(pad).*.linkfunc;
}
pub inline fn GST_PAD_UNLINKFUNC(pad: anytype) @TypeOf(GST_PAD_CAST(pad).*.unlinkfunc) {
    return GST_PAD_CAST(pad).*.unlinkfunc;
}
pub inline fn GST_PAD_IS_SRC(pad: anytype) @TypeOf(GST_PAD_DIRECTION(pad) == GST_PAD_SRC) {
    return GST_PAD_DIRECTION(pad) == GST_PAD_SRC;
}
pub inline fn GST_PAD_IS_SINK(pad: anytype) @TypeOf(GST_PAD_DIRECTION(pad) == GST_PAD_SINK) {
    return GST_PAD_DIRECTION(pad) == GST_PAD_SINK;
}
pub inline fn GST_PAD_IS_LINKED(pad: anytype) @TypeOf(GST_PAD_PEER(pad) != NULL) {
    return GST_PAD_PEER(pad) != NULL;
}
pub inline fn GST_PAD_IS_ACTIVE(pad: anytype) @TypeOf(GST_PAD_MODE(pad) != GST_PAD_MODE_NONE) {
    return GST_PAD_MODE(pad) != GST_PAD_MODE_NONE;
}
pub inline fn GST_PAD_IS_BLOCKED(pad: anytype) @TypeOf(GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_BLOCKED)) {
    return GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_BLOCKED);
}
pub inline fn GST_PAD_IS_BLOCKING(pad: anytype) @TypeOf(GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_BLOCKING)) {
    return GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_BLOCKING);
}
pub inline fn GST_PAD_IS_FLUSHING(pad: anytype) @TypeOf(GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_FLUSHING)) {
    return GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_FLUSHING);
}
pub inline fn GST_PAD_SET_FLUSHING(pad: anytype) @TypeOf(GST_OBJECT_FLAG_SET(pad, GST_PAD_FLAG_FLUSHING)) {
    return GST_OBJECT_FLAG_SET(pad, GST_PAD_FLAG_FLUSHING);
}
pub inline fn GST_PAD_UNSET_FLUSHING(pad: anytype) @TypeOf(GST_OBJECT_FLAG_UNSET(pad, GST_PAD_FLAG_FLUSHING)) {
    return GST_OBJECT_FLAG_UNSET(pad, GST_PAD_FLAG_FLUSHING);
}
pub inline fn GST_PAD_IS_EOS(pad: anytype) @TypeOf(GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_EOS)) {
    return GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_EOS);
}
pub inline fn GST_PAD_NEEDS_RECONFIGURE(pad: anytype) @TypeOf(GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_NEED_RECONFIGURE)) {
    return GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_NEED_RECONFIGURE);
}
pub inline fn GST_PAD_HAS_PENDING_EVENTS(pad: anytype) @TypeOf(GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_PENDING_EVENTS)) {
    return GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_PENDING_EVENTS);
}
pub inline fn GST_PAD_IS_FIXED_CAPS(pad: anytype) @TypeOf(GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_FIXED_CAPS)) {
    return GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_FIXED_CAPS);
}
pub inline fn GST_PAD_NEEDS_PARENT(pad: anytype) @TypeOf(GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_NEED_PARENT)) {
    return GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_NEED_PARENT);
}
pub inline fn GST_PAD_IS_PROXY_CAPS(pad: anytype) @TypeOf(GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_PROXY_CAPS)) {
    return GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_PROXY_CAPS);
}
pub inline fn GST_PAD_SET_PROXY_CAPS(pad: anytype) @TypeOf(GST_OBJECT_FLAG_SET(pad, GST_PAD_FLAG_PROXY_CAPS)) {
    return GST_OBJECT_FLAG_SET(pad, GST_PAD_FLAG_PROXY_CAPS);
}
pub inline fn GST_PAD_UNSET_PROXY_CAPS(pad: anytype) @TypeOf(GST_OBJECT_FLAG_UNSET(pad, GST_PAD_FLAG_PROXY_CAPS)) {
    return GST_OBJECT_FLAG_UNSET(pad, GST_PAD_FLAG_PROXY_CAPS);
}
pub inline fn GST_PAD_IS_PROXY_ALLOCATION(pad: anytype) @TypeOf(GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_PROXY_ALLOCATION)) {
    return GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_PROXY_ALLOCATION);
}
pub inline fn GST_PAD_SET_PROXY_ALLOCATION(pad: anytype) @TypeOf(GST_OBJECT_FLAG_SET(pad, GST_PAD_FLAG_PROXY_ALLOCATION)) {
    return GST_OBJECT_FLAG_SET(pad, GST_PAD_FLAG_PROXY_ALLOCATION);
}
pub inline fn GST_PAD_UNSET_PROXY_ALLOCATION(pad: anytype) @TypeOf(GST_OBJECT_FLAG_UNSET(pad, GST_PAD_FLAG_PROXY_ALLOCATION)) {
    return GST_OBJECT_FLAG_UNSET(pad, GST_PAD_FLAG_PROXY_ALLOCATION);
}
pub inline fn GST_PAD_IS_PROXY_SCHEDULING(pad: anytype) @TypeOf(GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_PROXY_SCHEDULING)) {
    return GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_PROXY_SCHEDULING);
}
pub inline fn GST_PAD_SET_PROXY_SCHEDULING(pad: anytype) @TypeOf(GST_OBJECT_FLAG_SET(pad, GST_PAD_FLAG_PROXY_SCHEDULING)) {
    return GST_OBJECT_FLAG_SET(pad, GST_PAD_FLAG_PROXY_SCHEDULING);
}
pub inline fn GST_PAD_UNSET_PROXY_SCHEDULING(pad: anytype) @TypeOf(GST_OBJECT_FLAG_UNSET(pad, GST_PAD_FLAG_PROXY_SCHEDULING)) {
    return GST_OBJECT_FLAG_UNSET(pad, GST_PAD_FLAG_PROXY_SCHEDULING);
}
pub inline fn GST_PAD_IS_ACCEPT_INTERSECT(pad: anytype) @TypeOf(GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_ACCEPT_INTERSECT)) {
    return GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_ACCEPT_INTERSECT);
}
pub inline fn GST_PAD_SET_ACCEPT_INTERSECT(pad: anytype) @TypeOf(GST_OBJECT_FLAG_SET(pad, GST_PAD_FLAG_ACCEPT_INTERSECT)) {
    return GST_OBJECT_FLAG_SET(pad, GST_PAD_FLAG_ACCEPT_INTERSECT);
}
pub inline fn GST_PAD_UNSET_ACCEPT_INTERSECT(pad: anytype) @TypeOf(GST_OBJECT_FLAG_UNSET(pad, GST_PAD_FLAG_ACCEPT_INTERSECT)) {
    return GST_OBJECT_FLAG_UNSET(pad, GST_PAD_FLAG_ACCEPT_INTERSECT);
}
pub inline fn GST_PAD_IS_ACCEPT_TEMPLATE(pad: anytype) @TypeOf(GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_ACCEPT_TEMPLATE)) {
    return GST_OBJECT_FLAG_IS_SET(pad, GST_PAD_FLAG_ACCEPT_TEMPLATE);
}
pub inline fn GST_PAD_SET_ACCEPT_TEMPLATE(pad: anytype) @TypeOf(GST_OBJECT_FLAG_SET(pad, GST_PAD_FLAG_ACCEPT_TEMPLATE)) {
    return GST_OBJECT_FLAG_SET(pad, GST_PAD_FLAG_ACCEPT_TEMPLATE);
}
pub inline fn GST_PAD_UNSET_ACCEPT_TEMPLATE(pad: anytype) @TypeOf(GST_OBJECT_FLAG_UNSET(pad, GST_PAD_FLAG_ACCEPT_TEMPLATE)) {
    return GST_OBJECT_FLAG_UNSET(pad, GST_PAD_FLAG_ACCEPT_TEMPLATE);
}
pub inline fn GST_PAD_GET_STREAM_LOCK(pad: anytype) @TypeOf(&GST_PAD_CAST(pad).*.stream_rec_lock) {
    return &GST_PAD_CAST(pad).*.stream_rec_lock;
}
pub inline fn GST_PAD_STREAM_LOCK(pad: anytype) @TypeOf(g_rec_mutex_lock(GST_PAD_GET_STREAM_LOCK(pad))) {
    return g_rec_mutex_lock(GST_PAD_GET_STREAM_LOCK(pad));
}
pub inline fn GST_PAD_STREAM_TRYLOCK(pad: anytype) @TypeOf(g_rec_mutex_trylock(GST_PAD_GET_STREAM_LOCK(pad))) {
    return g_rec_mutex_trylock(GST_PAD_GET_STREAM_LOCK(pad));
}
pub inline fn GST_PAD_STREAM_UNLOCK(pad: anytype) @TypeOf(g_rec_mutex_unlock(GST_PAD_GET_STREAM_LOCK(pad))) {
    return g_rec_mutex_unlock(GST_PAD_GET_STREAM_LOCK(pad));
}
pub inline fn GST_PAD_LAST_FLOW_RETURN(pad: anytype) @TypeOf(GST_PAD_CAST(pad).*.ABI.abi.last_flowret) {
    return GST_PAD_CAST(pad).*.ABI.abi.last_flowret;
}
pub inline fn GST_PAD_BLOCK_GET_COND(pad: anytype) @TypeOf(&GST_PAD_CAST(pad).*.block_cond) {
    return &GST_PAD_CAST(pad).*.block_cond;
}
pub inline fn GST_PAD_BLOCK_WAIT(pad: anytype) @TypeOf(g_cond_wait(GST_PAD_BLOCK_GET_COND(pad), GST_OBJECT_GET_LOCK(pad))) {
    return g_cond_wait(GST_PAD_BLOCK_GET_COND(pad), GST_OBJECT_GET_LOCK(pad));
}
pub inline fn GST_PAD_BLOCK_SIGNAL(pad: anytype) @TypeOf(g_cond_signal(GST_PAD_BLOCK_GET_COND(pad))) {
    return g_cond_signal(GST_PAD_BLOCK_GET_COND(pad));
}
pub inline fn GST_PAD_BLOCK_BROADCAST(pad: anytype) @TypeOf(g_cond_broadcast(GST_PAD_BLOCK_GET_COND(pad))) {
    return g_cond_broadcast(GST_PAD_BLOCK_GET_COND(pad));
}
pub inline fn gst_pad_get_name(pad: anytype) @TypeOf(gst_object_get_name(GST_OBJECT_CAST(pad))) {
    return gst_object_get_name(GST_OBJECT_CAST(pad));
}
pub inline fn gst_pad_get_parent(pad: anytype) @TypeOf(gst_object_get_parent(GST_OBJECT_CAST(pad))) {
    return gst_object_get_parent(GST_OBJECT_CAST(pad));
}
pub inline fn gst_pad_set_activate_function(p: anytype, f: anytype) @TypeOf(gst_pad_set_activate_function_full(p, f, NULL, NULL)) {
    return gst_pad_set_activate_function_full(p, f, NULL, NULL);
}
pub inline fn gst_pad_set_activatemode_function(p: anytype, f: anytype) @TypeOf(gst_pad_set_activatemode_function_full(p, f, NULL, NULL)) {
    return gst_pad_set_activatemode_function_full(p, f, NULL, NULL);
}
pub inline fn gst_pad_set_chain_function(p: anytype, f: anytype) @TypeOf(gst_pad_set_chain_function_full(p, f, NULL, NULL)) {
    return gst_pad_set_chain_function_full(p, f, NULL, NULL);
}
pub inline fn gst_pad_set_chain_list_function(p: anytype, f: anytype) @TypeOf(gst_pad_set_chain_list_function_full(p, f, NULL, NULL)) {
    return gst_pad_set_chain_list_function_full(p, f, NULL, NULL);
}
pub inline fn gst_pad_set_getrange_function(p: anytype, f: anytype) @TypeOf(gst_pad_set_getrange_function_full(p, f, NULL, NULL)) {
    return gst_pad_set_getrange_function_full(p, f, NULL, NULL);
}
pub inline fn gst_pad_set_event_function(p: anytype, f: anytype) @TypeOf(gst_pad_set_event_function_full(p, f, NULL, NULL)) {
    return gst_pad_set_event_function_full(p, f, NULL, NULL);
}
pub inline fn gst_pad_set_event_full_function(p: anytype, f: anytype) @TypeOf(gst_pad_set_event_full_function_full(p, f, NULL, NULL)) {
    return gst_pad_set_event_full_function_full(p, f, NULL, NULL);
}
pub inline fn gst_pad_set_link_function(p: anytype, f: anytype) @TypeOf(gst_pad_set_link_function_full(p, f, NULL, NULL)) {
    return gst_pad_set_link_function_full(p, f, NULL, NULL);
}
pub inline fn gst_pad_set_unlink_function(p: anytype, f: anytype) @TypeOf(gst_pad_set_unlink_function_full(p, f, NULL, NULL)) {
    return gst_pad_set_unlink_function_full(p, f, NULL, NULL);
}
pub inline fn gst_pad_set_iterate_internal_links_function(p: anytype, f: anytype) @TypeOf(gst_pad_set_iterate_internal_links_function_full(p, f, NULL, NULL)) {
    return gst_pad_set_iterate_internal_links_function_full(p, f, NULL, NULL);
}
pub inline fn gst_pad_set_query_function(p: anytype, f: anytype) @TypeOf(gst_pad_set_query_function_full(p, f, NULL, NULL)) {
    return gst_pad_set_query_function_full(p, f, NULL, NULL);
}
pub const __GST_BUS_H__ = "";
pub const GST_TYPE_BUS = gst_bus_get_type();
pub inline fn GST_BUS(bus: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(bus, GST_TYPE_BUS, GstBus)) {
    return G_TYPE_CHECK_INSTANCE_CAST(bus, GST_TYPE_BUS, GstBus);
}
pub inline fn GST_IS_BUS(bus: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(bus, GST_TYPE_BUS)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(bus, GST_TYPE_BUS);
}
pub inline fn GST_BUS_CLASS(bclass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(bclass, GST_TYPE_BUS, GstBusClass)) {
    return G_TYPE_CHECK_CLASS_CAST(bclass, GST_TYPE_BUS, GstBusClass);
}
pub inline fn GST_IS_BUS_CLASS(bclass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(bclass, GST_TYPE_BUS)) {
    return G_TYPE_CHECK_CLASS_TYPE(bclass, GST_TYPE_BUS);
}
pub inline fn GST_BUS_GET_CLASS(bus: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(bus, GST_TYPE_BUS, GstBusClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(bus, GST_TYPE_BUS, GstBusClass);
}
pub inline fn GST_BUS_CAST(bus: anytype) [*c]GstBus {
    return @import("std").zig.c_translation.cast([*c]GstBus, bus);
}
pub const __GST_ELEMENT_FACTORY_H__ = "";
pub const __GST_PLUGIN_H__ = "";
pub const __GST_MACROS_H__ = "";
pub const GST_CAN_INLINE = @as(c_int, 1);
pub const GST_PLUGIN_ERROR = gst_plugin_error_quark();
pub const GST_TYPE_PLUGIN = gst_plugin_get_type();
pub inline fn GST_IS_PLUGIN(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_PLUGIN)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_PLUGIN);
}
pub inline fn GST_IS_PLUGIN_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_PLUGIN)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_PLUGIN);
}
pub inline fn GST_PLUGIN_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_PLUGIN, GstPluginClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_PLUGIN, GstPluginClass);
}
pub inline fn GST_PLUGIN(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_PLUGIN, GstPlugin)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_PLUGIN, GstPlugin);
}
pub inline fn GST_PLUGIN_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_PLUGIN, GstPluginClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_PLUGIN, GstPluginClass);
}
pub inline fn GST_PLUGIN_CAST(obj: anytype) [*c]GstPlugin {
    return @import("std").zig.c_translation.cast([*c]GstPlugin, obj);
}
pub const __GST_PACKAGE_RELEASE_DATETIME = NULL;
pub const GST_LICENSE_UNKNOWN = "unknown";
pub const __GST_PLUGIN_FEATURE_H__ = "";
pub const GST_TYPE_PLUGIN_FEATURE = gst_plugin_feature_get_type();
pub inline fn GST_PLUGIN_FEATURE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_PLUGIN_FEATURE, GstPluginFeature)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_PLUGIN_FEATURE, GstPluginFeature);
}
pub inline fn GST_IS_PLUGIN_FEATURE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_PLUGIN_FEATURE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_PLUGIN_FEATURE);
}
pub inline fn GST_PLUGIN_FEATURE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_PLUGIN_FEATURE, GstPluginFeatureClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_PLUGIN_FEATURE, GstPluginFeatureClass);
}
pub inline fn GST_IS_PLUGIN_FEATURE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_PLUGIN_FEATURE)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_PLUGIN_FEATURE);
}
pub inline fn GST_PLUGIN_FEATURE_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_PLUGIN_FEATURE, GstPluginFeatureClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_PLUGIN_FEATURE, GstPluginFeatureClass);
}
pub inline fn GST_PLUGIN_FEATURE_CAST(obj: anytype) [*c]GstPluginFeature {
    return @import("std").zig.c_translation.cast([*c]GstPluginFeature, obj);
}
pub inline fn gst_plugin_feature_get_name(feature: anytype) @TypeOf(GST_OBJECT_NAME(feature)) {
    return GST_OBJECT_NAME(feature);
}
pub inline fn gst_plugin_feature_set_name(feature: anytype, name: anytype) @TypeOf(gst_object_set_name(GST_OBJECT_CAST(feature), name)) {
    return gst_object_set_name(GST_OBJECT_CAST(feature), name);
}
pub inline fn GST_PLUGIN_FEATURE_LIST_DEBUG(list: anytype) @TypeOf(gst_plugin_feature_list_debug(list)) {
    return gst_plugin_feature_list_debug(list);
}
pub const __GST_URI_H__ = "";
pub const GST_URI_ERROR = gst_uri_error_quark();
pub inline fn GST_URI_TYPE_IS_VALID(@"type": anytype) @TypeOf((@"type" == GST_URI_SRC) or (@"type" == GST_URI_SINK)) {
    return (@"type" == GST_URI_SRC) or (@"type" == GST_URI_SINK);
}
pub const GST_TYPE_URI_HANDLER = gst_uri_handler_get_type();
pub inline fn GST_URI_HANDLER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_URI_HANDLER, GstURIHandler)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_URI_HANDLER, GstURIHandler);
}
pub inline fn GST_IS_URI_HANDLER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_URI_HANDLER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_URI_HANDLER);
}
pub inline fn GST_URI_HANDLER_GET_INTERFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, GST_TYPE_URI_HANDLER, GstURIHandlerInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, GST_TYPE_URI_HANDLER, GstURIHandlerInterface);
}
pub const GST_TYPE_URI = gst_uri_get_type();
pub inline fn GST_IS_URI(obj: anytype) @TypeOf(GST_IS_MINI_OBJECT_TYPE(obj, GST_TYPE_URI)) {
    return GST_IS_MINI_OBJECT_TYPE(obj, GST_TYPE_URI);
}
pub inline fn GST_URI_CAST(obj: anytype) [*c]GstUri {
    return @import("std").zig.c_translation.cast([*c]GstUri, obj);
}
pub inline fn GST_URI(obj: anytype) @TypeOf(GST_URI_CAST(obj)) {
    return GST_URI_CAST(obj);
}
pub const GST_URI_NO_PORT = @as(c_int, 0);
pub const GST_TYPE_ELEMENT_FACTORY = gst_element_factory_get_type();
pub inline fn GST_ELEMENT_FACTORY(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_ELEMENT_FACTORY, GstElementFactory)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_ELEMENT_FACTORY, GstElementFactory);
}
pub inline fn GST_ELEMENT_FACTORY_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_ELEMENT_FACTORY, GstElementFactoryClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_ELEMENT_FACTORY, GstElementFactoryClass);
}
pub inline fn GST_IS_ELEMENT_FACTORY(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_ELEMENT_FACTORY)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_ELEMENT_FACTORY);
}
pub inline fn GST_IS_ELEMENT_FACTORY_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_ELEMENT_FACTORY)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_ELEMENT_FACTORY);
}
pub inline fn GST_ELEMENT_FACTORY_CAST(obj: anytype) [*c]GstElementFactory {
    return @import("std").zig.c_translation.cast([*c]GstElementFactory, obj);
}
pub const GST_ELEMENT_FACTORY_TYPE_DECODER = @import("std").zig.c_translation.cast(GstElementFactoryListType, G_GUINT64_CONSTANT(@as(c_int, 1)) << @as(c_int, 0));
pub const GST_ELEMENT_FACTORY_TYPE_ENCODER = @import("std").zig.c_translation.cast(GstElementFactoryListType, G_GUINT64_CONSTANT(@as(c_int, 1)) << @as(c_int, 1));
pub const GST_ELEMENT_FACTORY_TYPE_SINK = @import("std").zig.c_translation.cast(GstElementFactoryListType, G_GUINT64_CONSTANT(@as(c_int, 1)) << @as(c_int, 2));
pub const GST_ELEMENT_FACTORY_TYPE_SRC = @import("std").zig.c_translation.cast(GstElementFactoryListType, G_GUINT64_CONSTANT(@as(c_int, 1)) << @as(c_int, 3));
pub const GST_ELEMENT_FACTORY_TYPE_MUXER = @import("std").zig.c_translation.cast(GstElementFactoryListType, G_GUINT64_CONSTANT(@as(c_int, 1)) << @as(c_int, 4));
pub const GST_ELEMENT_FACTORY_TYPE_DEMUXER = @import("std").zig.c_translation.cast(GstElementFactoryListType, G_GUINT64_CONSTANT(@as(c_int, 1)) << @as(c_int, 5));
pub const GST_ELEMENT_FACTORY_TYPE_PARSER = @import("std").zig.c_translation.cast(GstElementFactoryListType, G_GUINT64_CONSTANT(@as(c_int, 1)) << @as(c_int, 6));
pub const GST_ELEMENT_FACTORY_TYPE_PAYLOADER = @import("std").zig.c_translation.cast(GstElementFactoryListType, G_GUINT64_CONSTANT(@as(c_int, 1)) << @as(c_int, 7));
pub const GST_ELEMENT_FACTORY_TYPE_DEPAYLOADER = @import("std").zig.c_translation.cast(GstElementFactoryListType, G_GUINT64_CONSTANT(@as(c_int, 1)) << @as(c_int, 8));
pub const GST_ELEMENT_FACTORY_TYPE_FORMATTER = @import("std").zig.c_translation.cast(GstElementFactoryListType, G_GUINT64_CONSTANT(@as(c_int, 1)) << @as(c_int, 9));
pub const GST_ELEMENT_FACTORY_TYPE_DECRYPTOR = @import("std").zig.c_translation.cast(GstElementFactoryListType, G_GUINT64_CONSTANT(@as(c_int, 1)) << @as(c_int, 10));
pub const GST_ELEMENT_FACTORY_TYPE_ENCRYPTOR = @import("std").zig.c_translation.cast(GstElementFactoryListType, G_GUINT64_CONSTANT(@as(c_int, 1)) << @as(c_int, 11));
pub const GST_ELEMENT_FACTORY_TYPE_HARDWARE = @import("std").zig.c_translation.cast(GstElementFactoryListType, G_GUINT64_CONSTANT(@as(c_int, 1)) << @as(c_int, 12));
pub const GST_ELEMENT_FACTORY_TYPE_MAX_ELEMENTS = @import("std").zig.c_translation.cast(GstElementFactoryListType, G_GUINT64_CONSTANT(@as(c_int, 1)) << @as(c_int, 48));
pub const GST_ELEMENT_FACTORY_TYPE_MEDIA_VIDEO = @import("std").zig.c_translation.cast(GstElementFactoryListType, G_GUINT64_CONSTANT(@as(c_int, 1)) << @as(c_int, 49));
pub const GST_ELEMENT_FACTORY_TYPE_MEDIA_AUDIO = @import("std").zig.c_translation.cast(GstElementFactoryListType, G_GUINT64_CONSTANT(@as(c_int, 1)) << @as(c_int, 50));
pub const GST_ELEMENT_FACTORY_TYPE_MEDIA_IMAGE = @import("std").zig.c_translation.cast(GstElementFactoryListType, G_GUINT64_CONSTANT(@as(c_int, 1)) << @as(c_int, 51));
pub const GST_ELEMENT_FACTORY_TYPE_MEDIA_SUBTITLE = @import("std").zig.c_translation.cast(GstElementFactoryListType, G_GUINT64_CONSTANT(@as(c_int, 1)) << @as(c_int, 52));
pub const GST_ELEMENT_FACTORY_TYPE_MEDIA_METADATA = @import("std").zig.c_translation.cast(GstElementFactoryListType, G_GUINT64_CONSTANT(@as(c_int, 1)) << @as(c_int, 53));
pub const GST_ELEMENT_FACTORY_TYPE_ANY = @import("std").zig.c_translation.cast(GstElementFactoryListType, (G_GUINT64_CONSTANT(@as(c_int, 1)) << @as(c_int, 49)) - @as(c_int, 1));
pub const GST_ELEMENT_FACTORY_TYPE_MEDIA_ANY = @import("std").zig.c_translation.cast(GstElementFactoryListType, ~G_GUINT64_CONSTANT(@as(c_int, 0)) << @as(c_int, 48));
pub const GST_ELEMENT_FACTORY_TYPE_VIDEO_ENCODER = @import("std").zig.c_translation.cast(GstElementFactoryListType, (GST_ELEMENT_FACTORY_TYPE_ENCODER | GST_ELEMENT_FACTORY_TYPE_MEDIA_VIDEO) | GST_ELEMENT_FACTORY_TYPE_MEDIA_IMAGE);
pub const GST_ELEMENT_FACTORY_TYPE_AUDIO_ENCODER = @import("std").zig.c_translation.cast(GstElementFactoryListType, GST_ELEMENT_FACTORY_TYPE_ENCODER | GST_ELEMENT_FACTORY_TYPE_MEDIA_AUDIO);
pub const GST_ELEMENT_FACTORY_TYPE_AUDIOVIDEO_SINKS = @import("std").zig.c_translation.cast(GstElementFactoryListType, ((GST_ELEMENT_FACTORY_TYPE_SINK | GST_ELEMENT_FACTORY_TYPE_MEDIA_AUDIO) | GST_ELEMENT_FACTORY_TYPE_MEDIA_VIDEO) | GST_ELEMENT_FACTORY_TYPE_MEDIA_IMAGE);
pub const GST_ELEMENT_FACTORY_TYPE_DECODABLE = @import("std").zig.c_translation.cast(GstElementFactoryListType, (((GST_ELEMENT_FACTORY_TYPE_DECODER | GST_ELEMENT_FACTORY_TYPE_DEMUXER) | GST_ELEMENT_FACTORY_TYPE_DEPAYLOADER) | GST_ELEMENT_FACTORY_TYPE_PARSER) | GST_ELEMENT_FACTORY_TYPE_DECRYPTOR);
pub const GST_ELEMENT_FACTORY_KLASS_DECODER = "Decoder";
pub const GST_ELEMENT_FACTORY_KLASS_ENCODER = "Encoder";
pub const GST_ELEMENT_FACTORY_KLASS_SINK = "Sink";
pub const GST_ELEMENT_FACTORY_KLASS_SRC = "Source";
pub const GST_ELEMENT_FACTORY_KLASS_MUXER = "Muxer";
pub const GST_ELEMENT_FACTORY_KLASS_DEMUXER = "Demuxer";
pub const GST_ELEMENT_FACTORY_KLASS_PARSER = "Parser";
pub const GST_ELEMENT_FACTORY_KLASS_PAYLOADER = "Payloader";
pub const GST_ELEMENT_FACTORY_KLASS_DEPAYLOADER = "Depayloader";
pub const GST_ELEMENT_FACTORY_KLASS_FORMATTER = "Formatter";
pub const GST_ELEMENT_FACTORY_KLASS_DECRYPTOR = "Decryptor";
pub const GST_ELEMENT_FACTORY_KLASS_ENCRYPTOR = "Encryptor";
pub const GST_ELEMENT_FACTORY_KLASS_MEDIA_VIDEO = "Video";
pub const GST_ELEMENT_FACTORY_KLASS_MEDIA_AUDIO = "Audio";
pub const GST_ELEMENT_FACTORY_KLASS_MEDIA_IMAGE = "Image";
pub const GST_ELEMENT_FACTORY_KLASS_MEDIA_SUBTITLE = "Subtitle";
pub const GST_ELEMENT_FACTORY_KLASS_MEDIA_METADATA = "Metadata";
pub const GST_ELEMENT_FACTORY_KLASS_HARDWARE = "Hardware";
pub inline fn GST_STATE(elem: anytype) @TypeOf(GST_ELEMENT_CAST(elem).*.current_state) {
    return GST_ELEMENT_CAST(elem).*.current_state;
}
pub inline fn GST_STATE_NEXT(elem: anytype) @TypeOf(GST_ELEMENT_CAST(elem).*.next_state) {
    return GST_ELEMENT_CAST(elem).*.next_state;
}
pub inline fn GST_STATE_PENDING(elem: anytype) @TypeOf(GST_ELEMENT_CAST(elem).*.pending_state) {
    return GST_ELEMENT_CAST(elem).*.pending_state;
}
pub inline fn GST_STATE_TARGET(elem: anytype) @TypeOf(GST_ELEMENT_CAST(elem).*.target_state) {
    return GST_ELEMENT_CAST(elem).*.target_state;
}
pub inline fn GST_STATE_RETURN(elem: anytype) @TypeOf(GST_ELEMENT_CAST(elem).*.last_return) {
    return GST_ELEMENT_CAST(elem).*.last_return;
}
pub inline fn __GST_SIGN(val: anytype) @TypeOf(if (val < @as(c_int, 0)) -@as(c_int, 1) else if (val > @as(c_int, 0)) @as(c_int, 1) else @as(c_int, 0)) {
    return if (val < @as(c_int, 0)) -@as(c_int, 1) else if (val > @as(c_int, 0)) @as(c_int, 1) else @as(c_int, 0);
}
pub inline fn GST_STATE_GET_NEXT(cur: anytype, pending: anytype) GstState {
    return @import("std").zig.c_translation.cast(GstState, cur + __GST_SIGN(@import("std").zig.c_translation.cast(gint, pending) - @import("std").zig.c_translation.cast(gint, cur)));
}
pub inline fn GST_STATE_TRANSITION(cur: anytype, next: anytype) GstStateChange {
    return @import("std").zig.c_translation.cast(GstStateChange, (cur << @as(c_int, 3)) | next);
}
pub inline fn GST_STATE_TRANSITION_CURRENT(trans: anytype) GstState {
    return @import("std").zig.c_translation.cast(GstState, trans >> @as(c_int, 3));
}
pub inline fn GST_STATE_TRANSITION_NEXT(trans: anytype) GstState {
    return @import("std").zig.c_translation.cast(GstState, trans & @as(c_int, 0x7));
}
pub inline fn GST_ELEMENT_IS_LOCKED_STATE(elem: anytype) @TypeOf(GST_OBJECT_FLAG_IS_SET(elem, GST_ELEMENT_FLAG_LOCKED_STATE)) {
    return GST_OBJECT_FLAG_IS_SET(elem, GST_ELEMENT_FLAG_LOCKED_STATE);
}
pub inline fn GST_ELEMENT_NAME(elem: anytype) @TypeOf(GST_OBJECT_NAME(elem)) {
    return GST_OBJECT_NAME(elem);
}
pub inline fn GST_ELEMENT_PARENT(elem: anytype) @TypeOf(GST_ELEMENT_CAST(GST_OBJECT_PARENT(elem))) {
    return GST_ELEMENT_CAST(GST_OBJECT_PARENT(elem));
}
pub inline fn GST_ELEMENT_BUS(elem: anytype) @TypeOf(GST_ELEMENT_CAST(elem).*.bus) {
    return GST_ELEMENT_CAST(elem).*.bus;
}
pub inline fn GST_ELEMENT_CLOCK(elem: anytype) @TypeOf(GST_ELEMENT_CAST(elem).*.clock) {
    return GST_ELEMENT_CAST(elem).*.clock;
}
pub inline fn GST_ELEMENT_PADS(elem: anytype) @TypeOf(GST_ELEMENT_CAST(elem).*.pads) {
    return GST_ELEMENT_CAST(elem).*.pads;
}
pub inline fn GST_ELEMENT_START_TIME(elem: anytype) @TypeOf(GST_ELEMENT_CAST(elem).*.start_time) {
    return GST_ELEMENT_CAST(elem).*.start_time;
}
pub inline fn GST_ELEMENT_MESSAGE_MAKE_DETAILS(args: anytype) @TypeOf(gst_make_element_message_details ++ args) {
    return gst_make_element_message_details ++ args;
}
pub inline fn GST_STATE_GET_LOCK(elem: anytype) @TypeOf(&GST_ELEMENT_CAST(elem).*.state_lock) {
    return &GST_ELEMENT_CAST(elem).*.state_lock;
}
pub inline fn GST_STATE_GET_COND(elem: anytype) @TypeOf(&GST_ELEMENT_CAST(elem).*.state_cond) {
    return &GST_ELEMENT_CAST(elem).*.state_cond;
}
pub inline fn GST_STATE_LOCK(elem: anytype) @TypeOf(g_rec_mutex_lock(GST_STATE_GET_LOCK(elem))) {
    return g_rec_mutex_lock(GST_STATE_GET_LOCK(elem));
}
pub inline fn GST_STATE_TRYLOCK(elem: anytype) @TypeOf(g_rec_mutex_trylock(GST_STATE_GET_LOCK(elem))) {
    return g_rec_mutex_trylock(GST_STATE_GET_LOCK(elem));
}
pub inline fn GST_STATE_UNLOCK(elem: anytype) @TypeOf(g_rec_mutex_unlock(GST_STATE_GET_LOCK(elem))) {
    return g_rec_mutex_unlock(GST_STATE_GET_LOCK(elem));
}
pub inline fn GST_STATE_WAIT(elem: anytype) @TypeOf(g_cond_wait(GST_STATE_GET_COND(elem), GST_OBJECT_GET_LOCK(elem))) {
    return g_cond_wait(GST_STATE_GET_COND(elem), GST_OBJECT_GET_LOCK(elem));
}
pub inline fn GST_STATE_WAIT_UNTIL(elem: anytype, end_time: anytype) @TypeOf(g_cond_wait_until(GST_STATE_GET_COND(elem), GST_OBJECT_GET_LOCK(elem), end_time)) {
    return g_cond_wait_until(GST_STATE_GET_COND(elem), GST_OBJECT_GET_LOCK(elem), end_time);
}
pub inline fn gst_element_get_name(elem: anytype) @TypeOf(gst_object_get_name(GST_OBJECT_CAST(elem))) {
    return gst_object_get_name(GST_OBJECT_CAST(elem));
}
pub inline fn gst_element_set_name(elem: anytype, name: anytype) @TypeOf(gst_object_set_name(GST_OBJECT_CAST(elem), name)) {
    return gst_object_set_name(GST_OBJECT_CAST(elem), name);
}
pub inline fn gst_element_get_parent(elem: anytype) @TypeOf(gst_object_get_parent(GST_OBJECT_CAST(elem))) {
    return gst_object_get_parent(GST_OBJECT_CAST(elem));
}
pub inline fn gst_element_set_parent(elem: anytype, parent: anytype) @TypeOf(gst_object_set_parent(GST_OBJECT_CAST(elem), parent)) {
    return gst_object_set_parent(GST_OBJECT_CAST(elem), parent);
}
pub const GST_TYPE_BIN = gst_bin_get_type();
pub inline fn GST_IS_BIN(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_BIN)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_BIN);
}
pub inline fn GST_IS_BIN_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_BIN)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_BIN);
}
pub inline fn GST_BIN_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_BIN, GstBinClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_BIN, GstBinClass);
}
pub inline fn GST_BIN(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_BIN, GstBin)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_BIN, GstBin);
}
pub inline fn GST_BIN_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_BIN, GstBinClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_BIN, GstBinClass);
}
pub inline fn GST_BIN_CAST(obj: anytype) [*c]GstBin {
    return @import("std").zig.c_translation.cast([*c]GstBin, obj);
}
pub inline fn GST_BIN_IS_NO_RESYNC(bin: anytype) @TypeOf(GST_OBJECT_FLAG_IS_SET(bin, GST_BIN_FLAG_NO_RESYNC)) {
    return GST_OBJECT_FLAG_IS_SET(bin, GST_BIN_FLAG_NO_RESYNC);
}
pub inline fn GST_BIN_NUMCHILDREN(bin: anytype) @TypeOf(GST_BIN_CAST(bin).*.numchildren) {
    return GST_BIN_CAST(bin).*.numchildren;
}
pub inline fn GST_BIN_CHILDREN(bin: anytype) @TypeOf(GST_BIN_CAST(bin).*.children) {
    return GST_BIN_CAST(bin).*.children;
}
pub inline fn GST_BIN_CHILDREN_COOKIE(bin: anytype) @TypeOf(GST_BIN_CAST(bin).*.children_cookie) {
    return GST_BIN_CAST(bin).*.children_cookie;
}
pub const __GST_BUFFER_POOL_H__ = "";
pub const GST_TYPE_BUFFER_POOL = gst_buffer_pool_get_type();
pub inline fn GST_IS_BUFFER_POOL(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_BUFFER_POOL)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_BUFFER_POOL);
}
pub inline fn GST_IS_BUFFER_POOL_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_BUFFER_POOL)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_BUFFER_POOL);
}
pub inline fn GST_BUFFER_POOL_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_BUFFER_POOL, GstBufferPoolClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_BUFFER_POOL, GstBufferPoolClass);
}
pub inline fn GST_BUFFER_POOL(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_BUFFER_POOL, GstBufferPool)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_BUFFER_POOL, GstBufferPool);
}
pub inline fn GST_BUFFER_POOL_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_BUFFER_POOL, GstBufferPoolClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_BUFFER_POOL, GstBufferPoolClass);
}
pub inline fn GST_BUFFER_POOL_CAST(obj: anytype) [*c]GstBufferPool {
    return @import("std").zig.c_translation.cast([*c]GstBufferPool, obj);
}
pub inline fn GST_BUFFER_POOL_IS_FLUSHING(pool: anytype) @TypeOf(g_atomic_int_get(&pool.*.flushing)) {
    return g_atomic_int_get(&pool.*.flushing);
}
pub const __GST_CHILD_PROXY_H__ = "";
pub const GST_TYPE_CHILD_PROXY = gst_child_proxy_get_type();
pub inline fn GST_CHILD_PROXY(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_CHILD_PROXY, GstChildProxy)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_CHILD_PROXY, GstChildProxy);
}
pub inline fn GST_IS_CHILD_PROXY(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_CHILD_PROXY)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_CHILD_PROXY);
}
pub inline fn GST_CHILD_PROXY_GET_INTERFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, GST_TYPE_CHILD_PROXY, GstChildProxyInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, GST_TYPE_CHILD_PROXY, GstChildProxyInterface);
}
pub const __GSTDEBUGUTILS_H__ = "";
pub inline fn GST_DEBUG_BIN_TO_DOT_FILE(bin: anytype, details: anytype, file_name: anytype) @TypeOf(gst_debug_bin_to_dot_file(bin, details, file_name)) {
    return gst_debug_bin_to_dot_file(bin, details, file_name);
}
pub inline fn GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS(bin: anytype, details: anytype, file_name: anytype) @TypeOf(gst_debug_bin_to_dot_file_with_ts(bin, details, file_name)) {
    return gst_debug_bin_to_dot_file_with_ts(bin, details, file_name);
}
pub const __GST_DEVICE_MONITOR_H__ = "";
pub const __GST_DEVICE_PROVIDER_H__ = "";
pub const __GST_DEVICE_PROVIDER_FACTORY_H__ = "";
pub const GST_TYPE_DEVICE_PROVIDER_FACTORY = gst_device_provider_factory_get_type();
pub inline fn GST_DEVICE_PROVIDER_FACTORY(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_DEVICE_PROVIDER_FACTORY, GstDeviceProviderFactory)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_DEVICE_PROVIDER_FACTORY, GstDeviceProviderFactory);
}
pub inline fn GST_DEVICE_PROVIDER_FACTORY_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_DEVICE_PROVIDER_FACTORY, GstDeviceProviderFactoryClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_DEVICE_PROVIDER_FACTORY, GstDeviceProviderFactoryClass);
}
pub inline fn GST_IS_DEVICE_PROVIDER_FACTORY(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_DEVICE_PROVIDER_FACTORY)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_DEVICE_PROVIDER_FACTORY);
}
pub inline fn GST_IS_DEVICE_PROVIDER_FACTORY_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_DEVICE_PROVIDER_FACTORY)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_DEVICE_PROVIDER_FACTORY);
}
pub inline fn GST_DEVICE_PROVIDER_FACTORY_CAST(obj: anytype) [*c]GstDeviceProviderFactory {
    return @import("std").zig.c_translation.cast([*c]GstDeviceProviderFactory, obj);
}
pub const GST_TYPE_DEVICE_PROVIDER = gst_device_provider_get_type();
pub inline fn GST_IS_DEVICE_PROVIDER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_DEVICE_PROVIDER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_DEVICE_PROVIDER);
}
pub inline fn GST_IS_DEVICE_PROVIDER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_DEVICE_PROVIDER)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_DEVICE_PROVIDER);
}
pub inline fn GST_DEVICE_PROVIDER_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_DEVICE_PROVIDER, GstDeviceProviderClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_DEVICE_PROVIDER, GstDeviceProviderClass);
}
pub inline fn GST_DEVICE_PROVIDER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_DEVICE_PROVIDER, GstDeviceProvider)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_DEVICE_PROVIDER, GstDeviceProvider);
}
pub inline fn GST_DEVICE_PROVIDER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_DEVICE_PROVIDER, GstDeviceProviderClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_DEVICE_PROVIDER, GstDeviceProviderClass);
}
pub inline fn GST_DEVICE_PROVIDER_CAST(obj: anytype) [*c]GstDeviceProvider {
    return @import("std").zig.c_translation.cast([*c]GstDeviceProvider, obj);
}
pub const GST_TYPE_DEVICE_MONITOR = gst_device_monitor_get_type();
pub inline fn GST_IS_DEVICE_MONITOR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_DEVICE_MONITOR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_DEVICE_MONITOR);
}
pub inline fn GST_IS_DEVICE_MONITOR_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_DEVICE_MONITOR)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_DEVICE_MONITOR);
}
pub inline fn GST_DEVICE_MONITOR_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_DEVICE_MONITOR, GstDeviceMonitorClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_DEVICE_MONITOR, GstDeviceMonitorClass);
}
pub inline fn GST_DEVICE_MONITOR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_DEVICE_MONITOR, GstDeviceMonitor)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_DEVICE_MONITOR, GstDeviceMonitor);
}
pub inline fn GST_DEVICE_MONITOR_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_DEVICE_MONITOR, GstDeviceMonitorClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_DEVICE_MONITOR, GstDeviceMonitorClass);
}
pub inline fn GST_DEVICE_MONITOR_CAST(obj: anytype) [*c]GstDeviceMonitor {
    return @import("std").zig.c_translation.cast([*c]GstDeviceMonitor, obj);
}
pub const __GST_DYNAMIC_TYPE_FACTORY_H__ = "";
pub const GST_TYPE_DYNAMIC_TYPE_FACTORY = gst_dynamic_type_factory_get_type();
pub inline fn GST_DYNAMIC_TYPE_FACTORY(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_DYNAMIC_TYPE_FACTORY, GstDynamicTypeFactory)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_DYNAMIC_TYPE_FACTORY, GstDynamicTypeFactory);
}
pub inline fn GST_DYNAMIC_TYPE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_DYNAMIC_TYPE_FACTORY, GstDynamicTypeFactoryClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_DYNAMIC_TYPE_FACTORY, GstDynamicTypeFactoryClass);
}
pub inline fn GST_IS_DYNAMIC_TYPE_FACTORY(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_DYNAMIC_TYPE_FACTORY)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_DYNAMIC_TYPE_FACTORY);
}
pub inline fn GST_IS_DYNAMIC_TYPE_FACTORY_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_DYNAMIC_TYPE_FACTORY)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_DYNAMIC_TYPE_FACTORY);
}
pub inline fn GST_DYNAMIC_TYPE_FACTORY_CAST(obj: anytype) [*c]GstDynamicTypeFactory {
    return @import("std").zig.c_translation.cast([*c]GstDynamicTypeFactory, obj);
}
pub const __GST_ELEMENT_METADATA_H__ = "";
pub const GST_ELEMENT_METADATA_LONGNAME = "long-name";
pub const GST_ELEMENT_METADATA_KLASS = "klass";
pub const GST_ELEMENT_METADATA_DESCRIPTION = "description";
pub const GST_ELEMENT_METADATA_AUTHOR = "author";
pub const GST_ELEMENT_METADATA_DOC_URI = "doc-uri";
pub const GST_ELEMENT_METADATA_ICON_NAME = "icon-name";
pub const __GST_ERROR_H__ = "";
pub const GST_LIBRARY_ERROR = gst_library_error_quark();
pub const GST_RESOURCE_ERROR = gst_resource_error_quark();
pub const GST_CORE_ERROR = gst_core_error_quark();
pub const GST_STREAM_ERROR = gst_stream_error_quark();
pub const GST_ERROR_SYSTEM = blk: {
    _ = "system error: %s";
    break :blk g_strerror(errno);
};
pub const __GST_GHOST_PAD_H__ = "";
pub const GST_TYPE_PROXY_PAD = gst_proxy_pad_get_type();
pub inline fn GST_IS_PROXY_PAD(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_PROXY_PAD)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_PROXY_PAD);
}
pub inline fn GST_IS_PROXY_PAD_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_PROXY_PAD)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_PROXY_PAD);
}
pub inline fn GST_PROXY_PAD(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_PROXY_PAD, GstProxyPad)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_PROXY_PAD, GstProxyPad);
}
pub inline fn GST_PROXY_PAD_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_PROXY_PAD, GstProxyPadClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_PROXY_PAD, GstProxyPadClass);
}
pub const GST_TYPE_GHOST_PAD = gst_ghost_pad_get_type();
pub inline fn GST_IS_GHOST_PAD(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_GHOST_PAD)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_GHOST_PAD);
}
pub inline fn GST_IS_GHOST_PAD_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_GHOST_PAD)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_GHOST_PAD);
}
pub inline fn GST_GHOST_PAD(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_GHOST_PAD, GstGhostPad)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_GHOST_PAD, GstGhostPad);
}
pub inline fn GST_GHOST_PAD_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_GHOST_PAD, GstGhostPadClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_GHOST_PAD, GstGhostPadClass);
}
pub inline fn GST_GHOST_PAD_CAST(obj: anytype) [*c]GstGhostPad {
    return @import("std").zig.c_translation.cast([*c]GstGhostPad, obj);
}
pub const __GSTINFO_H__ = "";
pub const GST_LEVEL_DEFAULT = GST_LEVEL_NONE;
pub const GST_LEVEL_MAX = GST_LEVEL_COUNT;
pub const GST_DEBUG_FG_MASK = @as(c_int, 0x000F);
pub const GST_DEBUG_BG_MASK = @as(c_int, 0x00F0);
pub const GST_DEBUG_FORMAT_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFF00, .hexadecimal);
pub inline fn GST_STR_NULL(str: anytype) @TypeOf(if (str) str else "(NULL)") {
    return if (str) str else "(NULL)";
}
pub inline fn GST_DEBUG_PAD_NAME(pad: anytype) @TypeOf(if (pad != NULL) GST_STR_NULL(GST_OBJECT_NAME(pad)) else "''") {
    return blk: {
        _ = if (pad != NULL) if (GST_OBJECT_PARENT(pad) != NULL) GST_STR_NULL(GST_OBJECT_NAME(GST_OBJECT_PARENT(pad))) else "''" else "''";
        break :blk if (pad != NULL) GST_STR_NULL(GST_OBJECT_NAME(pad)) else "''";
    };
}
pub const GST_PTR_FORMAT = "p\x07A";
pub const GST_SEGMENT_FORMAT = "p\x07B";
pub const GST_TIMEP_FORMAT = "p\x07T";
pub const GST_STIMEP_FORMAT = "p\x07S";
pub inline fn GST_CAT_MEMDUMP_OBJECT(cat: anytype, obj: anytype, msg: anytype, data: anytype, length: anytype) @TypeOf(__GST_CAT_MEMDUMP_LOG(cat, obj, msg, data, length)) {
    return __GST_CAT_MEMDUMP_LOG(cat, obj, msg, data, length);
}
pub inline fn GST_CAT_MEMDUMP(cat: anytype, msg: anytype, data: anytype, length: anytype) @TypeOf(__GST_CAT_MEMDUMP_LOG(cat, NULL, msg, data, length)) {
    return __GST_CAT_MEMDUMP_LOG(cat, NULL, msg, data, length);
}
pub inline fn GST_MEMDUMP_OBJECT(obj: anytype, msg: anytype, data: anytype, length: anytype) @TypeOf(__GST_CAT_MEMDUMP_LOG(GST_CAT_DEFAULT, obj, msg, data, length)) {
    return __GST_CAT_MEMDUMP_LOG(GST_CAT_DEFAULT, obj, msg, data, length);
}
pub inline fn GST_MEMDUMP(msg: anytype, data: anytype, length: anytype) @TypeOf(__GST_CAT_MEMDUMP_LOG(GST_CAT_DEFAULT, NULL, msg, data, length)) {
    return __GST_CAT_MEMDUMP_LOG(GST_CAT_DEFAULT, NULL, msg, data, length);
}
pub inline fn GST_DEBUG_FUNCPTR_NAME(ptr: anytype) @TypeOf(_gst_debug_nameof_funcptr(@import("std").zig.c_translation.cast(GstDebugFuncPtr, ptr))) {
    return _gst_debug_nameof_funcptr(@import("std").zig.c_translation.cast(GstDebugFuncPtr, ptr));
}
pub const __GST_PARAMSPECS_H__ = "";
pub const __GST_VALUE_H__ = "";
pub inline fn GST_MAKE_FOURCC(a: anytype, b: anytype, c: anytype, d: anytype) @TypeOf(((@import("std").zig.c_translation.cast(guint32, a) | (@import("std").zig.c_translation.cast(guint32, b) << @as(c_int, 8))) | (@import("std").zig.c_translation.cast(guint32, c) << @as(c_int, 16))) | (@import("std").zig.c_translation.cast(guint32, d) << @as(c_int, 24))) {
    return ((@import("std").zig.c_translation.cast(guint32, a) | (@import("std").zig.c_translation.cast(guint32, b) << @as(c_int, 8))) | (@import("std").zig.c_translation.cast(guint32, c) << @as(c_int, 16))) | (@import("std").zig.c_translation.cast(guint32, d) << @as(c_int, 24));
}
pub inline fn GST_STR_FOURCC(f: anytype) guint32 {
    return @import("std").zig.c_translation.cast(guint32, ((f[@as(c_int, 0)] | (f[@as(c_int, 1)] << @as(c_int, 8))) | (f[@as(c_int, 2)] << @as(c_int, 16))) | (f[@as(c_int, 3)] << @as(c_int, 24)));
}
pub const GST_FOURCC_FORMAT = "c%c%c%c";
pub inline fn __GST_PRINT_CHAR(c: anytype) @TypeOf(if (g_ascii_isprint(c)) c else '.') {
    return if (g_ascii_isprint(c)) c else '.';
}
pub inline fn GST_FOURCC_ARGS(fourcc: anytype) @TypeOf(__GST_PRINT_CHAR((fourcc >> @as(c_int, 24)) & @as(c_int, 0xff))) {
    return blk: {
        _ = __GST_PRINT_CHAR(fourcc & @as(c_int, 0xff));
        _ = __GST_PRINT_CHAR((fourcc >> @as(c_int, 8)) & @as(c_int, 0xff));
        _ = __GST_PRINT_CHAR((fourcc >> @as(c_int, 16)) & @as(c_int, 0xff));
        break :blk __GST_PRINT_CHAR((fourcc >> @as(c_int, 24)) & @as(c_int, 0xff));
    };
}
pub inline fn GST_VALUE_HOLDS_INT_RANGE(x: anytype) @TypeOf((@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_int_range_type)) {
    return (@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_int_range_type);
}
pub inline fn GST_VALUE_HOLDS_INT64_RANGE(x: anytype) @TypeOf((@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_int64_range_type)) {
    return (@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_int64_range_type);
}
pub inline fn GST_VALUE_HOLDS_DOUBLE_RANGE(x: anytype) @TypeOf((@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_double_range_type)) {
    return (@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_double_range_type);
}
pub inline fn GST_VALUE_HOLDS_FRACTION_RANGE(x: anytype) @TypeOf((@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_fraction_range_type)) {
    return (@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_fraction_range_type);
}
pub inline fn GST_VALUE_HOLDS_LIST(x: anytype) @TypeOf((@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_value_list_type)) {
    return (@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_value_list_type);
}
pub inline fn GST_VALUE_HOLDS_ARRAY(x: anytype) @TypeOf((@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_value_array_type)) {
    return (@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_value_array_type);
}
pub inline fn GST_VALUE_HOLDS_CAPS(x: anytype) @TypeOf((@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_caps_type)) {
    return (@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_caps_type);
}
pub inline fn GST_VALUE_HOLDS_STRUCTURE(x: anytype) @TypeOf((@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_structure_type)) {
    return (@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_structure_type);
}
pub inline fn GST_VALUE_HOLDS_CAPS_FEATURES(x: anytype) @TypeOf((@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_caps_features_type)) {
    return (@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_caps_features_type);
}
pub inline fn GST_VALUE_HOLDS_BUFFER(x: anytype) @TypeOf((@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_buffer_type)) {
    return (@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_buffer_type);
}
pub inline fn GST_VALUE_HOLDS_SAMPLE(x: anytype) @TypeOf((@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_sample_type)) {
    return (@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_sample_type);
}
pub inline fn GST_VALUE_HOLDS_FRACTION(x: anytype) @TypeOf((@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_fraction_type)) {
    return (@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_fraction_type);
}
pub inline fn GST_VALUE_HOLDS_DATE_TIME(x: anytype) @TypeOf((@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_date_time_type)) {
    return (@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_date_time_type);
}
pub inline fn GST_VALUE_HOLDS_BITMASK(x: anytype) @TypeOf((@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_bitmask_type)) {
    return (@import("std").zig.c_translation.cast(gpointer, x) != NULL) and (G_VALUE_TYPE(x) == _gst_bitmask_type);
}
pub inline fn GST_VALUE_HOLDS_FLAG_SET(x: anytype) @TypeOf(G_TYPE_FUNDAMENTAL(G_VALUE_TYPE(x)) == GST_TYPE_FLAG_SET) {
    return G_TYPE_FUNDAMENTAL(G_VALUE_TYPE(x)) == GST_TYPE_FLAG_SET;
}
pub const GST_FLAG_SET_MASK_EXACT = @import("std").zig.c_translation.cast(guint, -@as(c_int, 1));
pub const GST_TYPE_INT_RANGE = _gst_int_range_type;
pub const GST_TYPE_INT64_RANGE = _gst_int64_range_type;
pub const GST_TYPE_DOUBLE_RANGE = _gst_double_range_type;
pub const GST_TYPE_FRACTION_RANGE = _gst_fraction_range_type;
pub const GST_TYPE_LIST = _gst_value_list_type;
pub const GST_TYPE_ARRAY = _gst_value_array_type;
pub const GST_TYPE_FRACTION = _gst_fraction_type;
pub const GST_TYPE_BITMASK = _gst_bitmask_type;
pub const GST_TYPE_FLAG_SET = _gst_flagset_type;
pub const GST_TYPE_G_THREAD = gst_g_thread_get_type();
pub const GST_VALUE_LESS_THAN = -@as(c_int, 1);
pub const GST_VALUE_EQUAL = @as(c_int, 0);
pub const GST_VALUE_GREATER_THAN = @as(c_int, 1);
pub const GST_VALUE_UNORDERED = @as(c_int, 2);
pub const GST_PARAM_CONTROLLABLE = @as(c_int, 1) << (G_PARAM_USER_SHIFT + @as(c_int, 1));
pub const GST_PARAM_MUTABLE_READY = @as(c_int, 1) << (G_PARAM_USER_SHIFT + @as(c_int, 2));
pub const GST_PARAM_MUTABLE_PAUSED = @as(c_int, 1) << (G_PARAM_USER_SHIFT + @as(c_int, 3));
pub const GST_PARAM_MUTABLE_PLAYING = @as(c_int, 1) << (G_PARAM_USER_SHIFT + @as(c_int, 4));
pub const GST_PARAM_DOC_SHOW_DEFAULT = @as(c_int, 1) << (G_PARAM_USER_SHIFT + @as(c_int, 5));
pub const GST_PARAM_CONDITIONALLY_AVAILABLE = @as(c_int, 1) << (G_PARAM_USER_SHIFT + @as(c_int, 6));
pub const GST_PARAM_USER_SHIFT = @as(c_int, 1) << (G_PARAM_USER_SHIFT + @as(c_int, 8));
pub const GST_TYPE_PARAM_FRACTION = gst_param_spec_fraction_get_type();
pub inline fn GST_IS_PARAM_SPEC_FRACTION(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, GST_TYPE_PARAM_FRACTION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, GST_TYPE_PARAM_FRACTION);
}
pub inline fn GST_PARAM_SPEC_FRACTION(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, GST_TYPE_PARAM_FRACTION, GstParamSpecFraction)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, GST_TYPE_PARAM_FRACTION, GstParamSpecFraction);
}
pub const GST_TYPE_PARAM_ARRAY_LIST = gst_param_spec_array_get_type();
pub inline fn GST_IS_PARAM_SPEC_ARRAY_LIST(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, GST_TYPE_PARAM_ARRAY_LIST)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, GST_TYPE_PARAM_ARRAY_LIST);
}
pub inline fn GST_PARAM_SPEC_ARRAY_LIST(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, GST_TYPE_PARAM_ARRAY_LIST, GstParamSpecArray)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, GST_TYPE_PARAM_ARRAY_LIST, GstParamSpecArray);
}
pub const __GST_PIPELINE_H__ = "";
pub const GST_TYPE_PIPELINE = gst_pipeline_get_type();
pub inline fn GST_PIPELINE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_PIPELINE, GstPipeline)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_PIPELINE, GstPipeline);
}
pub inline fn GST_IS_PIPELINE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_PIPELINE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_PIPELINE);
}
pub inline fn GST_PIPELINE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_PIPELINE, GstPipelineClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_PIPELINE, GstPipelineClass);
}
pub inline fn GST_IS_PIPELINE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_PIPELINE)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_PIPELINE);
}
pub inline fn GST_PIPELINE_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_PIPELINE, GstPipelineClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_PIPELINE, GstPipelineClass);
}
pub inline fn GST_PIPELINE_CAST(obj: anytype) [*c]GstPipeline {
    return @import("std").zig.c_translation.cast([*c]GstPipeline, obj);
}
pub const __GST_POLL_H__ = "";
pub const __GST_PRESET_H__ = "";
pub const GST_TYPE_PRESET = gst_preset_get_type();
pub inline fn GST_PRESET(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_PRESET, GstPreset)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_PRESET, GstPreset);
}
pub inline fn GST_IS_PRESET(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_PRESET)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_PRESET);
}
pub inline fn GST_PRESET_GET_INTERFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, GST_TYPE_PRESET, GstPresetInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, GST_TYPE_PRESET, GstPresetInterface);
}
pub const __GST_PROTECTION_H__ = "";
pub const GST_PROTECTION_SYSTEM_ID_CAPS_FIELD = "protection-system";
pub const GST_PROTECTION_UNSPECIFIED_SYSTEM_ID = "unspecified-system-id";
pub const GST_PROTECTION_META_API_TYPE = gst_protection_meta_api_get_type();
pub inline fn gst_buffer_get_protection_meta(b: anytype) [*c]GstProtectionMeta {
    return @import("std").zig.c_translation.cast([*c]GstProtectionMeta, gst_buffer_get_meta(b, GST_PROTECTION_META_API_TYPE));
}
pub const GST_PROTECTION_META_INFO = gst_protection_meta_get_info();
pub const __GST_REGISTRY_H__ = "";
pub const GST_TYPE_REGISTRY = gst_registry_get_type();
pub inline fn GST_REGISTRY(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_REGISTRY, GstRegistry)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_REGISTRY, GstRegistry);
}
pub inline fn GST_IS_REGISTRY(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_REGISTRY)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_REGISTRY);
}
pub inline fn GST_REGISTRY_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_REGISTRY, GstRegistryClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_REGISTRY, GstRegistryClass);
}
pub inline fn GST_IS_REGISTRY_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_REGISTRY)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_REGISTRY);
}
pub inline fn GST_REGISTRY_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_REGISTRY, GstRegistryClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_REGISTRY, GstRegistryClass);
}
pub const __GST_PROMISE_H__ = "";
pub const GST_TYPE_PROMISE = gst_promise_get_type();
pub inline fn GST_PROMISE(obj: anytype) [*c]GstPromise {
    return @import("std").zig.c_translation.cast([*c]GstPromise, obj);
}
pub const __GST_SYSTEM_CLOCK_H__ = "";
pub const GST_TYPE_SYSTEM_CLOCK = gst_system_clock_get_type();
pub inline fn GST_SYSTEM_CLOCK(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_SYSTEM_CLOCK, GstSystemClock)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_SYSTEM_CLOCK, GstSystemClock);
}
pub inline fn GST_SYSTEM_CLOCK_CAST(obj: anytype) [*c]GstSystemClock {
    return @import("std").zig.c_translation.cast([*c]GstSystemClock, obj);
}
pub inline fn GST_IS_SYSTEM_CLOCK(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_SYSTEM_CLOCK)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_SYSTEM_CLOCK);
}
pub inline fn GST_SYSTEM_CLOCK_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_SYSTEM_CLOCK, GstSystemClockClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_SYSTEM_CLOCK, GstSystemClockClass);
}
pub inline fn GST_IS_SYSTEM_CLOCK_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_SYSTEM_CLOCK)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_SYSTEM_CLOCK);
}
pub inline fn GST_SYSTEM_CLOCK_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_SYSTEM_CLOCK, GstSystemClockClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_SYSTEM_CLOCK, GstSystemClockClass);
}
pub const __GST_TAG_SETTER_H__ = "";
pub const GST_TYPE_TAG_SETTER = gst_tag_setter_get_type();
pub inline fn GST_TAG_SETTER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_TAG_SETTER, GstTagSetter)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_TAG_SETTER, GstTagSetter);
}
pub inline fn GST_IS_TAG_SETTER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_TAG_SETTER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_TAG_SETTER);
}
pub inline fn GST_TAG_SETTER_GET_INTERFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, GST_TYPE_TAG_SETTER, GstTagSetterInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, GST_TYPE_TAG_SETTER, GstTagSetterInterface);
}
pub const __GST_TOC_SETTER_H__ = "";
pub const GST_TYPE_TOC_SETTER = gst_toc_setter_get_type();
pub inline fn GST_TOC_SETTER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_TOC_SETTER, GstTocSetter)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_TOC_SETTER, GstTocSetter);
}
pub inline fn GST_IS_TOC_SETTER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_TOC_SETTER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_TOC_SETTER);
}
pub inline fn GST_TOC_SETTER_GET_IFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, GST_TYPE_TOC_SETTER, GstTocSetterInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, GST_TYPE_TOC_SETTER, GstTocSetterInterface);
}
pub const __GST_TRACER_H__ = "";
pub const GST_TYPE_TRACER = gst_tracer_get_type();
pub inline fn GST_TRACER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_TRACER, GstTracer)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_TRACER, GstTracer);
}
pub inline fn GST_TRACER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_TRACER, GstTracerClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_TRACER, GstTracerClass);
}
pub inline fn GST_IS_TRACER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_TRACER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_TRACER);
}
pub inline fn GST_IS_TRACER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_TRACER)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_TRACER);
}
pub inline fn GST_TRACER_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_TRACER, GstTracerClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_TRACER, GstTracerClass);
}
pub inline fn GST_TRACER_CAST(obj: anytype) [*c]GstTracer {
    return @import("std").zig.c_translation.cast([*c]GstTracer, obj);
}
pub const __GST_TRACER_FACTORY_H__ = "";
pub const GST_TYPE_TRACER_FACTORY = gst_tracer_factory_get_type();
pub inline fn GST_TRACER_FACTORY(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_TRACER_FACTORY, GstTracerFactory)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_TRACER_FACTORY, GstTracerFactory);
}
pub inline fn GST_IS_TRACER_FACTORY(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_TRACER_FACTORY)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_TRACER_FACTORY);
}
pub inline fn GST_TRACER_FACTORY_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_TRACER_FACTORY, GstTracerFactoryClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_TRACER_FACTORY, GstTracerFactoryClass);
}
pub inline fn GST_IS_TRACER_FACTORY_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_TRACER_FACTORY)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_TRACER_FACTORY);
}
pub inline fn GST_TRACER_FACTORY_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_TRACER_FACTORY, GstTracerFactoryClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_TRACER_FACTORY, GstTracerFactoryClass);
}
pub inline fn GST_TRACER_FACTORY_CAST(obj: anytype) [*c]GstTracerFactory {
    return @import("std").zig.c_translation.cast([*c]GstTracerFactory, obj);
}
pub const __GST_TRACER_RECORD_H__ = "";
pub const GST_TYPE_TRACER_RECORD = gst_tracer_record_get_type();
pub inline fn GST_TRACER_RECORD(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_TRACER_RECORD, GstTracerRecord)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_TRACER_RECORD, GstTracerRecord);
}
pub inline fn GST_TRACER_RECORD_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_TRACER_RECORD, GstTracerRecordClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_TRACER_RECORD, GstTracerRecordClass);
}
pub inline fn GST_IS_TRACER_RECORD(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_TRACER_RECORD)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_TRACER_RECORD);
}
pub inline fn GST_IS_TRACER_RECORD_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_TRACER_RECORD)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_TRACER_RECORD);
}
pub inline fn GST_TRACER_RECORD_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_TRACER_RECORD, GstTracerRecordClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_TRACER_RECORD, GstTracerRecordClass);
}
pub inline fn GST_TRACER_RECORD_CAST(obj: anytype) [*c]GstTracerRecord {
    return @import("std").zig.c_translation.cast([*c]GstTracerRecord, obj);
}
pub const __GST_TYPE_FIND_H__ = "";
pub const GST_TYPE_TYPE_FIND = gst_type_find_get_type();
pub const __GST_TYPE_FIND_FACTORY_H__ = "";
pub const GST_TYPE_TYPE_FIND_FACTORY = gst_type_find_factory_get_type();
pub inline fn GST_TYPE_FIND_FACTORY(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_TYPE_FIND_FACTORY, GstTypeFindFactory)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_TYPE_FIND_FACTORY, GstTypeFindFactory);
}
pub inline fn GST_IS_TYPE_FIND_FACTORY(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_TYPE_FIND_FACTORY)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_TYPE_FIND_FACTORY);
}
pub inline fn GST_TYPE_FIND_FACTORY_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_TYPE_FIND_FACTORY, GstTypeFindFactoryClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_TYPE_FIND_FACTORY, GstTypeFindFactoryClass);
}
pub inline fn GST_IS_TYPE_FIND_FACTORY_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_TYPE_FIND_FACTORY)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_TYPE_FIND_FACTORY);
}
pub inline fn GST_TYPE_FIND_FACTORY_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_TYPE_FIND_FACTORY, GstTypeFindFactoryClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GST_TYPE_TYPE_FIND_FACTORY, GstTypeFindFactoryClass);
}
pub const __GST_UTILS_H__ = "";
pub const __GST_PARSE_H__ = "";
pub const GST_PARSE_ERROR = gst_parse_error_quark();
pub const GST_TYPE_PARSE_CONTEXT = gst_parse_context_get_type();
pub inline fn gst_gdouble_to_guint64(value: anytype) guint64 {
    return @import("std").zig.c_translation.cast(guint64, value);
}
pub inline fn gst_guint64_to_gdouble(value: anytype) gdouble {
    return @import("std").zig.c_translation.cast(gdouble, value);
}
pub const GST_SEQNUM_INVALID = @as(c_int, 0);
pub const GST_GROUP_ID_INVALID = @as(c_int, 0);
pub inline fn _GST_READ_UINT64_BE(data: anytype) @TypeOf(((((((_GST_GET(data, @as(c_int, 0), @as(c_int, 64), @as(c_int, 56)) | _GST_GET(data, @as(c_int, 1), @as(c_int, 64), @as(c_int, 48))) | _GST_GET(data, @as(c_int, 2), @as(c_int, 64), @as(c_int, 40))) | _GST_GET(data, @as(c_int, 3), @as(c_int, 64), @as(c_int, 32))) | _GST_GET(data, @as(c_int, 4), @as(c_int, 64), @as(c_int, 24))) | _GST_GET(data, @as(c_int, 5), @as(c_int, 64), @as(c_int, 16))) | _GST_GET(data, @as(c_int, 6), @as(c_int, 64), @as(c_int, 8))) | _GST_GET(data, @as(c_int, 7), @as(c_int, 64), @as(c_int, 0))) {
    return ((((((_GST_GET(data, @as(c_int, 0), @as(c_int, 64), @as(c_int, 56)) | _GST_GET(data, @as(c_int, 1), @as(c_int, 64), @as(c_int, 48))) | _GST_GET(data, @as(c_int, 2), @as(c_int, 64), @as(c_int, 40))) | _GST_GET(data, @as(c_int, 3), @as(c_int, 64), @as(c_int, 32))) | _GST_GET(data, @as(c_int, 4), @as(c_int, 64), @as(c_int, 24))) | _GST_GET(data, @as(c_int, 5), @as(c_int, 64), @as(c_int, 16))) | _GST_GET(data, @as(c_int, 6), @as(c_int, 64), @as(c_int, 8))) | _GST_GET(data, @as(c_int, 7), @as(c_int, 64), @as(c_int, 0));
}
pub inline fn _GST_READ_UINT64_LE(data: anytype) @TypeOf(((((((_GST_GET(data, @as(c_int, 7), @as(c_int, 64), @as(c_int, 56)) | _GST_GET(data, @as(c_int, 6), @as(c_int, 64), @as(c_int, 48))) | _GST_GET(data, @as(c_int, 5), @as(c_int, 64), @as(c_int, 40))) | _GST_GET(data, @as(c_int, 4), @as(c_int, 64), @as(c_int, 32))) | _GST_GET(data, @as(c_int, 3), @as(c_int, 64), @as(c_int, 24))) | _GST_GET(data, @as(c_int, 2), @as(c_int, 64), @as(c_int, 16))) | _GST_GET(data, @as(c_int, 1), @as(c_int, 64), @as(c_int, 8))) | _GST_GET(data, @as(c_int, 0), @as(c_int, 64), @as(c_int, 0))) {
    return ((((((_GST_GET(data, @as(c_int, 7), @as(c_int, 64), @as(c_int, 56)) | _GST_GET(data, @as(c_int, 6), @as(c_int, 64), @as(c_int, 48))) | _GST_GET(data, @as(c_int, 5), @as(c_int, 64), @as(c_int, 40))) | _GST_GET(data, @as(c_int, 4), @as(c_int, 64), @as(c_int, 32))) | _GST_GET(data, @as(c_int, 3), @as(c_int, 64), @as(c_int, 24))) | _GST_GET(data, @as(c_int, 2), @as(c_int, 64), @as(c_int, 16))) | _GST_GET(data, @as(c_int, 1), @as(c_int, 64), @as(c_int, 8))) | _GST_GET(data, @as(c_int, 0), @as(c_int, 64), @as(c_int, 0));
}
pub inline fn _GST_READ_UINT32_BE(data: anytype) @TypeOf(((_GST_GET(data, @as(c_int, 0), @as(c_int, 32), @as(c_int, 24)) | _GST_GET(data, @as(c_int, 1), @as(c_int, 32), @as(c_int, 16))) | _GST_GET(data, @as(c_int, 2), @as(c_int, 32), @as(c_int, 8))) | _GST_GET(data, @as(c_int, 3), @as(c_int, 32), @as(c_int, 0))) {
    return ((_GST_GET(data, @as(c_int, 0), @as(c_int, 32), @as(c_int, 24)) | _GST_GET(data, @as(c_int, 1), @as(c_int, 32), @as(c_int, 16))) | _GST_GET(data, @as(c_int, 2), @as(c_int, 32), @as(c_int, 8))) | _GST_GET(data, @as(c_int, 3), @as(c_int, 32), @as(c_int, 0));
}
pub inline fn _GST_READ_UINT32_LE(data: anytype) @TypeOf(((_GST_GET(data, @as(c_int, 3), @as(c_int, 32), @as(c_int, 24)) | _GST_GET(data, @as(c_int, 2), @as(c_int, 32), @as(c_int, 16))) | _GST_GET(data, @as(c_int, 1), @as(c_int, 32), @as(c_int, 8))) | _GST_GET(data, @as(c_int, 0), @as(c_int, 32), @as(c_int, 0))) {
    return ((_GST_GET(data, @as(c_int, 3), @as(c_int, 32), @as(c_int, 24)) | _GST_GET(data, @as(c_int, 2), @as(c_int, 32), @as(c_int, 16))) | _GST_GET(data, @as(c_int, 1), @as(c_int, 32), @as(c_int, 8))) | _GST_GET(data, @as(c_int, 0), @as(c_int, 32), @as(c_int, 0));
}
pub inline fn _GST_READ_UINT24_BE(data: anytype) @TypeOf((_GST_GET(data, @as(c_int, 0), @as(c_int, 32), @as(c_int, 16)) | _GST_GET(data, @as(c_int, 1), @as(c_int, 32), @as(c_int, 8))) | _GST_GET(data, @as(c_int, 2), @as(c_int, 32), @as(c_int, 0))) {
    return (_GST_GET(data, @as(c_int, 0), @as(c_int, 32), @as(c_int, 16)) | _GST_GET(data, @as(c_int, 1), @as(c_int, 32), @as(c_int, 8))) | _GST_GET(data, @as(c_int, 2), @as(c_int, 32), @as(c_int, 0));
}
pub inline fn _GST_READ_UINT24_LE(data: anytype) @TypeOf((_GST_GET(data, @as(c_int, 2), @as(c_int, 32), @as(c_int, 16)) | _GST_GET(data, @as(c_int, 1), @as(c_int, 32), @as(c_int, 8))) | _GST_GET(data, @as(c_int, 0), @as(c_int, 32), @as(c_int, 0))) {
    return (_GST_GET(data, @as(c_int, 2), @as(c_int, 32), @as(c_int, 16)) | _GST_GET(data, @as(c_int, 1), @as(c_int, 32), @as(c_int, 8))) | _GST_GET(data, @as(c_int, 0), @as(c_int, 32), @as(c_int, 0));
}
pub inline fn _GST_READ_UINT16_BE(data: anytype) @TypeOf(_GST_GET(data, @as(c_int, 0), @as(c_int, 16), @as(c_int, 8)) | _GST_GET(data, @as(c_int, 1), @as(c_int, 16), @as(c_int, 0))) {
    return _GST_GET(data, @as(c_int, 0), @as(c_int, 16), @as(c_int, 8)) | _GST_GET(data, @as(c_int, 1), @as(c_int, 16), @as(c_int, 0));
}
pub inline fn _GST_READ_UINT16_LE(data: anytype) @TypeOf(_GST_GET(data, @as(c_int, 1), @as(c_int, 16), @as(c_int, 8)) | _GST_GET(data, @as(c_int, 0), @as(c_int, 16), @as(c_int, 0))) {
    return _GST_GET(data, @as(c_int, 1), @as(c_int, 16), @as(c_int, 8)) | _GST_GET(data, @as(c_int, 0), @as(c_int, 16), @as(c_int, 0));
}
pub inline fn GST_READ_UINT8(data: anytype) @TypeOf(_GST_GET(data, @as(c_int, 0), @as(c_int, 8), @as(c_int, 0))) {
    return _GST_GET(data, @as(c_int, 0), @as(c_int, 8), @as(c_int, 0));
}
pub inline fn GFLOAT_TO_LE(val: anytype) gfloat {
    return @import("std").zig.c_translation.cast(gfloat, val);
}
pub inline fn GFLOAT_TO_BE(val: anytype) @TypeOf(GFLOAT_SWAP_LE_BE(val)) {
    return GFLOAT_SWAP_LE_BE(val);
}
pub inline fn GDOUBLE_TO_LE(val: anytype) gdouble {
    return @import("std").zig.c_translation.cast(gdouble, val);
}
pub inline fn GDOUBLE_TO_BE(val: anytype) @TypeOf(GDOUBLE_SWAP_LE_BE(val)) {
    return GDOUBLE_SWAP_LE_BE(val);
}
pub inline fn GFLOAT_FROM_LE(val: anytype) @TypeOf(GFLOAT_TO_LE(val)) {
    return GFLOAT_TO_LE(val);
}
pub inline fn GFLOAT_FROM_BE(val: anytype) @TypeOf(GFLOAT_TO_BE(val)) {
    return GFLOAT_TO_BE(val);
}
pub inline fn GDOUBLE_FROM_LE(val: anytype) @TypeOf(GDOUBLE_TO_LE(val)) {
    return GDOUBLE_TO_LE(val);
}
pub inline fn GDOUBLE_FROM_BE(val: anytype) @TypeOf(GDOUBLE_TO_BE(val)) {
    return GDOUBLE_TO_BE(val);
}
pub inline fn GST_ROUND_UP_2(num: anytype) @TypeOf((num + @as(c_int, 1)) & ~@as(c_int, 1)) {
    return (num + @as(c_int, 1)) & ~@as(c_int, 1);
}
pub inline fn GST_ROUND_UP_4(num: anytype) @TypeOf((num + @as(c_int, 3)) & ~@as(c_int, 3)) {
    return (num + @as(c_int, 3)) & ~@as(c_int, 3);
}
pub inline fn GST_ROUND_UP_8(num: anytype) @TypeOf((num + @as(c_int, 7)) & ~@as(c_int, 7)) {
    return (num + @as(c_int, 7)) & ~@as(c_int, 7);
}
pub inline fn GST_ROUND_UP_16(num: anytype) @TypeOf((num + @as(c_int, 15)) & ~@as(c_int, 15)) {
    return (num + @as(c_int, 15)) & ~@as(c_int, 15);
}
pub inline fn GST_ROUND_UP_32(num: anytype) @TypeOf((num + @as(c_int, 31)) & ~@as(c_int, 31)) {
    return (num + @as(c_int, 31)) & ~@as(c_int, 31);
}
pub inline fn GST_ROUND_UP_64(num: anytype) @TypeOf((num + @as(c_int, 63)) & ~@as(c_int, 63)) {
    return (num + @as(c_int, 63)) & ~@as(c_int, 63);
}
pub inline fn GST_ROUND_UP_128(num: anytype) @TypeOf((num + @as(c_int, 127)) & ~@as(c_int, 127)) {
    return (num + @as(c_int, 127)) & ~@as(c_int, 127);
}
pub inline fn GST_ROUND_UP_N(num: anytype, @"align": anytype) @TypeOf((num + (@"align" - @as(c_int, 1))) & ~(@"align" - @as(c_int, 1))) {
    return (num + (@"align" - @as(c_int, 1))) & ~(@"align" - @as(c_int, 1));
}
pub inline fn GST_ROUND_DOWN_2(num: anytype) @TypeOf(num & ~@as(c_int, 1)) {
    return num & ~@as(c_int, 1);
}
pub inline fn GST_ROUND_DOWN_4(num: anytype) @TypeOf(num & ~@as(c_int, 3)) {
    return num & ~@as(c_int, 3);
}
pub inline fn GST_ROUND_DOWN_8(num: anytype) @TypeOf(num & ~@as(c_int, 7)) {
    return num & ~@as(c_int, 7);
}
pub inline fn GST_ROUND_DOWN_16(num: anytype) @TypeOf(num & ~@as(c_int, 15)) {
    return num & ~@as(c_int, 15);
}
pub inline fn GST_ROUND_DOWN_32(num: anytype) @TypeOf(num & ~@as(c_int, 31)) {
    return num & ~@as(c_int, 31);
}
pub inline fn GST_ROUND_DOWN_64(num: anytype) @TypeOf(num & ~@as(c_int, 63)) {
    return num & ~@as(c_int, 63);
}
pub inline fn GST_ROUND_DOWN_128(num: anytype) @TypeOf(num & ~@as(c_int, 127)) {
    return num & ~@as(c_int, 127);
}
pub inline fn GST_ROUND_DOWN_N(num: anytype, @"align": anytype) @TypeOf(num & ~(@"align" - @as(c_int, 1))) {
    return num & ~(@"align" - @as(c_int, 1));
}
pub const __GSTCOMPAT_H__ = "";
pub inline fn gst_buffer_new_and_alloc(s: anytype) @TypeOf(gst_buffer_new_allocate(NULL, s, NULL)) {
    return gst_buffer_new_allocate(NULL, s, NULL);
}
pub const GST_BUFFER_TIMESTAMP = GST_BUFFER_PTS;
pub const GST_BUFFER_TIMESTAMP_IS_VALID = GST_BUFFER_PTS_IS_VALID;
pub const gst_element_class_set_details_simple = gst_element_class_set_metadata;
pub inline fn gst_element_factory_get_longname(f: anytype) @TypeOf(gst_element_factory_get_metadata(f, GST_ELEMENT_METADATA_LONGNAME)) {
    return gst_element_factory_get_metadata(f, GST_ELEMENT_METADATA_LONGNAME);
}
pub inline fn gst_element_factory_get_klass(f: anytype) @TypeOf(gst_element_factory_get_metadata(f, GST_ELEMENT_METADATA_KLASS)) {
    return gst_element_factory_get_metadata(f, GST_ELEMENT_METADATA_KLASS);
}
pub inline fn gst_element_factory_get_description(f: anytype) @TypeOf(gst_element_factory_get_metadata(f, GST_ELEMENT_METADATA_DESCRIPTION)) {
    return gst_element_factory_get_metadata(f, GST_ELEMENT_METADATA_DESCRIPTION);
}
pub inline fn gst_element_factory_get_author(f: anytype) @TypeOf(gst_element_factory_get_metadata(f, GST_ELEMENT_METADATA_AUTHOR)) {
    return gst_element_factory_get_metadata(f, GST_ELEMENT_METADATA_AUTHOR);
}
pub inline fn gst_element_factory_get_documentation_uri(f: anytype) @TypeOf(gst_element_factory_get_metadata(f, GST_ELEMENT_METADATA_DOC_URI)) {
    return gst_element_factory_get_metadata(f, GST_ELEMENT_METADATA_DOC_URI);
}
pub inline fn gst_element_factory_get_icon_name(f: anytype) @TypeOf(gst_element_factory_get_metadata(f, GST_ELEMENT_METADATA_ICON_NAME)) {
    return gst_element_factory_get_metadata(f, GST_ELEMENT_METADATA_ICON_NAME);
}
pub inline fn gst_tag_list_free(taglist: anytype) @TypeOf(gst_tag_list_unref(taglist)) {
    return gst_tag_list_unref(taglist);
}
pub const GST_MESSAGE_DURATION = GST_MESSAGE_DURATION_CHANGED;
pub inline fn gst_message_new_duration(src: anytype, fmt: anytype, dur: anytype) @TypeOf(gst_message_new_duration_changed(src)) {
    _ = fmt;
    _ = dur;
    return gst_message_new_duration_changed(src);
}
pub const tm = struct_tm;
pub const timespec = struct_timespec;
pub const itimerspec = struct_itimerspec;
pub const sigval = union_sigval;
pub const sigevent = struct_sigevent;
pub const __locale_data = struct___locale_data;
pub const __locale_struct = struct___locale_struct;
pub const _GDoubleIEEE754 = union__GDoubleIEEE754;
pub const _GFloatIEEE754 = union__GFloatIEEE754;
pub const _GTimeVal = struct__GTimeVal;
pub const _GBytes = struct__GBytes;
pub const _GArray = struct__GArray;
pub const _GByteArray = struct__GByteArray;
pub const _GPtrArray = struct__GPtrArray;
pub const __va_list = struct___va_list;
pub const _GError = struct__GError;
pub const _GDebugKey = struct__GDebugKey;
pub const timeval = struct_timeval;
pub const __pthread_internal_list = struct___pthread_internal_list;
pub const __pthread_internal_slist = struct___pthread_internal_slist;
pub const __pthread_mutex_s = struct___pthread_mutex_s;
pub const __pthread_rwlock_arch_t = struct___pthread_rwlock_arch_t;
pub const __pthread_cond_s = struct___pthread_cond_s;
pub const random_data = struct_random_data;
pub const drand48_data = struct_drand48_data;
pub const _GThread = struct__GThread;
pub const _GMutex = union__GMutex;
pub const _GRecMutex = struct__GRecMutex;
pub const _GRWLock = struct__GRWLock;
pub const _GCond = struct__GCond;
pub const _GPrivate = struct__GPrivate;
pub const _GOnce = struct__GOnce;
pub const _GAsyncQueue = struct__GAsyncQueue;
pub const sigcontext = struct_sigcontext;
pub const _aarch64_ctx = struct__aarch64_ctx;
pub const fpsimd_context = struct_fpsimd_context;
pub const esr_context = struct_esr_context;
pub const extra_context = struct_extra_context;
pub const sve_context = struct_sve_context;
pub const __itimer_which = enum___itimer_which;
pub const itimerval = struct_itimerval;
pub const user_regs_struct = struct_user_regs_struct;
pub const user_fpsimd_struct = struct_user_fpsimd_struct;
pub const elf_siginfo = struct_elf_siginfo;
pub const elf_prstatus = struct_elf_prstatus;
pub const elf_prpsinfo = struct_elf_prpsinfo;
pub const _GTimeZone = struct__GTimeZone;
pub const _GDateTime = struct__GDateTime;
pub const _GBookmarkFile = struct__GBookmarkFile;
pub const _GChecksum = struct__GChecksum;
pub const _GIConv = struct__GIConv;
pub const _GData = struct__GData;
pub const _GDate = struct__GDate;
pub const dirent = struct_dirent;
pub const __dirstream = struct___dirstream;
pub const _GDir = struct__GDir;
pub const _GMemVTable = struct__GMemVTable;
pub const _GNode = struct__GNode;
pub const _GList = struct__GList;
pub const _GHashTable = struct__GHashTable;
pub const _GHashTableIter = struct__GHashTableIter;
pub const _GHmac = struct__GHmac;
pub const _GHook = struct__GHook;
pub const _GHookList = struct__GHookList;
pub const _GPollFD = struct__GPollFD;
pub const _GSList = struct__GSList;
pub const _GMainContext = struct__GMainContext;
pub const _GMainLoop = struct__GMainLoop;
pub const _GSourceCallbackFuncs = struct__GSourceCallbackFuncs;
pub const _GSourceFuncs = struct__GSourceFuncs;
pub const _GSourcePrivate = struct__GSourcePrivate;
pub const _GSource = struct__GSource;
pub const _GString = struct__GString;
pub const _GIOFuncs = struct__GIOFuncs;
pub const _GIOChannel = struct__GIOChannel;
pub const _GKeyFile = struct__GKeyFile;
pub const _GMappedFile = struct__GMappedFile;
pub const _GMarkupParseContext = struct__GMarkupParseContext;
pub const _GMarkupParser = struct__GMarkupParser;
pub const _GVariantType = struct__GVariantType;
pub const _GVariant = struct__GVariant;
pub const _GVariantIter = struct__GVariantIter;
pub const _GVariantBuilder = struct__GVariantBuilder;
pub const _GVariantDict = struct__GVariantDict;
pub const _GLogField = struct__GLogField;
pub const _GOptionContext = struct__GOptionContext;
pub const _GOptionGroup = struct__GOptionGroup;
pub const _GOptionEntry = struct__GOptionEntry;
pub const _GPatternSpec = struct__GPatternSpec;
pub const _GQueue = struct__GQueue;
pub const _GRand = struct__GRand;
pub const _GRegex = struct__GRegex;
pub const _GMatchInfo = struct__GMatchInfo;
pub const _GScannerConfig = struct__GScannerConfig;
pub const _GTokenValue = union__GTokenValue;
pub const _GScanner = struct__GScanner;
pub const _GSequence = struct__GSequence;
pub const _GSequenceNode = struct__GSequenceNode;
pub const _GStringChunk = struct__GStringChunk;
pub const _GStrvBuilder = struct__GStrvBuilder;
pub const _GThreadPool = struct__GThreadPool;
pub const _GTimer = struct__GTimer;
pub const _GTrashStack = struct__GTrashStack;
pub const _GTree = struct__GTree;
pub const _GTreeNode = struct__GTreeNode;
pub const _GUri = struct__GUri;
pub const _GUriParamsIter = struct__GUriParamsIter;
pub const _GAllocator = struct__GAllocator;
pub const _GMemChunk = struct__GMemChunk;
pub const _GCache = struct__GCache;
pub const _GCompletion = struct__GCompletion;
pub const _GRelation = struct__GRelation;
pub const _GTuples = struct__GTuples;
pub const _GThreadFunctions = struct__GThreadFunctions;
pub const sched_param = struct_sched_param;
pub const __jmp_buf_tag = struct___jmp_buf_tag;
pub const _pthread_cleanup_buffer = struct__pthread_cleanup_buffer;
pub const __cancel_jmp_buf_tag = struct___cancel_jmp_buf_tag;
pub const __pthread_cleanup_frame = struct___pthread_cleanup_frame;
pub const _GStaticRecMutex = struct__GStaticRecMutex;
pub const _GStaticRWLock = struct__GStaticRWLock;
pub const _GStaticPrivate = struct__GStaticPrivate;
pub const _GValue = struct__GValue;
pub const _GTypeCValue = union__GTypeCValue;
pub const _GTypePlugin = struct__GTypePlugin;
pub const _GTypeClass = struct__GTypeClass;
pub const _GTypeInterface = struct__GTypeInterface;
pub const _GTypeInstance = struct__GTypeInstance;
pub const _GTypeValueTable = struct__GTypeValueTable;
pub const _GTypeInfo = struct__GTypeInfo;
pub const _GTypeFundamentalInfo = struct__GTypeFundamentalInfo;
pub const _GInterfaceInfo = struct__GInterfaceInfo;
pub const _GTypeQuery = struct__GTypeQuery;
pub const _GParamSpec = struct__GParamSpec;
pub const _GParamSpecClass = struct__GParamSpecClass;
pub const _GParameter = struct__GParameter;
pub const _GParamSpecPool = struct__GParamSpecPool;
pub const _GParamSpecTypeInfo = struct__GParamSpecTypeInfo;
pub const _GClosure = struct__GClosure;
pub const _GClosureNotifyData = struct__GClosureNotifyData;
pub const _GCClosure = struct__GCClosure;
pub const _GSignalQuery = struct__GSignalQuery;
pub const _GSignalInvocationHint = struct__GSignalInvocationHint;
pub const _GObject = struct__GObject;
pub const _GObjectConstructParam = struct__GObjectConstructParam;
pub const _GObjectClass = struct__GObjectClass;
pub const _GBinding = struct__GBinding;
pub const _GBindingGroup = struct__GBindingGroup;
pub const _GEnumValue = struct__GEnumValue;
pub const _GEnumClass = struct__GEnumClass;
pub const _GFlagsValue = struct__GFlagsValue;
pub const _GFlagsClass = struct__GFlagsClass;
pub const _GParamSpecChar = struct__GParamSpecChar;
pub const _GParamSpecUChar = struct__GParamSpecUChar;
pub const _GParamSpecBoolean = struct__GParamSpecBoolean;
pub const _GParamSpecInt = struct__GParamSpecInt;
pub const _GParamSpecUInt = struct__GParamSpecUInt;
pub const _GParamSpecLong = struct__GParamSpecLong;
pub const _GParamSpecULong = struct__GParamSpecULong;
pub const _GParamSpecInt64 = struct__GParamSpecInt64;
pub const _GParamSpecUInt64 = struct__GParamSpecUInt64;
pub const _GParamSpecUnichar = struct__GParamSpecUnichar;
pub const _GParamSpecEnum = struct__GParamSpecEnum;
pub const _GParamSpecFlags = struct__GParamSpecFlags;
pub const _GParamSpecFloat = struct__GParamSpecFloat;
pub const _GParamSpecDouble = struct__GParamSpecDouble;
pub const _GParamSpecString = struct__GParamSpecString;
pub const _GParamSpecParam = struct__GParamSpecParam;
pub const _GParamSpecBoxed = struct__GParamSpecBoxed;
pub const _GParamSpecPointer = struct__GParamSpecPointer;
pub const _GParamSpecValueArray = struct__GParamSpecValueArray;
pub const _GParamSpecObject = struct__GParamSpecObject;
pub const _GParamSpecOverride = struct__GParamSpecOverride;
pub const _GParamSpecGType = struct__GParamSpecGType;
pub const _GParamSpecVariant = struct__GParamSpecVariant;
pub const _GSignalGroup = struct__GSignalGroup;
pub const _GTypeModule = struct__GTypeModule;
pub const _GTypeModuleClass = struct__GTypeModuleClass;
pub const _GTypePluginClass = struct__GTypePluginClass;
pub const _GValueArray = struct__GValueArray;
pub const _GstAtomicQueue = struct__GstAtomicQueue;
pub const _GstObject = struct__GstObject;
pub const _GstBusPrivate = struct__GstBusPrivate;
pub const _GstBus = struct__GstBus;
pub const _GstClockPrivate = struct__GstClockPrivate;
pub const _GstClock = struct__GstClock;
pub const _GstElement = struct__GstElement;
pub const _GstObjectClass = struct__GstObjectClass;
pub const _GstElementFactory = struct__GstElementFactory;
pub const _GstMiniObject = struct__GstMiniObject;
pub const _GstCaps = struct__GstCaps;
pub const _GstPadTemplate = struct__GstPadTemplate;
pub const _GstTaskPrivate = struct__GstTaskPrivate;
pub const _GstTask = struct__GstTask;
pub const _GstBufferPoolPrivate = struct__GstBufferPoolPrivate;
pub const _GstBufferPool = struct__GstBufferPool;
pub const _GstBuffer = struct__GstBuffer;
pub const _GstBufferList = struct__GstBufferList;
pub const _GstEvent = struct__GstEvent;
pub const _GstQuery = struct__GstQuery;
pub const _GstIterator = struct__GstIterator;
pub const _GstPadPrivate = struct__GstPadPrivate;
pub const _GstPad = struct__GstPad;
pub const _GstMessage = struct__GstMessage;
pub const _GstContext = struct__GstContext;
pub const _GstElementClass = struct__GstElementClass;
pub const _GstControlBindingPrivate = struct__GstControlBindingPrivate;
pub const _GstControlBinding = struct__GstControlBinding;
pub const _GstControlBindingClass = struct__GstControlBindingClass;
pub const _GstClockEntry = struct__GstClockEntry;
pub const _GstClockClass = struct__GstClockClass;
pub const _GstControlSource = struct__GstControlSource;
pub const _GstControlSourceClass = struct__GstControlSourceClass;
pub const _GstTimedValue = struct__GstTimedValue;
pub const _GstValueArray = struct__GstValueArray;
pub const _GstPadClass = struct__GstPadClass;
pub const _GstPadProbeInfo = struct__GstPadProbeInfo;
pub const _GstAllocatorPrivate = struct__GstAllocatorPrivate;
pub const _GstAllocator = struct__GstAllocator;
pub const _GstMemory = struct__GstMemory;
pub const _GstAllocationParams = struct__GstAllocationParams;
pub const _GstAllocatorClass = struct__GstAllocatorClass;
pub const _GstDateTime = struct__GstDateTime;
pub const _GstStructure = struct__GstStructure;
pub const _GstCapsFeatures = struct__GstCapsFeatures;
pub const _GstStaticCaps = struct__GstStaticCaps;
pub const _GstMetaInfo = struct__GstMetaInfo;
pub const _GstMeta = struct__GstMeta;
pub const _GstParentBufferMeta = struct__GstParentBufferMeta;
pub const _GstReferenceTimestampMeta = struct__GstReferenceTimestampMeta;
pub const _GstPadTemplateClass = struct__GstPadTemplateClass;
pub const _GstStaticPadTemplate = struct__GstStaticPadTemplate;
pub const _GstFormatDefinition = struct__GstFormatDefinition;
pub const _GstSegment = struct__GstSegment;
pub const _GstSample = struct__GstSample;
pub const _GstTagList = struct__GstTagList;
pub const _GstTocEntry = struct__GstTocEntry;
pub const _GstToc = struct__GstToc;
pub const _GstDevicePrivate = struct__GstDevicePrivate;
pub const _GstDevice = struct__GstDevice;
pub const _GstDeviceClass = struct__GstDeviceClass;
pub const _GstStreamPrivate = struct__GstStreamPrivate;
pub const _GstStream = struct__GstStream;
pub const _GstStreamClass = struct__GstStreamClass;
pub const _GstStreamCollectionPrivate = struct__GstStreamCollectionPrivate;
pub const _GstStreamCollection = struct__GstStreamCollection;
pub const _GstStreamCollectionClass = struct__GstStreamCollectionClass;
pub const _GstTaskPool = struct__GstTaskPool;
pub const _GstTaskPoolClass = struct__GstTaskPoolClass;
pub const _GstSharedTaskPoolPrivate = struct__GstSharedTaskPoolPrivate;
pub const _GstSharedTaskPool = struct__GstSharedTaskPool;
pub const _GstSharedTaskPoolClass = struct__GstSharedTaskPoolClass;
pub const _GstTaskClass = struct__GstTaskClass;
pub const _GstBusClass = struct__GstBusClass;
pub const _GstElementFactoryClass = struct__GstElementFactoryClass;
pub const _GstPlugin = struct__GstPlugin;
pub const _GstPluginClass = struct__GstPluginClass;
pub const _GstPluginDesc = struct__GstPluginDesc;
pub const _GstPluginFeature = struct__GstPluginFeature;
pub const _GstPluginFeatureClass = struct__GstPluginFeatureClass;
pub const _GstURIHandler = struct__GstURIHandler;
pub const _GstURIHandlerInterface = struct__GstURIHandlerInterface;
pub const _GstUri = struct__GstUri;
pub const _GstBinPrivate = struct__GstBinPrivate;
pub const _GstBin = struct__GstBin;
pub const _GstBinClass = struct__GstBinClass;
pub const _GstBufferPoolAcquireParams = struct__GstBufferPoolAcquireParams;
pub const _GstBufferPoolClass = struct__GstBufferPoolClass;
pub const _GstChildProxy = struct__GstChildProxy;
pub const _GstChildProxyInterface = struct__GstChildProxyInterface;
pub const _GstDeviceProviderPrivate = struct__GstDeviceProviderPrivate;
pub const _GstDeviceProvider = struct__GstDeviceProvider;
pub const _GstDeviceProviderFactory = struct__GstDeviceProviderFactory;
pub const _GstDeviceProviderClass = struct__GstDeviceProviderClass;
pub const _GstDeviceProviderFactoryClass = struct__GstDeviceProviderFactoryClass;
pub const _GstDeviceMonitorPrivate = struct__GstDeviceMonitorPrivate;
pub const _GstDeviceMonitor = struct__GstDeviceMonitor;
pub const _GstDeviceMonitorClass = struct__GstDeviceMonitorClass;
pub const _GstDynamicTypeFactory = struct__GstDynamicTypeFactory;
pub const _GstDynamicTypeFactoryClass = struct__GstDynamicTypeFactoryClass;
pub const _GstProxyPadPrivate = struct__GstProxyPadPrivate;
pub const _GstProxyPad = struct__GstProxyPad;
pub const _GstProxyPadClass = struct__GstProxyPadClass;
pub const _GstGhostPadPrivate = struct__GstGhostPadPrivate;
pub const _GstGhostPad = struct__GstGhostPad;
pub const _GstGhostPadClass = struct__GstGhostPadClass;
pub const _GstDebugCategory = struct__GstDebugCategory;
pub const _GstDebugMessage = struct__GstDebugMessage;
pub const _GstValueTable = struct__GstValueTable;
pub const _GstParamSpecFraction = struct__GstParamSpecFraction;
pub const _GstParamSpecArray = struct__GstParamSpecArray;
pub const _GstPipelinePrivate = struct__GstPipelinePrivate;
pub const _GstPipeline = struct__GstPipeline;
pub const _GstPipelineClass = struct__GstPipelineClass;
pub const _GstPoll = struct__GstPoll;
pub const _GstPreset = struct__GstPreset;
pub const _GstPresetInterface = struct__GstPresetInterface;
pub const _GstProtectionMeta = struct__GstProtectionMeta;
pub const _GstRegistryPrivate = struct__GstRegistryPrivate;
pub const _GstRegistry = struct__GstRegistry;
pub const _GstRegistryClass = struct__GstRegistryClass;
pub const _GstPromise = struct__GstPromise;
pub const _GstSystemClockPrivate = struct__GstSystemClockPrivate;
pub const _GstSystemClock = struct__GstSystemClock;
pub const _GstSystemClockClass = struct__GstSystemClockClass;
pub const _GstTagSetter = struct__GstTagSetter;
pub const _GstTagSetterInterface = struct__GstTagSetterInterface;
pub const _GstTocSetter = struct__GstTocSetter;
pub const _GstTocSetterInterface = struct__GstTocSetterInterface;
pub const _GstTracerPrivate = struct__GstTracerPrivate;
pub const _GstTracer = struct__GstTracer;
pub const _GstTracerClass = struct__GstTracerClass;
pub const _GstTracerFactory = struct__GstTracerFactory;
pub const _GstTracerFactoryClass = struct__GstTracerFactoryClass;
pub const _GstTracerRecord = struct__GstTracerRecord;
pub const _GstTracerRecordClass = struct__GstTracerRecordClass;
pub const _GstTypeFind = struct__GstTypeFind;
pub const _GstTypeFindFactory = struct__GstTypeFindFactory;
pub const _GstTypeFindFactoryClass = struct__GstTypeFindFactoryClass;
pub const _GstParseContext = struct__GstParseContext;
